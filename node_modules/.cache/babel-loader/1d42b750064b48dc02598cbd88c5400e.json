{"ast":null,"code":"/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nimport { CryptoUtils } from \"./CryptoUtils\";\nimport { StringUtils } from \"./StringUtils\";\nimport { TimeUtils } from \"./TimeUtils\";\n/**\r\n * @hidden\r\n */\n\nvar TokenUtils =\n/** @class */\nfunction () {\n  function TokenUtils() {}\n  /**\r\n   * decode a JWT\r\n   *\r\n   * @param jwtToken\r\n   */\n\n\n  TokenUtils.decodeJwt = function (jwtToken) {\n    if (StringUtils.isEmpty(jwtToken)) {\n      return null;\n    }\n\n    var idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\n    var matches = idTokenPartsRegex.exec(jwtToken);\n\n    if (!matches || matches.length < 4) {\n      // this._requestContext.logger.warn(\"The returned id_token is not parseable.\");\n      return null;\n    }\n\n    var crackedToken = {\n      header: matches[1],\n      JWSPayload: matches[2],\n      JWSSig: matches[3]\n    };\n    return crackedToken;\n  };\n  /**\r\n   * Evaluates whether token cache item expiration is within expiration offset range\r\n   * @param tokenCacheItem\r\n   */\n\n\n  TokenUtils.validateExpirationIsWithinOffset = function (expiration, tokenRenewalOffsetSeconds) {\n    var offset = tokenRenewalOffsetSeconds || 300;\n    return expiration && expiration > TimeUtils.now() + offset;\n  };\n  /**\r\n   * Extract IdToken by decoding the RAWIdToken\r\n   *\r\n   * @param encodedIdToken\r\n   */\n\n\n  TokenUtils.extractIdToken = function (encodedIdToken) {\n    // id token will be decoded to get the username\n    var decodedToken = this.decodeJwt(encodedIdToken);\n\n    if (!decodedToken) {\n      return null;\n    }\n\n    try {\n      var base64IdToken = decodedToken.JWSPayload;\n      var base64Decoded = CryptoUtils.base64Decode(base64IdToken);\n\n      if (!base64Decoded) {\n        // this._requestContext.logger.info(\"The returned id_token could not be base64 url safe decoded.\");\n        return null;\n      } // ECMA script has JSON built-in support\n\n\n      return JSON.parse(base64Decoded);\n    } catch (err) {// this._requestContext.logger.error(\"The returned id_token could not be decoded\" + err);\n    }\n\n    return null;\n  };\n\n  return TokenUtils;\n}();\n\nexport { TokenUtils };","map":{"version":3,"sources":["../../src/utils/TokenUtils.ts"],"names":[],"mappings":"AAAA;;;AAGG;AAEH,SAAS,WAAT,QAA4B,eAA5B;AACA,SAAS,WAAT,QAA4B,eAA5B;AACA,SAAS,SAAT,QAA0B,aAA1B;AAEA;;AAEG;;AACH,IAAA,UAAA;AAAA;AAAA,YAAA;AAAA,WAAA,UAAA,GAAA,CA4DC;AA1DG;;;;AAIG;;;AACI,EAAA,UAAA,CAAA,SAAA,GAAP,UAAiB,QAAjB,EAAiC;AAC7B,QAAI,WAAW,CAAC,OAAZ,CAAoB,QAApB,CAAJ,EAAmC;AAC/B,aAAO,IAAP;AACH;;AACD,QAAM,iBAAiB,GAAG,sCAA1B;AACA,QAAM,OAAO,GAAG,iBAAiB,CAAC,IAAlB,CAAuB,QAAvB,CAAhB;;AACA,QAAI,CAAC,OAAD,IAAY,OAAO,CAAC,MAAR,GAAiB,CAAjC,EAAoC;AAChC;AACA,aAAO,IAAP;AACH;;AACD,QAAM,YAAY,GAAG;AACjB,MAAA,MAAM,EAAE,OAAO,CAAC,CAAD,CADE;AAEjB,MAAA,UAAU,EAAE,OAAO,CAAC,CAAD,CAFF;AAGjB,MAAA,MAAM,EAAE,OAAO,CAAC,CAAD;AAHE,KAArB;AAKA,WAAO,YAAP;AACH,GAhBM;AAkBP;;;AAGG;;;AACI,EAAA,UAAA,CAAA,gCAAA,GAAP,UAAwC,UAAxC,EAA4D,yBAA5D,EAA6F;AACzF,QAAM,MAAM,GAAG,yBAAyB,IAAI,GAA5C;AACA,WAAO,UAAU,IAAK,UAAU,GAAG,SAAS,CAAC,GAAV,KAAkB,MAArD;AACH,GAHM;AAKP;;;;AAIG;;;AACI,EAAA,UAAA,CAAA,cAAA,GAAP,UAAsB,cAAtB,EAA4C;AAC5C;AACI,QAAM,YAAY,GAAG,KAAK,SAAL,CAAe,cAAf,CAArB;;AACA,QAAI,CAAC,YAAL,EAAmB;AACf,aAAO,IAAP;AACH;;AACD,QAAI;AACA,UAAM,aAAa,GAAG,YAAY,CAAC,UAAnC;AACA,UAAM,aAAa,GAAG,WAAW,CAAC,YAAZ,CAAyB,aAAzB,CAAtB;;AACA,UAAI,CAAC,aAAL,EAAoB;AAChB;AACA,eAAO,IAAP;AACH,OAND,CAOA;;;AACA,aAAO,IAAI,CAAC,KAAL,CAAW,aAAX,CAAP;AACH,KATD,CASE,OAAO,GAAP,EAAY,CACV;AACH;;AAED,WAAO,IAAP;AACH,GApBM;;AAqBX,SAAA,UAAA;AAAC,CA5DD,EAAA","sourceRoot":"","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { CryptoUtils } from \"./CryptoUtils\";\r\nimport { StringUtils } from \"./StringUtils\";\r\nimport { TimeUtils } from \"./TimeUtils\";\r\n/**\r\n * @hidden\r\n */\r\nvar TokenUtils = /** @class */ (function () {\r\n    function TokenUtils() {\r\n    }\r\n    /**\r\n     * decode a JWT\r\n     *\r\n     * @param jwtToken\r\n     */\r\n    TokenUtils.decodeJwt = function (jwtToken) {\r\n        if (StringUtils.isEmpty(jwtToken)) {\r\n            return null;\r\n        }\r\n        var idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\r\n        var matches = idTokenPartsRegex.exec(jwtToken);\r\n        if (!matches || matches.length < 4) {\r\n            // this._requestContext.logger.warn(\"The returned id_token is not parseable.\");\r\n            return null;\r\n        }\r\n        var crackedToken = {\r\n            header: matches[1],\r\n            JWSPayload: matches[2],\r\n            JWSSig: matches[3]\r\n        };\r\n        return crackedToken;\r\n    };\r\n    /**\r\n     * Evaluates whether token cache item expiration is within expiration offset range\r\n     * @param tokenCacheItem\r\n     */\r\n    TokenUtils.validateExpirationIsWithinOffset = function (expiration, tokenRenewalOffsetSeconds) {\r\n        var offset = tokenRenewalOffsetSeconds || 300;\r\n        return expiration && (expiration > TimeUtils.now() + offset);\r\n    };\r\n    /**\r\n     * Extract IdToken by decoding the RAWIdToken\r\n     *\r\n     * @param encodedIdToken\r\n     */\r\n    TokenUtils.extractIdToken = function (encodedIdToken) {\r\n        // id token will be decoded to get the username\r\n        var decodedToken = this.decodeJwt(encodedIdToken);\r\n        if (!decodedToken) {\r\n            return null;\r\n        }\r\n        try {\r\n            var base64IdToken = decodedToken.JWSPayload;\r\n            var base64Decoded = CryptoUtils.base64Decode(base64IdToken);\r\n            if (!base64Decoded) {\r\n                // this._requestContext.logger.info(\"The returned id_token could not be base64 url safe decoded.\");\r\n                return null;\r\n            }\r\n            // ECMA script has JSON built-in support\r\n            return JSON.parse(base64Decoded);\r\n        }\r\n        catch (err) {\r\n            // this._requestContext.logger.error(\"The returned id_token could not be decoded\" + err);\r\n        }\r\n        return null;\r\n    };\r\n    return TokenUtils;\r\n}());\r\nexport { TokenUtils };\r\n//# sourceMappingURL=TokenUtils.js.map"]},"metadata":{},"sourceType":"module"}