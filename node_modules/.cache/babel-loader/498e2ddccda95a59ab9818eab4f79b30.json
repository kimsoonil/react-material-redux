{"ast":null,"code":"/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nimport * as tslib_1 from \"tslib\";\nimport { AccessTokenKey } from \"./cache/AccessTokenKey\";\nimport { AccessTokenValue } from \"./cache/AccessTokenValue\";\nimport { ServerRequestParameters } from \"./ServerRequestParameters\";\nimport { AuthorityType } from \"./authority/Authority\";\nimport { ClientInfo } from \"./ClientInfo\";\nimport { IdToken } from \"./IdToken\";\nimport { AuthCache } from \"./cache/AuthCache\";\nimport { Account } from \"./Account\";\nimport { ScopeSet } from \"./ScopeSet\";\nimport { StringUtils } from \"./utils/StringUtils\";\nimport { WindowUtils } from \"./utils/WindowUtils\";\nimport { TokenUtils } from \"./utils/TokenUtils\";\nimport { TimeUtils } from \"./utils/TimeUtils\";\nimport { UrlUtils } from \"./utils/UrlUtils\";\nimport { RequestUtils } from \"./utils/RequestUtils\";\nimport { ResponseUtils } from \"./utils/ResponseUtils\";\nimport { AuthorityFactory } from \"./authority/AuthorityFactory\";\nimport { buildConfiguration } from \"./Configuration\";\nimport { ClientConfigurationError } from \"./error/ClientConfigurationError\";\nimport { AuthError } from \"./error/AuthError\";\nimport { ClientAuthError, ClientAuthErrorMessage } from \"./error/ClientAuthError\";\nimport { ServerError } from \"./error/ServerError\";\nimport { InteractionRequiredAuthError } from \"./error/InteractionRequiredAuthError\";\nimport { buildResponseStateOnly } from \"./AuthResponse\";\nimport TelemetryManager from \"./telemetry/TelemetryManager\";\nimport { API_EVENT_IDENTIFIER } from \"./telemetry/ApiEvent\";\nimport { Constants, ServerHashParamKeys, ResponseTypes, TemporaryCacheKeys, PersistentCacheKeys, ErrorCacheKeys, FramePrefix } from \"./utils/Constants\";\nimport { CryptoUtils } from \"./utils/CryptoUtils\";\nimport { TrustedAuthority } from \"./authority/TrustedAuthority\";\nimport { AuthCacheUtils } from \"./utils/AuthCacheUtils\"; // default authority\n\nvar DEFAULT_AUTHORITY = \"https://login.microsoftonline.com/common\";\n/**\r\n * UserAgentApplication class\r\n *\r\n * Object Instance that the developer can use to make loginXX OR acquireTokenXX functions\r\n */\n\nvar UserAgentApplication =\n/** @class */\nfunction () {\n  /**\r\n   * @constructor\r\n   * Constructor for the UserAgentApplication used to instantiate the UserAgentApplication object\r\n   *\r\n   * Important attributes in the Configuration object for auth are:\r\n   * - clientID: the application ID of your application.\r\n   * You can obtain one by registering your application with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview\r\n   * - authority: the authority URL for your application.\r\n   *\r\n   * In Azure AD, authority is a URL indicating the Azure active directory that MSAL uses to obtain tokens.\r\n   * It is of the form https://login.microsoftonline.com/&lt;Enter_the_Tenant_Info_Here&gt;.\r\n   * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\r\n   * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\r\n   * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\r\n   * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\r\n   *\r\n   *\r\n   * In Azure B2C, authority is of the form https://&lt;instance&gt;/tfp/&lt;tenant&gt;/&lt;policyName&gt;/\r\n   *\r\n   * @param {@link (Configuration:type)} configuration object for the MSAL UserAgentApplication instance\r\n   */\n  function UserAgentApplication(configuration) {\n    // callbacks for token/error\n    this.authResponseCallback = null;\n    this.tokenReceivedCallback = null;\n    this.errorReceivedCallback = null; // Set the Configuration\n\n    this.config = buildConfiguration(configuration);\n    this.logger = this.config.system.logger;\n    this.clientId = this.config.auth.clientId;\n    this.inCookie = this.config.cache.storeAuthStateInCookie;\n    this.telemetryManager = this.getTelemetryManagerFromConfig(this.config.system.telemetry, this.clientId);\n    TrustedAuthority.setTrustedAuthoritiesFromConfig(this.config.auth.validateAuthority, this.config.auth.knownAuthorities);\n    AuthorityFactory.saveMetadataFromConfig(this.config.auth.authority, this.config.auth.authorityMetadata); // if no authority is passed, set the default: \"https://login.microsoftonline.com/common\"\n\n    this.authority = this.config.auth.authority || DEFAULT_AUTHORITY; // cache keys msal - typescript throws an error if any value other than \"localStorage\" or \"sessionStorage\" is passed\n\n    this.cacheStorage = new AuthCache(this.clientId, this.config.cache.cacheLocation, this.inCookie); // Initialize window handling code\n\n    window.activeRenewals = {};\n    window.renewStates = [];\n    window.callbackMappedToRenewStates = {};\n    window.promiseMappedToRenewStates = {};\n    window.msal = this;\n    var urlHash = window.location.hash;\n    var urlContainsHash = UrlUtils.urlContainsHash(urlHash); // check if back button is pressed\n\n    WindowUtils.checkIfBackButtonIsPressed(this.cacheStorage); // On the server 302 - Redirect, handle this\n\n    if (urlContainsHash) {\n      var stateInfo = this.getResponseState(urlHash);\n\n      if (stateInfo.method === Constants.interactionTypeRedirect) {\n        this.handleRedirectAuthenticationResponse(urlHash);\n      }\n    }\n  }\n\n  Object.defineProperty(UserAgentApplication.prototype, \"authority\", {\n    /**\r\n     * Method to manage the authority URL.\r\n     *\r\n     * @returns {string} authority\r\n     */\n    get: function () {\n      return this.authorityInstance.CanonicalAuthority;\n    },\n\n    /**\r\n     * setter for the authority URL\r\n     * @param {string} authority\r\n     */\n    // If the developer passes an authority, create an instance\n    set: function (val) {\n      this.authorityInstance = AuthorityFactory.CreateInstance(val, this.config.auth.validateAuthority);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Get the current authority instance from the MSAL configuration object\r\n   *\r\n   * @returns {@link Authority} authority instance\r\n   */\n\n  UserAgentApplication.prototype.getAuthorityInstance = function () {\n    return this.authorityInstance;\n  };\n\n  UserAgentApplication.prototype.handleRedirectCallback = function (authOrTokenCallback, errorReceivedCallback) {\n    if (!authOrTokenCallback) {\n      throw ClientConfigurationError.createInvalidCallbackObjectError(authOrTokenCallback);\n    } // Set callbacks\n\n\n    if (errorReceivedCallback) {\n      this.tokenReceivedCallback = authOrTokenCallback;\n      this.errorReceivedCallback = errorReceivedCallback;\n      this.logger.warning(\"This overload for callback is deprecated - please change the format of the callbacks to a single callback as shown: (err: AuthError, response: AuthResponse).\");\n    } else {\n      this.authResponseCallback = authOrTokenCallback;\n    }\n\n    if (this.redirectError) {\n      this.authErrorHandler(Constants.interactionTypeRedirect, this.redirectError, this.redirectResponse);\n    } else if (this.redirectResponse) {\n      this.authResponseHandler(Constants.interactionTypeRedirect, this.redirectResponse);\n    }\n  };\n  /**\r\n   * Public API to verify if the URL contains the hash with known properties\r\n   * @param hash\r\n   */\n\n\n  UserAgentApplication.prototype.urlContainsHash = function (hash) {\n    this.logger.verbose(\"UrlContainsHash has been called\");\n    return UrlUtils.urlContainsHash(hash);\n  };\n\n  UserAgentApplication.prototype.authResponseHandler = function (interactionType, response, resolve) {\n    this.logger.verbose(\"AuthResponseHandler has been called\");\n\n    if (interactionType === Constants.interactionTypeRedirect) {\n      this.logger.verbose(\"Interaction type is redirect\");\n\n      if (this.errorReceivedCallback) {\n        this.logger.verbose(\"Two callbacks were provided to handleRedirectCallback, calling success callback with response\");\n        this.tokenReceivedCallback(response);\n      } else if (this.authResponseCallback) {\n        this.logger.verbose(\"One callback was provided to handleRedirectCallback, calling authResponseCallback with response\");\n        this.authResponseCallback(null, response);\n      }\n    } else if (interactionType === Constants.interactionTypePopup) {\n      this.logger.verbose(\"Interaction type is popup, resolving\");\n      resolve(response);\n    } else {\n      throw ClientAuthError.createInvalidInteractionTypeError();\n    }\n  };\n\n  UserAgentApplication.prototype.authErrorHandler = function (interactionType, authErr, response, reject) {\n    this.logger.verbose(\"AuthErrorHandler has been called\"); // set interaction_status to complete\n\n    this.cacheStorage.removeItem(TemporaryCacheKeys.INTERACTION_STATUS);\n\n    if (interactionType === Constants.interactionTypeRedirect) {\n      this.logger.verbose(\"Interaction type is redirect\");\n\n      if (this.errorReceivedCallback) {\n        this.logger.verbose(\"Two callbacks were provided to handleRedirectCallback, calling error callback\");\n        this.errorReceivedCallback(authErr, response.accountState);\n      } else if (this.authResponseCallback) {\n        this.logger.verbose(\"One callback was provided to handleRedirectCallback, calling authResponseCallback with error\");\n        this.authResponseCallback(authErr, response);\n      } else {\n        this.logger.verbose(\"handleRedirectCallback has not been called and no callbacks are registered, throwing error\");\n        throw authErr;\n      }\n    } else if (interactionType === Constants.interactionTypePopup) {\n      this.logger.verbose(\"Interaction type is popup, rejecting\");\n      reject(authErr);\n    } else {\n      throw ClientAuthError.createInvalidInteractionTypeError();\n    }\n  }; // #endregion\n\n  /**\r\n   * Use when initiating the login process by redirecting the user's browser to the authorization endpoint.\r\n   * @param {@link (AuthenticationParameters:type)}\r\n   */\n\n\n  UserAgentApplication.prototype.loginRedirect = function (userRequest) {\n    this.logger.verbose(\"LoginRedirect has been called\"); // validate request\n\n    var request = RequestUtils.validateRequest(userRequest, true, this.clientId, Constants.interactionTypeRedirect);\n    this.acquireTokenInteractive(Constants.interactionTypeRedirect, true, request, null, null);\n  };\n  /**\r\n   * Use when you want to obtain an access_token for your API by redirecting the user's browser window to the authorization endpoint.\r\n   * @param {@link (AuthenticationParameters:type)}\r\n   *\r\n   * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\r\n   */\n\n\n  UserAgentApplication.prototype.acquireTokenRedirect = function (userRequest) {\n    this.logger.verbose(\"AcquireTokenRedirect has been called\"); // validate request\n\n    var request = RequestUtils.validateRequest(userRequest, false, this.clientId, Constants.interactionTypeRedirect);\n    this.acquireTokenInteractive(Constants.interactionTypeRedirect, false, request, null, null);\n  };\n  /**\r\n   * Use when initiating the login process via opening a popup window in the user's browser\r\n   *\r\n   * @param {@link (AuthenticationParameters:type)}\r\n   *\r\n   * @returns {Promise.<AuthResponse>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse} object\r\n   */\n\n\n  UserAgentApplication.prototype.loginPopup = function (userRequest) {\n    var _this = this;\n\n    this.logger.verbose(\"LoginPopup has been called\"); // validate request\n\n    var request = RequestUtils.validateRequest(userRequest, true, this.clientId, Constants.interactionTypePopup);\n    var apiEvent = this.telemetryManager.createAndStartApiEvent(request.correlationId, API_EVENT_IDENTIFIER.LoginPopup);\n    return new Promise(function (resolve, reject) {\n      _this.acquireTokenInteractive(Constants.interactionTypePopup, true, request, resolve, reject);\n    }).then(function (resp) {\n      _this.logger.verbose(\"Successfully logged in\");\n\n      _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, true);\n\n      return resp;\n    }).catch(function (error) {\n      _this.cacheStorage.resetTempCacheItems(request.state);\n\n      _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, false, error.errorCode);\n\n      throw error;\n    });\n  };\n  /**\r\n   * Use when you want to obtain an access_token for your API via opening a popup window in the user's browser\r\n   * @param {@link AuthenticationParameters}\r\n   *\r\n   * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\r\n   * @returns {Promise.<AuthResponse>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse} object\r\n   */\n\n\n  UserAgentApplication.prototype.acquireTokenPopup = function (userRequest) {\n    var _this = this;\n\n    this.logger.verbose(\"AcquireTokenPopup has been called\"); // validate request\n\n    var request = RequestUtils.validateRequest(userRequest, false, this.clientId, Constants.interactionTypePopup);\n    var apiEvent = this.telemetryManager.createAndStartApiEvent(request.correlationId, API_EVENT_IDENTIFIER.AcquireTokenPopup);\n    return new Promise(function (resolve, reject) {\n      _this.acquireTokenInteractive(Constants.interactionTypePopup, false, request, resolve, reject);\n    }).then(function (resp) {\n      _this.logger.verbose(\"Successfully acquired token\");\n\n      _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, true);\n\n      return resp;\n    }).catch(function (error) {\n      _this.cacheStorage.resetTempCacheItems(request.state);\n\n      _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, false, error.errorCode);\n\n      throw error;\n    });\n  }; // #region Acquire Token\n\n  /**\r\n   * Use when initiating the login process or when you want to obtain an access_token for your API,\r\n   * either by redirecting the user's browser window to the authorization endpoint or via opening a popup window in the user's browser.\r\n   * @param {@link (AuthenticationParameters:type)}\r\n   *\r\n   * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\r\n   */\n\n\n  UserAgentApplication.prototype.acquireTokenInteractive = function (interactionType, isLoginCall, request, resolve, reject) {\n    var _this = this;\n\n    this.logger.verbose(\"AcquireTokenInteractive has been called\"); // block the request if made from the hidden iframe\n\n    WindowUtils.blockReloadInHiddenIframes();\n    var interactionProgress = this.cacheStorage.getItem(TemporaryCacheKeys.INTERACTION_STATUS);\n\n    if (interactionType === Constants.interactionTypeRedirect) {\n      this.cacheStorage.setItem(TemporaryCacheKeys.REDIRECT_REQUEST, \"\" + Constants.inProgress + Constants.resourceDelimiter + request.state);\n    } // If already in progress, do not proceed\n\n\n    if (interactionProgress === Constants.inProgress) {\n      var thrownError = isLoginCall ? ClientAuthError.createLoginInProgressError() : ClientAuthError.createAcquireTokenInProgressError();\n      var stateOnlyResponse = buildResponseStateOnly(this.getAccountState(request.state));\n      this.cacheStorage.resetTempCacheItems(request.state);\n      this.authErrorHandler(interactionType, thrownError, stateOnlyResponse, reject);\n      return;\n    } // Get the account object if a session exists\n\n\n    var account;\n\n    if (request && request.account && !isLoginCall) {\n      account = request.account;\n      this.logger.verbose(\"Account set from request\");\n    } else {\n      account = this.getAccount();\n      this.logger.verbose(\"Account set from MSAL Cache\");\n    } // If no session exists, prompt the user to login.\n\n\n    if (!account && !ServerRequestParameters.isSSOParam(request)) {\n      if (isLoginCall) {\n        // extract ADAL id_token if exists\n        var adalIdToken = this.extractADALIdToken(); // silent login if ADAL id_token is retrieved successfully - SSO\n\n        if (adalIdToken && !request.scopes) {\n          this.logger.info(\"ADAL's idToken exists. Extracting login information from ADAL's idToken\");\n          var tokenRequest = this.buildIDTokenRequest(request);\n          this.silentLogin = true;\n          this.acquireTokenSilent(tokenRequest).then(function (response) {\n            _this.silentLogin = false;\n\n            _this.logger.info(\"Unified cache call is successful\");\n\n            _this.authResponseHandler(interactionType, response, resolve);\n\n            return;\n          }, function (error) {\n            _this.silentLogin = false;\n\n            _this.logger.error(\"Error occurred during unified cache ATS: \" + error); // proceed to login since ATS failed\n\n\n            _this.acquireTokenHelper(null, interactionType, isLoginCall, request, resolve, reject);\n          });\n        } // No ADAL token found, proceed to login\n        else {\n            this.logger.verbose(\"Login call but no token found, proceed to login\");\n            this.acquireTokenHelper(null, interactionType, isLoginCall, request, resolve, reject);\n          }\n      } // AcquireToken call, but no account or context given, so throw error\n      else {\n          this.logger.verbose(\"AcquireToken call, no context or account given\");\n          this.logger.info(\"User login is required\");\n          var stateOnlyResponse = buildResponseStateOnly(this.getAccountState(request.state));\n          this.cacheStorage.resetTempCacheItems(request.state);\n          this.authErrorHandler(interactionType, ClientAuthError.createUserLoginRequiredError(), stateOnlyResponse, reject);\n          return;\n        }\n    } // User session exists\n    else {\n        this.logger.verbose(\"User session exists, login not required\");\n        this.acquireTokenHelper(account, interactionType, isLoginCall, request, resolve, reject);\n      }\n  };\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   * Helper function to acquireToken\r\n   *\r\n   */\n\n\n  UserAgentApplication.prototype.acquireTokenHelper = function (account, interactionType, isLoginCall, request, resolve, reject) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var requestSignature, serverAuthenticationRequest, acquireTokenAuthority, popUpWindow, responseType, loginStartPage, urlNavigate, hash, error_1, navigate, err_1;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"AcquireTokenHelper has been called\");\n            this.logger.verbose(\"Interaction type: \" + interactionType + \". isLoginCall: \" + isLoginCall); // Track the acquireToken progress\n\n            this.cacheStorage.setItem(TemporaryCacheKeys.INTERACTION_STATUS, Constants.inProgress);\n            requestSignature = request.scopes ? request.scopes.join(\" \").toLowerCase() : Constants.oidcScopes.join(\" \");\n            this.logger.verbosePii(\"Request signature: \" + requestSignature);\n            acquireTokenAuthority = request && request.authority ? AuthorityFactory.CreateInstance(request.authority, this.config.auth.validateAuthority, request.authorityMetadata) : this.authorityInstance;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 11,, 12]);\n\n            if (!!acquireTokenAuthority.hasCachedMetadata()) return [3\n            /*break*/\n            , 3];\n            this.logger.verbose(\"No cached metadata for authority\");\n            return [4\n            /*yield*/\n            , AuthorityFactory.saveMetadataFromNetwork(acquireTokenAuthority, this.telemetryManager, request.correlationId)];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            this.logger.verbose(\"Cached metadata found for authority\");\n            _a.label = 4;\n\n          case 4:\n            responseType = isLoginCall ? ResponseTypes.id_token : this.getTokenType(account, request.scopes);\n            loginStartPage = request.redirectStartPage || window.location.href;\n            serverAuthenticationRequest = new ServerRequestParameters(acquireTokenAuthority, this.clientId, responseType, this.getRedirectUri(request && request.redirectUri), request.scopes, request.state, request.correlationId);\n            this.logger.verbose(\"Finished building server authentication request\");\n            this.updateCacheEntries(serverAuthenticationRequest, account, isLoginCall, loginStartPage);\n            this.logger.verbose(\"Updating cache entries\"); // populate QueryParameters (sid/login_hint) and any other extraQueryParameters set by the developer\n\n            serverAuthenticationRequest.populateQueryParams(account, request);\n            this.logger.verbose(\"Query parameters populated from account\");\n            urlNavigate = UrlUtils.createNavigateUrl(serverAuthenticationRequest) + Constants.response_mode_fragment; // set state in cache\n\n            if (interactionType === Constants.interactionTypeRedirect) {\n              if (!isLoginCall) {\n                this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_ACQ_TOKEN, request.state), serverAuthenticationRequest.state, this.inCookie);\n                this.logger.verbose(\"State cached for redirect\");\n                this.logger.verbosePii(\"State cached: \" + serverAuthenticationRequest.state);\n              } else {\n                this.logger.verbose(\"Interaction type redirect but login call is true. State not cached\");\n              }\n            } else if (interactionType === Constants.interactionTypePopup) {\n              window.renewStates.push(serverAuthenticationRequest.state);\n              window.requestType = isLoginCall ? Constants.login : Constants.renewToken;\n              this.logger.verbose(\"State saved to window\");\n              this.logger.verbosePii(\"State saved: \" + serverAuthenticationRequest.state); // Register callback to capture results from server\n\n              this.registerCallback(serverAuthenticationRequest.state, requestSignature, resolve, reject);\n            } else {\n              this.logger.verbose(\"Invalid interaction error. State not cached\");\n              throw ClientAuthError.createInvalidInteractionTypeError();\n            }\n\n            if (!(interactionType === Constants.interactionTypePopup)) return [3\n            /*break*/\n            , 9];\n            this.logger.verbose(\"Interaction type is popup. Generating popup window\"); // Generate a popup window\n\n            try {\n              popUpWindow = this.openPopup(urlNavigate, \"msal\", Constants.popUpWidth, Constants.popUpHeight); // Push popup window handle onto stack for tracking\n\n              WindowUtils.trackPopup(popUpWindow);\n            } catch (e) {\n              this.logger.info(ClientAuthErrorMessage.popUpWindowError.code + \":\" + ClientAuthErrorMessage.popUpWindowError.desc);\n              this.cacheStorage.setItem(ErrorCacheKeys.ERROR, ClientAuthErrorMessage.popUpWindowError.code);\n              this.cacheStorage.setItem(ErrorCacheKeys.ERROR_DESC, ClientAuthErrorMessage.popUpWindowError.desc);\n\n              if (reject) {\n                reject(ClientAuthError.createPopupWindowError());\n                return [2\n                /*return*/\n                ];\n              }\n            }\n\n            if (!popUpWindow) return [3\n            /*break*/\n            , 8];\n            _a.label = 5;\n\n          case 5:\n            _a.trys.push([5, 7,, 8]);\n\n            return [4\n            /*yield*/\n            , WindowUtils.monitorPopupForHash(popUpWindow, this.config.system.loadFrameTimeout, urlNavigate, this.logger)];\n\n          case 6:\n            hash = _a.sent();\n            this.handleAuthenticationResponse(hash); // Request completed successfully, set to completed\n\n            this.cacheStorage.removeItem(TemporaryCacheKeys.INTERACTION_STATUS);\n            this.logger.info(\"Closing popup window\"); // TODO: Check how this can be extracted for any framework specific code?\n\n            if (this.config.framework.isAngular) {\n              this.broadcast(\"msal:popUpHashChanged\", hash);\n            }\n\n            WindowUtils.closePopups();\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            error_1 = _a.sent();\n\n            if (reject) {\n              reject(error_1);\n            }\n\n            if (this.config.framework.isAngular) {\n              this.broadcast(\"msal:popUpClosed\", error_1.errorCode + Constants.resourceDelimiter + error_1.errorMessage);\n            } else {\n              // Request failed, set to canceled\n              this.cacheStorage.removeItem(TemporaryCacheKeys.INTERACTION_STATUS);\n              popUpWindow.close();\n            }\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 8:\n            return [3\n            /*break*/\n            , 10];\n\n          case 9:\n            // If onRedirectNavigate is implemented, invoke it and provide urlNavigate\n            if (request.onRedirectNavigate) {\n              this.logger.verbose(\"Invoking onRedirectNavigate callback\");\n              navigate = request.onRedirectNavigate(urlNavigate); // Returning false from onRedirectNavigate will stop navigation\n\n              if (navigate !== false) {\n                this.logger.verbose(\"onRedirectNavigate did not return false, navigating\");\n                this.navigateWindow(urlNavigate);\n              } else {\n                this.logger.verbose(\"onRedirectNavigate returned false, stopping navigation\");\n              }\n            } else {\n              // Otherwise, perform navigation\n              this.logger.verbose(\"Navigating window to urlNavigate\");\n              this.navigateWindow(urlNavigate);\n            }\n\n            _a.label = 10;\n\n          case 10:\n            return [3\n            /*break*/\n            , 12];\n\n          case 11:\n            err_1 = _a.sent();\n            this.logger.error(err_1);\n            this.cacheStorage.resetTempCacheItems(request.state);\n            this.authErrorHandler(interactionType, ClientAuthError.createEndpointResolutionError(err_1.toString), buildResponseStateOnly(request.state), reject);\n\n            if (popUpWindow) {\n              popUpWindow.close();\n            }\n\n            return [3\n            /*break*/\n            , 12];\n\n          case 12:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * API interfacing idToken request when applications already have a session/hint acquired by authorization client applications\r\n   * @param request\r\n   */\n\n\n  UserAgentApplication.prototype.ssoSilent = function (request) {\n    this.logger.verbose(\"ssoSilent has been called\"); // throw an error on an empty request\n\n    if (!request) {\n      throw ClientConfigurationError.createEmptyRequestError();\n    } // throw an error on no hints passed\n\n\n    if (!request.sid && !request.loginHint) {\n      throw ClientConfigurationError.createSsoSilentError();\n    }\n\n    return this.acquireTokenSilent(tslib_1.__assign({}, request, {\n      scopes: Constants.oidcScopes\n    }));\n  };\n  /**\r\n   * Use this function to obtain a token before every call to the API / resource provider\r\n   *\r\n   * MSAL return's a cached token when available\r\n   * Or it send's a request to the STS to obtain a new token using a hidden iframe.\r\n   *\r\n   * @param {@link AuthenticationParameters}\r\n   *\r\n   * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\r\n   * @returns {Promise.<AuthResponse>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse} object\r\n   *\r\n   */\n\n\n  UserAgentApplication.prototype.acquireTokenSilent = function (userRequest) {\n    var _this = this;\n\n    this.logger.verbose(\"AcquireTokenSilent has been called\"); // validate the request\n\n    var request = RequestUtils.validateRequest(userRequest, false, this.clientId, Constants.interactionTypeSilent);\n    var apiEvent = this.telemetryManager.createAndStartApiEvent(request.correlationId, API_EVENT_IDENTIFIER.AcquireTokenSilent);\n    var requestSignature = RequestUtils.createRequestSignature(request);\n    return new Promise(function (resolve, reject) {\n      return tslib_1.__awaiter(_this, void 0, void 0, function () {\n        var scope, account, adalIdToken, responseType, serverAuthenticationRequest, adalIdTokenObject, userContainedClaims, authErr, cacheResultResponse, logMessage, err_2;\n        return tslib_1.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              // block the request if made from the hidden iframe\n              WindowUtils.blockReloadInHiddenIframes();\n              scope = request.scopes.join(\" \").toLowerCase();\n              this.logger.verbosePii(\"Serialized scopes: \" + scope);\n\n              if (request.account) {\n                account = request.account;\n                this.logger.verbose(\"Account set from request\");\n              } else {\n                account = this.getAccount();\n                this.logger.verbose(\"Account set from MSAL Cache\");\n              }\n\n              adalIdToken = this.cacheStorage.getItem(Constants.adalIdToken); // In the event of no account being passed in the config, no session id, and no pre-existing adalIdToken, user will need to log in\n\n              if (!account && !(request.sid || request.loginHint) && StringUtils.isEmpty(adalIdToken)) {\n                this.logger.info(\"User login is required\"); // The promise rejects with a UserLoginRequiredError, which should be caught and user should be prompted to log in interactively\n\n                return [2\n                /*return*/\n                , reject(ClientAuthError.createUserLoginRequiredError())];\n              }\n\n              responseType = this.getTokenType(account, request.scopes);\n              this.logger.verbose(\"Response type: \" + responseType);\n              serverAuthenticationRequest = new ServerRequestParameters(AuthorityFactory.CreateInstance(request.authority, this.config.auth.validateAuthority, request.authorityMetadata), this.clientId, responseType, this.getRedirectUri(request.redirectUri), request.scopes, request.state, request.correlationId);\n              this.logger.verbose(\"Finished building server authentication request\"); // populate QueryParameters (sid/login_hint) and any other extraQueryParameters set by the developer\n\n              if (ServerRequestParameters.isSSOParam(request) || account) {\n                serverAuthenticationRequest.populateQueryParams(account, request, null, true);\n                this.logger.verbose(\"Query parameters populated from existing SSO or account\");\n              } // if user didn't pass login_hint/sid and adal's idtoken is present, extract the login_hint from the adalIdToken\n              else if (!account && !StringUtils.isEmpty(adalIdToken)) {\n                  adalIdTokenObject = TokenUtils.extractIdToken(adalIdToken);\n                  this.logger.verbose(\"ADAL's idToken exists. Extracting login information from ADAL's idToken to populate query parameters\");\n                  serverAuthenticationRequest.populateQueryParams(account, null, adalIdTokenObject, true);\n                } else {\n                  this.logger.verbose(\"No additional query parameters added\");\n                }\n\n              userContainedClaims = request.claimsRequest || serverAuthenticationRequest.claimsValue; // If request.forceRefresh is set to true, force a request for a new token instead of getting it from the cache\n\n              if (!userContainedClaims && !request.forceRefresh) {\n                try {\n                  cacheResultResponse = this.getCachedToken(serverAuthenticationRequest, account);\n                } catch (e) {\n                  authErr = e;\n                }\n              }\n\n              if (!cacheResultResponse) return [3\n              /*break*/\n              , 1];\n              this.logger.verbose(\"Token found in cache lookup\");\n              this.logger.verbosePii(\"Scopes found: \" + JSON.stringify(cacheResultResponse.scopes));\n              resolve(cacheResultResponse);\n              return [2\n              /*return*/\n              , null];\n\n            case 1:\n              if (!authErr) return [3\n              /*break*/\n              , 2];\n              this.logger.infoPii(authErr.errorCode + \":\" + authErr.errorMessage);\n              reject(authErr);\n              return [2\n              /*return*/\n              , null];\n\n            case 2:\n              logMessage = void 0;\n\n              if (userContainedClaims) {\n                logMessage = \"Skipped cache lookup since claims were given\";\n              } else if (request.forceRefresh) {\n                logMessage = \"Skipped cache lookup since request.forceRefresh option was set to true\";\n              } else {\n                logMessage = \"No valid token found in cache lookup\";\n              }\n\n              this.logger.verbose(logMessage); // Cache result can return null if cache is empty. In that case, set authority to default value if no authority is passed to the API.\n\n              if (!serverAuthenticationRequest.authorityInstance) {\n                serverAuthenticationRequest.authorityInstance = request.authority ? AuthorityFactory.CreateInstance(request.authority, this.config.auth.validateAuthority, request.authorityMetadata) : this.authorityInstance;\n              }\n\n              this.logger.verbosePii(\"Authority instance: \" + serverAuthenticationRequest.authority);\n              _a.label = 3;\n\n            case 3:\n              _a.trys.push([3, 7,, 8]);\n\n              if (!!serverAuthenticationRequest.authorityInstance.hasCachedMetadata()) return [3\n              /*break*/\n              , 5];\n              this.logger.verbose(\"No cached metadata for authority\");\n              return [4\n              /*yield*/\n              , AuthorityFactory.saveMetadataFromNetwork(serverAuthenticationRequest.authorityInstance, this.telemetryManager, request.correlationId)];\n\n            case 4:\n              _a.sent();\n\n              this.logger.verbose(\"Authority has been updated with endpoint discovery response\");\n              return [3\n              /*break*/\n              , 6];\n\n            case 5:\n              this.logger.verbose(\"Cached metadata found for authority\");\n              _a.label = 6;\n\n            case 6:\n              /*\r\n               * refresh attempt with iframe\r\n               * Already renewing for this scope, callback when we get the token.\r\n               */\n              if (window.activeRenewals[requestSignature]) {\n                this.logger.verbose(\"Renewing token in progress. Registering callback\"); // Active renewals contains the state for each renewal.\n\n                this.registerCallback(window.activeRenewals[requestSignature], requestSignature, resolve, reject);\n              } else {\n                if (request.scopes && ScopeSet.onlyContainsOidcScopes(request.scopes)) {\n                  /*\r\n                   * App uses idToken to send to api endpoints\r\n                   * Default scope is tracked as OIDC scopes to store this token\r\n                   */\n                  this.logger.verbose(\"OpenID Connect scopes only, renewing idToken\");\n                  this.silentLogin = true;\n                  this.renewIdToken(requestSignature, resolve, reject, account, serverAuthenticationRequest);\n                } else {\n                  // renew access token\n                  this.logger.verbose(\"Renewing access token\");\n                  this.renewToken(requestSignature, resolve, reject, account, serverAuthenticationRequest);\n                }\n              }\n\n              return [3\n              /*break*/\n              , 8];\n\n            case 7:\n              err_2 = _a.sent();\n              this.logger.error(err_2);\n              reject(ClientAuthError.createEndpointResolutionError(err_2.toString()));\n              return [2\n              /*return*/\n              , null];\n\n            case 8:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }).then(function (res) {\n      _this.logger.verbose(\"Successfully acquired token\");\n\n      _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, true);\n\n      return res;\n    }).catch(function (error) {\n      _this.cacheStorage.resetTempCacheItems(request.state);\n\n      _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, false, error.errorCode);\n\n      throw error;\n    });\n  }; // #endregion\n  // #region Popup Window Creation\n\n  /**\r\n   * @hidden\r\n   *\r\n   * Configures popup window for login.\r\n   *\r\n   * @param urlNavigate\r\n   * @param title\r\n   * @param popUpWidth\r\n   * @param popUpHeight\r\n   * @ignore\r\n   * @hidden\r\n   */\n\n\n  UserAgentApplication.prototype.openPopup = function (urlNavigate, title, popUpWidth, popUpHeight) {\n    this.logger.verbose(\"OpenPopup has been called\");\n\n    try {\n      /**\r\n       * adding winLeft and winTop to account for dual monitor\r\n       * using screenLeft and screenTop for IE8 and earlier\r\n       */\n      var winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n      var winTop = window.screenTop ? window.screenTop : window.screenY;\n      /**\r\n       * window.innerWidth displays browser window\"s height and width excluding toolbars\r\n       * using document.documentElement.clientWidth for IE8 and earlier\r\n       */\n\n      var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n      var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n      var left = width / 2 - popUpWidth / 2 + winLeft;\n      var top_1 = height / 2 - popUpHeight / 2 + winTop; // open the window\n\n      var popupWindow = window.open(urlNavigate, title, \"width=\" + popUpWidth + \", height=\" + popUpHeight + \", top=\" + top_1 + \", left=\" + left + \", scrollbars=yes\");\n\n      if (!popupWindow) {\n        throw ClientAuthError.createPopupWindowError();\n      }\n\n      if (popupWindow.focus) {\n        popupWindow.focus();\n      }\n\n      return popupWindow;\n    } catch (e) {\n      this.cacheStorage.removeItem(TemporaryCacheKeys.INTERACTION_STATUS);\n      throw ClientAuthError.createPopupWindowError(e.toString());\n    }\n  }; // #endregion\n  // #region Iframe Management\n\n  /**\r\n   * @hidden\r\n   * Calling _loadFrame but with a timeout to signal failure in loadframeStatus. Callbacks are left.\r\n   * registered when network errors occur and subsequent token requests for same resource are registered to the pending request.\r\n   * @ignore\r\n   */\n\n\n  UserAgentApplication.prototype.loadIframeTimeout = function (urlNavigate, frameName, requestSignature) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var expectedState, iframe, _a, hash, error_2;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            expectedState = window.activeRenewals[requestSignature];\n            this.logger.verbosePii(\"Set loading state to pending for: \" + requestSignature + \":\" + expectedState);\n            this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, expectedState), Constants.inProgress);\n            if (!this.config.system.navigateFrameWait) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , WindowUtils.loadFrame(urlNavigate, frameName, this.config.system.navigateFrameWait, this.logger)];\n\n          case 1:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            _a = WindowUtils.loadFrameSync(urlNavigate, frameName, this.logger);\n            _b.label = 3;\n\n          case 3:\n            iframe = _a;\n            _b.label = 4;\n\n          case 4:\n            _b.trys.push([4, 6,, 7]);\n\n            return [4\n            /*yield*/\n            , WindowUtils.monitorIframeForHash(iframe.contentWindow, this.config.system.loadFrameTimeout, urlNavigate, this.logger)];\n\n          case 5:\n            hash = _b.sent();\n\n            if (hash) {\n              this.handleAuthenticationResponse(hash);\n            }\n\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            error_2 = _b.sent();\n\n            if (this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, expectedState)) === Constants.inProgress) {\n              // fail the iframe session if it's in pending state\n              this.logger.verbose(\"Loading frame has timed out after: \" + this.config.system.loadFrameTimeout / 1000 + \" seconds for scope/authority \" + requestSignature + \":\" + expectedState); // Error after timeout\n\n              if (expectedState && window.callbackMappedToRenewStates[expectedState]) {\n                window.callbackMappedToRenewStates[expectedState](null, error_2);\n              }\n\n              this.cacheStorage.removeItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, expectedState));\n            }\n\n            WindowUtils.removeHiddenIframe(iframe);\n            throw error_2;\n\n          case 7:\n            WindowUtils.removeHiddenIframe(iframe);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // #endregion\n  // #region General Helpers\n\n  /**\r\n   * @hidden\r\n   * Used to redirect the browser to the STS authorization endpoint\r\n   * @param {string} urlNavigate - URL of the authorization endpoint\r\n   */\n\n\n  UserAgentApplication.prototype.navigateWindow = function (urlNavigate, popupWindow) {\n    // Navigate if valid URL\n    if (urlNavigate && !StringUtils.isEmpty(urlNavigate)) {\n      var navigateWindow = popupWindow ? popupWindow : window;\n      var logMessage = popupWindow ? \"Navigated Popup window to:\" + urlNavigate : \"Navigate to:\" + urlNavigate;\n      this.logger.infoPii(logMessage);\n      navigateWindow.location.assign(urlNavigate);\n    } else {\n      this.logger.info(\"Navigate url is empty\");\n      throw AuthError.createUnexpectedError(\"Navigate url is empty\");\n    }\n  };\n  /**\r\n   * @hidden\r\n   * Used to add the developer requested callback to the array of callbacks for the specified scopes. The updated array is stored on the window object\r\n   * @param {string} expectedState - Unique state identifier (guid).\r\n   * @param {string} scope - Developer requested permissions. Not all scopes are guaranteed to be included in the access token returned.\r\n   * @param {Function} resolve - The resolve function of the promise object.\r\n   * @param {Function} reject - The reject function of the promise object.\r\n   * @ignore\r\n   */\n\n\n  UserAgentApplication.prototype.registerCallback = function (expectedState, requestSignature, resolve, reject) {\n    var _this = this; // track active renewals\n\n\n    window.activeRenewals[requestSignature] = expectedState; // initialize callbacks mapped array\n\n    if (!window.promiseMappedToRenewStates[expectedState]) {\n      window.promiseMappedToRenewStates[expectedState] = [];\n    } // indexing on the current state, push the callback params to callbacks mapped\n\n\n    window.promiseMappedToRenewStates[expectedState].push({\n      resolve: resolve,\n      reject: reject\n    }); // Store the server response in the current window??\n\n    if (!window.callbackMappedToRenewStates[expectedState]) {\n      window.callbackMappedToRenewStates[expectedState] = function (response, error) {\n        // reset active renewals\n        window.activeRenewals[requestSignature] = null; // for all promiseMappedtoRenewStates for a given 'state' - call the reject/resolve with error/token respectively\n\n        for (var i = 0; i < window.promiseMappedToRenewStates[expectedState].length; ++i) {\n          try {\n            if (error) {\n              window.promiseMappedToRenewStates[expectedState][i].reject(error);\n            } else if (response) {\n              window.promiseMappedToRenewStates[expectedState][i].resolve(response);\n            } else {\n              _this.cacheStorage.resetTempCacheItems(expectedState);\n\n              throw AuthError.createUnexpectedError(\"Error and response are both null\");\n            }\n          } catch (e) {\n            _this.logger.warning(e);\n          }\n        } // reset\n\n\n        window.promiseMappedToRenewStates[expectedState] = null;\n        window.callbackMappedToRenewStates[expectedState] = null;\n      };\n    }\n  }; // #endregion\n  // #region Logout\n\n  /**\r\n   * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n   * Default behaviour is to redirect the user to `window.location.href`.\r\n   */\n\n\n  UserAgentApplication.prototype.logout = function (correlationId) {\n    this.logger.verbose(\"Logout has been called\");\n    this.logoutAsync(correlationId);\n  };\n  /**\r\n   * Async version of logout(). Use to log out the current user.\r\n   * @param correlationId Request correlationId\r\n   */\n\n\n  UserAgentApplication.prototype.logoutAsync = function (correlationId) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var requestCorrelationId, apiEvent, correlationIdParam, postLogoutQueryParam, urlNavigate, error_3;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            requestCorrelationId = correlationId || CryptoUtils.createNewGuid();\n            apiEvent = this.telemetryManager.createAndStartApiEvent(requestCorrelationId, API_EVENT_IDENTIFIER.Logout);\n            this.clearCache();\n            this.account = null;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 5,, 6]);\n\n            if (!!this.authorityInstance.hasCachedMetadata()) return [3\n            /*break*/\n            , 3];\n            this.logger.verbose(\"No cached metadata for authority\");\n            return [4\n            /*yield*/\n            , AuthorityFactory.saveMetadataFromNetwork(this.authorityInstance, this.telemetryManager, correlationId)];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            this.logger.verbose(\"Cached metadata found for authority\");\n            _a.label = 4;\n\n          case 4:\n            correlationIdParam = \"client-request-id=\" + requestCorrelationId;\n            postLogoutQueryParam = void 0;\n\n            if (this.getPostLogoutRedirectUri()) {\n              postLogoutQueryParam = \"&post_logout_redirect_uri=\" + encodeURIComponent(this.getPostLogoutRedirectUri());\n              this.logger.verbose(\"redirectUri found and set\");\n            } else {\n              postLogoutQueryParam = \"\";\n              this.logger.verbose(\"No redirectUri set for app. postLogoutQueryParam is empty\");\n            }\n\n            urlNavigate = void 0;\n\n            if (this.authorityInstance.EndSessionEndpoint) {\n              urlNavigate = this.authorityInstance.EndSessionEndpoint + \"?\" + correlationIdParam + postLogoutQueryParam;\n              this.logger.verbose(\"EndSessionEndpoint found and urlNavigate set\");\n              this.logger.verbosePii(\"urlNavigate set to: \" + this.authorityInstance.EndSessionEndpoint);\n            } else {\n              urlNavigate = this.authority + \"oauth2/v2.0/logout?\" + correlationIdParam + postLogoutQueryParam;\n              this.logger.verbose(\"No endpoint, urlNavigate set to default\");\n            }\n\n            this.telemetryManager.stopAndFlushApiEvent(requestCorrelationId, apiEvent, true);\n            this.logger.verbose(\"Navigating window to urlNavigate\");\n            this.navigateWindow(urlNavigate);\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            error_3 = _a.sent();\n            this.telemetryManager.stopAndFlushApiEvent(requestCorrelationId, apiEvent, false, error_3.errorCode);\n            return [3\n            /*break*/\n            , 6];\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * @hidden\r\n   * Clear all access tokens and ID tokens in the cache.\r\n   * @ignore\r\n   */\n\n\n  UserAgentApplication.prototype.clearCache = function () {\n    this.logger.verbose(\"Clearing cache\");\n    window.renewStates = [];\n    var tokenCacheItems = this.cacheStorage.getAllTokens(Constants.clientId, Constants.homeAccountIdentifier);\n\n    for (var i = 0; i < tokenCacheItems.length; i++) {\n      this.cacheStorage.removeItem(JSON.stringify(tokenCacheItems[i].key));\n    }\n\n    this.cacheStorage.resetCacheItems();\n    this.cacheStorage.clearMsalCookie();\n    this.logger.verbose(\"Cache cleared\");\n  };\n  /**\r\n   * @hidden\r\n   * Clear a given access token from the cache.\r\n   *\r\n   * @param accessToken\r\n   */\n\n\n  UserAgentApplication.prototype.clearCacheForScope = function (accessToken) {\n    this.logger.verbose(\"Clearing access token from cache\");\n    var accessTokenItems = this.cacheStorage.getAllAccessTokens(Constants.clientId, Constants.homeAccountIdentifier);\n\n    for (var i = 0; i < accessTokenItems.length; i++) {\n      var token = accessTokenItems[i];\n\n      if (token.value.accessToken === accessToken) {\n        this.cacheStorage.removeItem(JSON.stringify(token.key));\n        this.logger.verbosePii(\"Access token removed: \" + token.key);\n      }\n    }\n  }; // #endregion\n  // #region Response\n\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   * Checks if the redirect response is received from the STS. In case of redirect, the url fragment has either id_token, access_token or error.\r\n   * @param {string} hash - Hash passed from redirect page.\r\n   * @returns {Boolean} - true if response contains id_token, access_token or error, false otherwise.\r\n   */\n\n\n  UserAgentApplication.prototype.isCallback = function (hash) {\n    this.logger.info(\"isCallback will be deprecated in favor of urlContainsHash in MSAL.js v2.0.\");\n    this.logger.verbose(\"isCallback has been called\");\n    return UrlUtils.urlContainsHash(hash);\n  };\n  /**\r\n   * @hidden\r\n   * Used to call the constructor callback with the token/error\r\n   * @param {string} [hash=window.location.hash] - Hash fragment of Url.\r\n   */\n\n\n  UserAgentApplication.prototype.processCallBack = function (hash, stateInfo, parentCallback) {\n    this.logger.info(\"ProcessCallBack has been called. Processing callback from redirect response\"); // get the state info from the hash\n\n    if (!stateInfo) {\n      this.logger.verbose(\"StateInfo is null, getting stateInfo from hash\");\n      stateInfo = this.getResponseState(hash);\n    }\n\n    var response;\n    var authErr; // Save the token info from the hash\n\n    try {\n      response = this.saveTokenFromHash(hash, stateInfo);\n    } catch (err) {\n      authErr = err;\n    }\n\n    try {\n      // Clear the cookie in the hash\n      this.cacheStorage.clearMsalCookie(stateInfo.state);\n      var accountState = this.getAccountState(stateInfo.state);\n\n      if (response) {\n        if (stateInfo.requestType === Constants.renewToken || response.accessToken) {\n          if (window.parent !== window) {\n            this.logger.verbose(\"Window is in iframe, acquiring token silently\");\n          } else {\n            this.logger.verbose(\"Acquiring token interactive in progress\");\n          }\n\n          this.logger.verbose(\"Response tokenType set to \" + ServerHashParamKeys.ACCESS_TOKEN);\n          response.tokenType = ServerHashParamKeys.ACCESS_TOKEN;\n        } else if (stateInfo.requestType === Constants.login) {\n          this.logger.verbose(\"Response tokenType set to \" + ServerHashParamKeys.ID_TOKEN);\n          response.tokenType = ServerHashParamKeys.ID_TOKEN;\n        }\n\n        if (!parentCallback) {\n          this.logger.verbose(\"Setting redirectResponse\");\n          this.redirectResponse = response;\n          return;\n        }\n      } else if (!parentCallback) {\n        this.logger.verbose(\"Response is null, setting redirectResponse with state\");\n        this.redirectResponse = buildResponseStateOnly(accountState);\n        this.redirectError = authErr;\n        this.cacheStorage.resetTempCacheItems(stateInfo.state);\n        return;\n      }\n\n      this.logger.verbose(\"Calling callback provided to processCallback\");\n      parentCallback(response, authErr);\n    } catch (err) {\n      this.logger.error(\"Error occurred in token received callback function: \" + err);\n      throw ClientAuthError.createErrorInCallbackFunction(err.toString());\n    }\n  };\n  /**\r\n   * @hidden\r\n   * This method must be called for processing the response received from the STS if using popups or iframes. It extracts the hash, processes the token or error\r\n   * information and saves it in the cache. It then resolves the promises with the result.\r\n   * @param {string} [hash=window.location.hash] - Hash fragment of Url.\r\n   */\n\n\n  UserAgentApplication.prototype.handleAuthenticationResponse = function (hash) {\n    this.logger.verbose(\"HandleAuthenticationResponse has been called\"); // retrieve the hash\n\n    var locationHash = hash || window.location.hash; // if (window.parent !== window), by using self, window.parent becomes equal to window in getResponseState method specifically\n\n    var stateInfo = this.getResponseState(locationHash);\n    this.logger.verbose(\"Obtained state from response\");\n    var tokenResponseCallback = window.callbackMappedToRenewStates[stateInfo.state];\n    this.processCallBack(locationHash, stateInfo, tokenResponseCallback);\n  };\n  /**\r\n   * @hidden\r\n   * This method must be called for processing the response received from the STS when using redirect flows. It extracts the hash, processes the token or error\r\n   * information and saves it in the cache. The result can then be accessed by user registered callbacks.\r\n   * @param {string} [hash=window.location.hash] - Hash fragment of Url.\r\n   */\n\n\n  UserAgentApplication.prototype.handleRedirectAuthenticationResponse = function (hash) {\n    this.logger.info(\"Returned from redirect url\");\n    this.logger.verbose(\"HandleRedirectAuthenticationResponse has been called\"); // clear hash from window\n\n    WindowUtils.clearUrlFragment();\n    this.logger.verbose(\"Window.location.hash cleared\"); // if (window.parent !== window), by using self, window.parent becomes equal to window in getResponseState method specifically\n\n    var stateInfo = this.getResponseState(hash); // if set to navigate to loginRequest page post login\n\n    if (this.config.auth.navigateToLoginRequestUrl && window.parent === window) {\n      this.logger.verbose(\"Window.parent is equal to window, not in popup or iframe. Navigation to login request url after login turned on\");\n      var loginRequestUrl = this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.LOGIN_REQUEST, stateInfo.state), this.inCookie); // Redirect to home page if login request url is null (real null or the string null)\n\n      if (!loginRequestUrl || loginRequestUrl === \"null\") {\n        this.logger.error(\"Unable to get valid login request url from cache, redirecting to home page\");\n        window.location.assign(\"/\");\n        return;\n      } else {\n        this.logger.verbose(\"Valid login request url obtained from cache\");\n        var currentUrl = UrlUtils.removeHashFromUrl(window.location.href);\n        var finalRedirectUrl = UrlUtils.removeHashFromUrl(loginRequestUrl);\n\n        if (currentUrl !== finalRedirectUrl) {\n          this.logger.verbose(\"Current url is not login request url, navigating\");\n          this.logger.verbosePii(\"CurrentUrl: \" + currentUrl + \", finalRedirectUrl: \" + finalRedirectUrl);\n          window.location.assign(\"\" + finalRedirectUrl + hash);\n          return;\n        } else {\n          this.logger.verbose(\"Current url matches login request url\");\n          var loginRequestUrlComponents = UrlUtils.GetUrlComponents(loginRequestUrl);\n\n          if (loginRequestUrlComponents.Hash) {\n            this.logger.verbose(\"Login request url contains hash, resetting non-msal hash\");\n            window.location.hash = loginRequestUrlComponents.Hash;\n          }\n        }\n      }\n    } else if (!this.config.auth.navigateToLoginRequestUrl) {\n      this.logger.verbose(\"Default navigation to start page after login turned off\");\n    }\n\n    this.processCallBack(hash, stateInfo, null);\n  };\n  /**\r\n   * @hidden\r\n   * Creates a stateInfo object from the URL fragment and returns it.\r\n   * @param {string} hash  -  Hash passed from redirect page\r\n   * @returns {TokenResponse} an object created from the redirect response from AAD comprising of the keys - parameters, requestType, stateMatch, stateResponse and valid.\r\n   * @ignore\r\n   */\n\n\n  UserAgentApplication.prototype.getResponseState = function (hash) {\n    this.logger.verbose(\"GetResponseState has been called\");\n    var parameters = UrlUtils.deserializeHash(hash);\n    var stateResponse;\n\n    if (!parameters) {\n      throw AuthError.createUnexpectedError(\"Hash was not parsed correctly.\");\n    }\n\n    if (parameters.hasOwnProperty(ServerHashParamKeys.STATE)) {\n      this.logger.verbose(\"Hash contains state. Creating stateInfo object\");\n      var parsedState = RequestUtils.parseLibraryState(parameters.state);\n      stateResponse = {\n        requestType: Constants.unknown,\n        state: parameters.state,\n        timestamp: parsedState.ts,\n        method: parsedState.method,\n        stateMatch: false\n      };\n    } else {\n      throw AuthError.createUnexpectedError(\"Hash does not contain state.\");\n    }\n    /*\r\n     * async calls can fire iframe and login request at the same time if developer does not use the API as expected\r\n     * incoming callback needs to be looked up to find the request type\r\n     */\n    // loginRedirect\n\n\n    if (stateResponse.state === this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_LOGIN, stateResponse.state), this.inCookie) || stateResponse.state === this.silentAuthenticationState) {\n      this.logger.verbose(\"State matches cached state, setting requestType to login\");\n      stateResponse.requestType = Constants.login;\n      stateResponse.stateMatch = true;\n      return stateResponse;\n    } // acquireTokenRedirect\n    else if (stateResponse.state === this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_ACQ_TOKEN, stateResponse.state), this.inCookie)) {\n        this.logger.verbose(\"State matches cached state, setting requestType to renewToken\");\n        stateResponse.requestType = Constants.renewToken;\n        stateResponse.stateMatch = true;\n        return stateResponse;\n      } // external api requests may have many renewtoken requests for different resource\n\n\n    if (!stateResponse.stateMatch) {\n      this.logger.verbose(\"State does not match cached state, setting requestType to type from window\");\n      stateResponse.requestType = window.requestType;\n      var statesInParentContext = window.renewStates;\n\n      for (var i = 0; i < statesInParentContext.length; i++) {\n        if (statesInParentContext[i] === stateResponse.state) {\n          this.logger.verbose(\"Matching state found for request\");\n          stateResponse.stateMatch = true;\n          break;\n        }\n      }\n\n      if (!stateResponse.stateMatch) {\n        this.logger.verbose(\"Matching state not found for request\");\n      }\n    }\n\n    return stateResponse;\n  }; // #endregion\n  // #region Token Processing (Extract to TokenProcessing.ts)\n\n  /**\r\n   * @hidden\r\n   * Used to get token for the specified set of scopes from the cache\r\n   * @param {@link ServerRequestParameters} - Request sent to the STS to obtain an id_token/access_token\r\n   * @param {Account} account - Account for which the scopes were requested\r\n   */\n\n\n  UserAgentApplication.prototype.getCachedToken = function (serverAuthenticationRequest, account) {\n    this.logger.verbose(\"GetCachedToken has been called\");\n    var scopes = serverAuthenticationRequest.scopes;\n    /**\r\n     * Id Token should be returned in every acquireTokenSilent call. The only exception is a response_type = token\r\n     * request when a valid ID Token is not present in the cache.\r\n     */\n\n    var idToken = this.getCachedIdToken(serverAuthenticationRequest, account);\n    var authResponse = this.getCachedAccessToken(serverAuthenticationRequest, account, scopes);\n    var accountState = this.getAccountState(serverAuthenticationRequest.state);\n    return ResponseUtils.buildAuthResponse(idToken, authResponse, serverAuthenticationRequest, account, scopes, accountState);\n  };\n  /**\r\n   * @hidden\r\n   *\r\n   * Uses passed in authority to further filter an array of tokenCacheItems until only the token being searched for remains, then returns that tokenCacheItem.\r\n   * This method will throw if authority filtering still yields multiple matching tokens and will return null if not tokens match the authority passed in.\r\n   *\r\n   * @param authority\r\n   * @param tokenCacheItems\r\n   * @param request\r\n   * @param requestScopes\r\n   * @param tokenType\r\n   */\n\n\n  UserAgentApplication.prototype.getTokenCacheItemByAuthority = function (authority, tokenCacheItems, requestScopes, tokenType) {\n    var _this = this;\n\n    var filteredAuthorityItems;\n\n    if (UrlUtils.isCommonAuthority(authority) || UrlUtils.isOrganizationsAuthority(authority)) {\n      filteredAuthorityItems = AuthCacheUtils.filterTokenCacheItemsByDomain(tokenCacheItems, UrlUtils.GetUrlComponents(authority).HostNameAndPort);\n    } else {\n      filteredAuthorityItems = AuthCacheUtils.filterTokenCacheItemsByAuthority(tokenCacheItems, authority);\n    }\n\n    if (filteredAuthorityItems.length === 1) {\n      return filteredAuthorityItems[0];\n    } else if (filteredAuthorityItems.length > 1) {\n      this.logger.warning(\"Multiple matching tokens found. Cleaning cache and requesting a new token.\");\n      filteredAuthorityItems.forEach(function (accessTokenCacheItem) {\n        _this.cacheStorage.removeItem(JSON.stringify(accessTokenCacheItem.key));\n      });\n      return null;\n    } else {\n      this.logger.verbose(\"No matching tokens of type \" + tokenType + \" found\");\n      return null;\n    }\n  };\n  /**\r\n   *\r\n   * @hidden\r\n   *\r\n   * Searches the token cache for an ID Token that matches the request parameter and returns it as an IdToken object.\r\n   *\r\n   * @param serverAuthenticationRequest\r\n   * @param account\r\n   */\n\n\n  UserAgentApplication.prototype.getCachedIdToken = function (serverAuthenticationRequest, account) {\n    this.logger.verbose(\"Getting all cached tokens of type ID Token\");\n    var idTokenCacheItems = this.cacheStorage.getAllIdTokens(this.clientId, account ? account.homeAccountIdentifier : null);\n    var matchAuthority = serverAuthenticationRequest.authority || this.authority;\n    var idTokenCacheItem = this.getTokenCacheItemByAuthority(matchAuthority, idTokenCacheItems, null, ServerHashParamKeys.ID_TOKEN);\n\n    if (idTokenCacheItem) {\n      this.logger.verbose(\"Evaluating ID token found\");\n      var idTokenIsStillValid = this.evaluateTokenExpiration(idTokenCacheItem);\n\n      if (idTokenIsStillValid) {\n        this.logger.verbose(\"ID token expiration is within offset, using ID token found in cache\");\n        var idTokenValue = idTokenCacheItem.value;\n\n        if (idTokenValue) {\n          this.logger.verbose(\"ID Token found in cache is valid and unexpired\");\n        } else {\n          this.logger.verbose(\"ID Token found in cache is invalid\");\n        }\n\n        return idTokenValue ? new IdToken(idTokenValue.idToken) : null;\n      } else {\n        this.logger.verbose(\"Cached ID token is expired, removing from cache\");\n        this.cacheStorage.removeItem(JSON.stringify(idTokenCacheItem.key));\n        return null;\n      }\n    } else {\n      this.logger.verbose(\"No tokens found\");\n      return null;\n    }\n  };\n  /**\r\n   *\r\n   * @hidden\r\n   *\r\n   * Searches the token cache for an access token that matches the request parameters and returns it as an AuthResponse.\r\n   *\r\n   * @param serverAuthenticationRequest\r\n   * @param account\r\n   * @param scopes\r\n   */\n\n\n  UserAgentApplication.prototype.getCachedAccessToken = function (serverAuthenticationRequest, account, scopes) {\n    this.logger.verbose(\"Getting all cached tokens of type Access Token\");\n    var tokenCacheItems = this.cacheStorage.getAllAccessTokens(this.clientId, account ? account.homeAccountIdentifier : null);\n    var scopeFilteredTokenCacheItems = AuthCacheUtils.filterTokenCacheItemsByScope(tokenCacheItems, scopes);\n    var matchAuthority = serverAuthenticationRequest.authority || this.authority; // serverAuthenticationRequest.authority can only be common or organizations if not null\n\n    var accessTokenCacheItem = this.getTokenCacheItemByAuthority(matchAuthority, scopeFilteredTokenCacheItems, scopes, ServerHashParamKeys.ACCESS_TOKEN);\n\n    if (!accessTokenCacheItem) {\n      this.logger.verbose(\"No matching token found when filtering by scope and authority\");\n      var authorityList = this.getUniqueAuthority(tokenCacheItems, \"authority\");\n\n      if (authorityList.length > 1) {\n        throw ClientAuthError.createMultipleAuthoritiesInCacheError(scopes.toString());\n      }\n\n      this.logger.verbose(\"Single authority used, setting authorityInstance\");\n      serverAuthenticationRequest.authorityInstance = AuthorityFactory.CreateInstance(authorityList[0], this.config.auth.validateAuthority);\n      return null;\n    } else {\n      serverAuthenticationRequest.authorityInstance = AuthorityFactory.CreateInstance(accessTokenCacheItem.key.authority, this.config.auth.validateAuthority);\n      this.logger.verbose(\"Evaluating access token found\");\n      var tokenIsStillValid = this.evaluateTokenExpiration(accessTokenCacheItem); // The response value will stay null if token retrieved from the cache is expired, otherwise it will be populated with said token's data\n\n      if (tokenIsStillValid) {\n        this.logger.verbose(\"Access token expiration is within offset, using access token found in cache\");\n\n        if (!account) {\n          account = this.getAccount();\n\n          if (!account) {\n            throw AuthError.createUnexpectedError(\"Account should not be null here.\");\n          }\n        }\n\n        var aState = this.getAccountState(serverAuthenticationRequest.state);\n        var response = {\n          uniqueId: \"\",\n          tenantId: \"\",\n          tokenType: ServerHashParamKeys.ACCESS_TOKEN,\n          idToken: null,\n          idTokenClaims: null,\n          accessToken: accessTokenCacheItem.value.accessToken,\n          scopes: accessTokenCacheItem.key.scopes.split(\" \"),\n          expiresOn: new Date(Number(accessTokenCacheItem.value.expiresIn) * 1000),\n          account: account,\n          accountState: aState,\n          fromCache: true\n        };\n        return response;\n      } else {\n        this.logger.verbose(\"Access token expired, removing from cache\");\n        this.cacheStorage.removeItem(JSON.stringify(accessTokenCacheItem.key));\n        return null;\n      }\n    }\n  };\n  /**\r\n   * Returns true if the token passed in is within the acceptable expiration time offset, false if it is expired.\r\n   * @param tokenCacheItem\r\n   * @param serverAuthenticationRequest\r\n   */\n\n\n  UserAgentApplication.prototype.evaluateTokenExpiration = function (tokenCacheItem) {\n    var expiration = Number(tokenCacheItem.value.expiresIn);\n    return TokenUtils.validateExpirationIsWithinOffset(expiration, this.config.system.tokenRenewalOffsetSeconds);\n  };\n  /**\r\n   * @hidden\r\n   * Used to get a unique list of authorities from the cache\r\n   * @param {Array<AccessTokenCacheItem>}  accessTokenCacheItems - accessTokenCacheItems saved in the cache\r\n   * @ignore\r\n   */\n\n\n  UserAgentApplication.prototype.getUniqueAuthority = function (accessTokenCacheItems, property) {\n    this.logger.verbose(\"GetUniqueAuthority has been called\");\n    var authorityList = [];\n    var flags = [];\n    accessTokenCacheItems.forEach(function (element) {\n      if (element.key.hasOwnProperty(property) && flags.indexOf(element.key[property]) === -1) {\n        flags.push(element.key[property]);\n        authorityList.push(element.key[property]);\n      }\n    });\n    return authorityList;\n  };\n  /**\r\n   * @hidden\r\n   * Check if ADAL id_token exists and return if exists.\r\n   *\r\n   */\n\n\n  UserAgentApplication.prototype.extractADALIdToken = function () {\n    this.logger.verbose(\"ExtractADALIdToken has been called\");\n    var adalIdToken = this.cacheStorage.getItem(Constants.adalIdToken);\n    return !StringUtils.isEmpty(adalIdToken) ? TokenUtils.extractIdToken(adalIdToken) : null;\n  };\n  /**\r\n   * @hidden\r\n   * Acquires access token using a hidden iframe.\r\n   * @ignore\r\n   */\n\n\n  UserAgentApplication.prototype.renewToken = function (requestSignature, resolve, reject, account, serverAuthenticationRequest) {\n    this.logger.verbose(\"RenewToken has been called\");\n    this.logger.verbosePii(\"RenewToken scope and authority: \" + requestSignature);\n    var frameName = WindowUtils.generateFrameName(FramePrefix.TOKEN_FRAME, requestSignature);\n    WindowUtils.addHiddenIFrame(frameName, this.logger);\n    this.updateCacheEntries(serverAuthenticationRequest, account, false);\n    this.logger.verbosePii(\"RenewToken expected state: \" + serverAuthenticationRequest.state); // Build urlNavigate with \"prompt=none\" and navigate to URL in hidden iFrame\n\n    var urlNavigate = UrlUtils.urlRemoveQueryStringParameter(UrlUtils.createNavigateUrl(serverAuthenticationRequest), Constants.prompt) + Constants.prompt_none + Constants.response_mode_fragment;\n    window.renewStates.push(serverAuthenticationRequest.state);\n    window.requestType = Constants.renewToken;\n    this.logger.verbose(\"Set window.renewState and requestType\");\n    this.registerCallback(serverAuthenticationRequest.state, requestSignature, resolve, reject);\n    this.logger.infoPii(\"Navigate to: \" + urlNavigate);\n    this.loadIframeTimeout(urlNavigate, frameName, requestSignature).catch(function (error) {\n      return reject(error);\n    });\n  };\n  /**\r\n   * @hidden\r\n   * Renews idtoken for app's own backend when clientId is passed as a single scope in the scopes array.\r\n   * @ignore\r\n   */\n\n\n  UserAgentApplication.prototype.renewIdToken = function (requestSignature, resolve, reject, account, serverAuthenticationRequest) {\n    this.logger.info(\"RenewIdToken has been called\");\n    var frameName = WindowUtils.generateFrameName(FramePrefix.ID_TOKEN_FRAME, requestSignature);\n    WindowUtils.addHiddenIFrame(frameName, this.logger);\n    this.updateCacheEntries(serverAuthenticationRequest, account, false);\n    this.logger.verbose(\"RenewIdToken expected state: \" + serverAuthenticationRequest.state); // Build urlNavigate with \"prompt=none\" and navigate to URL in hidden iFrame\n\n    var urlNavigate = UrlUtils.urlRemoveQueryStringParameter(UrlUtils.createNavigateUrl(serverAuthenticationRequest), Constants.prompt) + Constants.prompt_none + Constants.response_mode_fragment;\n\n    if (this.silentLogin) {\n      this.logger.verbose(\"Silent login is true, set silentAuthenticationState\");\n      window.requestType = Constants.login;\n      this.silentAuthenticationState = serverAuthenticationRequest.state;\n    } else {\n      this.logger.verbose(\"Not silent login, set window.renewState and requestType\");\n      window.requestType = Constants.renewToken;\n      window.renewStates.push(serverAuthenticationRequest.state);\n    } // note: scope here is clientId\n\n\n    this.registerCallback(serverAuthenticationRequest.state, requestSignature, resolve, reject);\n    this.logger.infoPii(\"Navigate to:\\\" \" + urlNavigate);\n    this.loadIframeTimeout(urlNavigate, frameName, requestSignature).catch(function (error) {\n      return reject(error);\n    });\n  };\n  /**\r\n   * @hidden\r\n   *\r\n   * This method builds an Access Token Cache item and saves it to the cache, returning the original\r\n   * AuthResponse augmented with a parsed expiresOn attribute.\r\n   *\r\n   * @param response The AuthResponse object that contains the token to be saved\r\n   * @param authority The authority under which the ID token will be cached\r\n   * @param scopes The scopes to be added to the cache item key (undefined for ID token cache items)\r\n   * @param clientInfo Client Info object that is used to generate the homeAccountIdentifier\r\n   * @param expiration Token expiration timestamp\r\n   */\n\n\n  UserAgentApplication.prototype.saveToken = function (response, authority, scopes, clientInfo, expiration) {\n    var accessTokenKey = new AccessTokenKey(authority, this.clientId, scopes, clientInfo.uid, clientInfo.utid);\n    var accessTokenValue = new AccessTokenValue(response.accessToken, response.idToken.rawIdToken, expiration.toString(), clientInfo.encodeClientInfo());\n    this.cacheStorage.setItem(JSON.stringify(accessTokenKey), JSON.stringify(accessTokenValue));\n\n    if (expiration) {\n      this.logger.verbose(\"New expiration set for token\");\n      response.expiresOn = new Date(expiration * 1000);\n    } else {\n      this.logger.error(\"Could not parse expiresIn parameter for access token\");\n    }\n\n    return response;\n  };\n  /**\r\n   * @hidden\r\n   *\r\n   * This method sets up the elements of an ID Token cache item and calls saveToken to save it in\r\n   * Access Token Cache item format for the client application to use.\r\n   *\r\n   * @param response The AuthResponse object that will be used to build the cache item\r\n   * @param authority The authority under which the ID token will be cached\r\n   * @param parameters The response's Hash Params, which contain the ID token returned from the server\r\n   * @param clientInfo Client Info object that is used to generate the homeAccountIdentifier\r\n   * @param idTokenObj ID Token object from which the ID token's expiration is extracted\r\n   */\n\n  /* tslint:disable:no-string-literal */\n\n\n  UserAgentApplication.prototype.saveIdToken = function (response, authority, parameters, clientInfo, idTokenObj) {\n    this.logger.verbose(\"SaveIdToken has been called\");\n\n    var idTokenResponse = tslib_1.__assign({}, response); // Scopes are undefined so they don't show up in ID token cache key\n\n\n    var scopes;\n    idTokenResponse.scopes = Constants.oidcScopes;\n    idTokenResponse.accessToken = parameters[ServerHashParamKeys.ID_TOKEN];\n    var expiration = Number(idTokenObj.expiration); // Set ID Token item in cache\n\n    this.logger.verbose(\"Saving ID token to cache\");\n    return this.saveToken(idTokenResponse, authority, scopes, clientInfo, expiration);\n  };\n  /**\r\n   * @hidden\r\n   *\r\n   * This method sets up the elements of an Access Token cache item and calls saveToken to save it to the cache\r\n   *\r\n   * @param response The AuthResponse object that will be used to build the cache item\r\n   * @param authority The authority under which the access token will be cached\r\n   * @param parameters The response's Hash Params, which contain the access token returned from the server\r\n   * @param clientInfo Client Info object that is used to generate the homeAccountIdentifier\r\n   */\n\n  /* tslint:disable:no-string-literal */\n\n\n  UserAgentApplication.prototype.saveAccessToken = function (response, authority, parameters, clientInfo) {\n    this.logger.verbose(\"SaveAccessToken has been called\");\n\n    var accessTokenResponse = tslib_1.__assign({}, response); // read the scopes\n\n\n    var scope = parameters[ServerHashParamKeys.SCOPE];\n    var consentedScopes = scope.split(\" \"); // retrieve all access tokens from the cache, remove the dup scopes\n\n    var accessTokenCacheItems = this.cacheStorage.getAllAccessTokens(this.clientId, authority);\n    this.logger.verbose(\"Retrieving all access tokens from cache and removing duplicates\");\n\n    for (var i = 0; i < accessTokenCacheItems.length; i++) {\n      var accessTokenCacheItem = accessTokenCacheItems[i];\n\n      if (accessTokenCacheItem.key.homeAccountIdentifier === response.account.homeAccountIdentifier) {\n        var cachedScopes = accessTokenCacheItem.key.scopes.split(\" \");\n\n        if (ScopeSet.isIntersectingScopes(cachedScopes, consentedScopes)) {\n          this.cacheStorage.removeItem(JSON.stringify(accessTokenCacheItem.key));\n        }\n      }\n    }\n\n    accessTokenResponse.accessToken = parameters[ServerHashParamKeys.ACCESS_TOKEN];\n    accessTokenResponse.scopes = consentedScopes;\n    var expiresIn = TimeUtils.parseExpiresIn(parameters[ServerHashParamKeys.EXPIRES_IN]);\n    var parsedState = RequestUtils.parseLibraryState(parameters[ServerHashParamKeys.STATE]);\n    var expiration = parsedState.ts + expiresIn;\n    this.logger.verbose(\"Saving access token to cache\");\n    return this.saveToken(accessTokenResponse, authority, scope, clientInfo, expiration);\n  };\n  /**\r\n   * @hidden\r\n   * Saves token or error received in the response from AAD in the cache. In case of id_token, it also creates the account object.\r\n   * @ignore\r\n   */\n\n\n  UserAgentApplication.prototype.saveTokenFromHash = function (hash, stateInfo) {\n    this.logger.verbose(\"SaveTokenFromHash has been called\");\n    this.logger.info(\"State status: \" + stateInfo.stateMatch + \"; Request type: \" + stateInfo.requestType);\n    var response = {\n      uniqueId: \"\",\n      tenantId: \"\",\n      tokenType: \"\",\n      idToken: null,\n      idTokenClaims: null,\n      accessToken: null,\n      scopes: [],\n      expiresOn: null,\n      account: null,\n      accountState: \"\",\n      fromCache: false\n    };\n    var error;\n    var hashParams = UrlUtils.deserializeHash(hash);\n    var authorityKey = \"\";\n    var acquireTokenAccountKey = \"\";\n    var idTokenObj = null; // If server returns an error\n\n    if (hashParams.hasOwnProperty(ServerHashParamKeys.ERROR_DESCRIPTION) || hashParams.hasOwnProperty(ServerHashParamKeys.ERROR)) {\n      this.logger.verbose(\"Server returned an error\");\n      this.logger.infoPii(\"Error : \" + hashParams[ServerHashParamKeys.ERROR] + \"; Error description: \" + hashParams[ServerHashParamKeys.ERROR_DESCRIPTION]);\n      this.cacheStorage.setItem(ErrorCacheKeys.ERROR, hashParams[ServerHashParamKeys.ERROR]);\n      this.cacheStorage.setItem(ErrorCacheKeys.ERROR_DESC, hashParams[ServerHashParamKeys.ERROR_DESCRIPTION]); // login\n\n      if (stateInfo.requestType === Constants.login) {\n        this.logger.verbose(\"RequestType is login, caching login error, generating authorityKey\");\n        this.cacheStorage.setItem(ErrorCacheKeys.LOGIN_ERROR, hashParams[ServerHashParamKeys.ERROR_DESCRIPTION] + \":\" + hashParams[ServerHashParamKeys.ERROR]);\n        authorityKey = AuthCache.generateAuthorityKey(stateInfo.state);\n      } // acquireToken\n\n\n      if (stateInfo.requestType === Constants.renewToken) {\n        this.logger.verbose(\"RequestType is renewToken, generating acquireTokenAccountKey\");\n        authorityKey = AuthCache.generateAuthorityKey(stateInfo.state);\n        var account = this.getAccount();\n        var accountId = void 0;\n\n        if (account && !StringUtils.isEmpty(account.homeAccountIdentifier)) {\n          accountId = account.homeAccountIdentifier;\n          this.logger.verbose(\"AccountId is set\");\n        } else {\n          accountId = Constants.no_account;\n          this.logger.verbose(\"AccountId is set as no_account\");\n        }\n\n        acquireTokenAccountKey = AuthCache.generateAcquireTokenAccountKey(accountId, stateInfo.state);\n      }\n\n      var _a = ServerHashParamKeys.ERROR,\n          hashErr = hashParams[_a],\n          _b = ServerHashParamKeys.ERROR_DESCRIPTION,\n          hashErrDesc = hashParams[_b];\n\n      if (InteractionRequiredAuthError.isInteractionRequiredError(hashErr) || InteractionRequiredAuthError.isInteractionRequiredError(hashErrDesc)) {\n        error = new InteractionRequiredAuthError(hashParams[ServerHashParamKeys.ERROR], hashParams[ServerHashParamKeys.ERROR_DESCRIPTION]);\n      } else {\n        error = new ServerError(hashParams[ServerHashParamKeys.ERROR], hashParams[ServerHashParamKeys.ERROR_DESCRIPTION]);\n      }\n    } // If the server returns \"Success\"\n    else {\n        this.logger.verbose(\"Server returns success\"); // Verify the state from redirect and record tokens to storage if exists\n\n        if (stateInfo.stateMatch) {\n          this.logger.info(\"State is right\");\n\n          if (hashParams.hasOwnProperty(ServerHashParamKeys.SESSION_STATE)) {\n            this.logger.verbose(\"Fragment has session state, caching\");\n            this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.SESSION_STATE, stateInfo.state), hashParams[ServerHashParamKeys.SESSION_STATE]);\n          }\n\n          response.accountState = this.getAccountState(stateInfo.state);\n          var clientInfo = void 0; // Process access_token\n\n          if (hashParams.hasOwnProperty(ServerHashParamKeys.ACCESS_TOKEN)) {\n            this.logger.info(\"Fragment has access token\");\n            response.accessToken = hashParams[ServerHashParamKeys.ACCESS_TOKEN];\n\n            if (hashParams.hasOwnProperty(ServerHashParamKeys.SCOPE)) {\n              response.scopes = hashParams[ServerHashParamKeys.SCOPE].split(\" \");\n            } // retrieve the id_token from response if present\n\n\n            if (hashParams.hasOwnProperty(ServerHashParamKeys.ID_TOKEN)) {\n              this.logger.verbose(\"Fragment has id_token\");\n              idTokenObj = new IdToken(hashParams[ServerHashParamKeys.ID_TOKEN]);\n            } else {\n              this.logger.verbose(\"No idToken on fragment, getting idToken from cache\");\n              idTokenObj = new IdToken(this.cacheStorage.getItem(PersistentCacheKeys.IDTOKEN));\n            }\n\n            response = ResponseUtils.setResponseIdToken(response, idTokenObj); // set authority\n\n            var authority = this.populateAuthority(stateInfo.state, this.inCookie, this.cacheStorage, idTokenObj);\n            this.logger.verbose(\"Got authority from cache\"); // retrieve client_info - if it is not found, generate the uid and utid from idToken\n\n            if (hashParams.hasOwnProperty(ServerHashParamKeys.CLIENT_INFO)) {\n              this.logger.verbose(\"Fragment has clientInfo\");\n              clientInfo = new ClientInfo(hashParams[ServerHashParamKeys.CLIENT_INFO], authority);\n            } else if (this.authorityInstance.AuthorityType === AuthorityType.Adfs) {\n              clientInfo = ClientInfo.createClientInfoFromIdToken(idTokenObj, authority);\n            } else {\n              this.logger.warning(\"ClientInfo not received in the response from AAD\");\n            }\n\n            response.account = Account.createAccount(idTokenObj, clientInfo);\n            this.logger.verbose(\"Account object created from response\");\n            var accountKey = void 0;\n\n            if (response.account && !StringUtils.isEmpty(response.account.homeAccountIdentifier)) {\n              this.logger.verbose(\"AccountKey set\");\n              accountKey = response.account.homeAccountIdentifier;\n            } else {\n              this.logger.verbose(\"AccountKey set as no_account\");\n              accountKey = Constants.no_account;\n            }\n\n            acquireTokenAccountKey = AuthCache.generateAcquireTokenAccountKey(accountKey, stateInfo.state);\n            var acquireTokenAccountKey_noaccount = AuthCache.generateAcquireTokenAccountKey(Constants.no_account, stateInfo.state);\n            this.logger.verbose(\"AcquireTokenAccountKey generated\");\n            var cachedAccount = this.cacheStorage.getItem(acquireTokenAccountKey);\n            var acquireTokenAccount = void 0; // Check with the account in the Cache\n\n            if (!StringUtils.isEmpty(cachedAccount)) {\n              acquireTokenAccount = JSON.parse(cachedAccount);\n              this.logger.verbose(\"AcquireToken request account retrieved from cache\");\n\n              if (response.account && acquireTokenAccount && Account.compareAccounts(response.account, acquireTokenAccount)) {\n                response = this.saveAccessToken(response, authority, hashParams, clientInfo);\n                this.logger.info(\"The user object received in the response is the same as the one passed in the acquireToken request\");\n              } else {\n                this.logger.warning(\"The account object created from the response is not the same as the one passed in the acquireToken request\");\n              }\n            } else if (!StringUtils.isEmpty(this.cacheStorage.getItem(acquireTokenAccountKey_noaccount))) {\n              this.logger.verbose(\"No acquireToken account retrieved from cache\");\n              response = this.saveAccessToken(response, authority, hashParams, clientInfo);\n            }\n          } // Process id_token\n\n\n          if (hashParams.hasOwnProperty(ServerHashParamKeys.ID_TOKEN)) {\n            this.logger.info(\"Fragment has idToken\"); // set the idToken\n\n            idTokenObj = new IdToken(hashParams[ServerHashParamKeys.ID_TOKEN]); // set authority\n\n            var authority = this.populateAuthority(stateInfo.state, this.inCookie, this.cacheStorage, idTokenObj);\n            response = ResponseUtils.setResponseIdToken(response, idTokenObj);\n\n            if (hashParams.hasOwnProperty(ServerHashParamKeys.CLIENT_INFO)) {\n              this.logger.verbose(\"Fragment has clientInfo\");\n              clientInfo = new ClientInfo(hashParams[ServerHashParamKeys.CLIENT_INFO], authority);\n            } else if (this.authorityInstance.AuthorityType === AuthorityType.Adfs) {\n              clientInfo = ClientInfo.createClientInfoFromIdToken(idTokenObj, authority);\n            } else {\n              this.logger.warning(\"ClientInfo not received in the response from AAD\");\n            }\n\n            this.account = Account.createAccount(idTokenObj, clientInfo);\n            response.account = this.account;\n            this.logger.verbose(\"Account object created from response\");\n\n            if (idTokenObj && idTokenObj.nonce) {\n              this.logger.verbose(\"IdToken has nonce\"); // check nonce integrity if idToken has nonce - throw an error if not matched\n\n              var cachedNonce = this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN, stateInfo.state), this.inCookie);\n\n              if (idTokenObj.nonce !== cachedNonce) {\n                this.account = null;\n                this.cacheStorage.setItem(ErrorCacheKeys.LOGIN_ERROR, \"Nonce Mismatch. Expected Nonce: \" + cachedNonce + \",\" + \"Actual Nonce: \" + idTokenObj.nonce);\n                this.logger.error(\"Nonce Mismatch. Expected Nonce: \" + cachedNonce + \", Actual Nonce: \" + idTokenObj.nonce);\n                error = ClientAuthError.createNonceMismatchError(cachedNonce, idTokenObj.nonce);\n              } // Save the token\n              else {\n                  this.logger.verbose(\"Nonce matches, saving idToken to cache\");\n                  this.cacheStorage.setItem(PersistentCacheKeys.IDTOKEN, hashParams[ServerHashParamKeys.ID_TOKEN], this.inCookie);\n                  this.cacheStorage.setItem(PersistentCacheKeys.CLIENT_INFO, clientInfo.encodeClientInfo(), this.inCookie); // Save idToken as access token item for app itself\n\n                  this.saveIdToken(response, authority, hashParams, clientInfo, idTokenObj);\n                }\n            } else {\n              this.logger.verbose(\"No idToken or no nonce. Cache key for Authority set as state\");\n              authorityKey = stateInfo.state;\n              acquireTokenAccountKey = stateInfo.state;\n              this.logger.error(\"Invalid id_token received in the response\");\n              error = ClientAuthError.createInvalidIdTokenError(idTokenObj);\n              this.cacheStorage.setItem(ErrorCacheKeys.ERROR, error.errorCode);\n              this.cacheStorage.setItem(ErrorCacheKeys.ERROR_DESC, error.errorMessage);\n            }\n          }\n        } // State mismatch - unexpected/invalid state\n        else {\n            this.logger.verbose(\"State mismatch\");\n            authorityKey = stateInfo.state;\n            acquireTokenAccountKey = stateInfo.state;\n            var expectedState = this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_LOGIN, stateInfo.state), this.inCookie);\n            this.logger.error(\"State Mismatch. Expected State: \" + expectedState + \", Actual State: \" + stateInfo.state);\n            error = ClientAuthError.createInvalidStateError(stateInfo.state, expectedState);\n            this.cacheStorage.setItem(ErrorCacheKeys.ERROR, error.errorCode);\n            this.cacheStorage.setItem(ErrorCacheKeys.ERROR_DESC, error.errorMessage);\n          }\n      } // Set status to completed\n\n\n    this.cacheStorage.removeItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, stateInfo.state));\n    this.cacheStorage.resetTempCacheItems(stateInfo.state);\n    this.logger.verbose(\"Status set to complete, temporary cache cleared\"); // this is required if navigateToLoginRequestUrl=false\n\n    if (this.inCookie) {\n      this.logger.verbose(\"InCookie is true, setting authorityKey in cookie\");\n      this.cacheStorage.setItemCookie(authorityKey, \"\", -1);\n      this.cacheStorage.clearMsalCookie(stateInfo.state);\n    }\n\n    if (error) {\n      // Error case, set status to cancelled\n      throw error;\n    }\n\n    if (!response) {\n      throw AuthError.createUnexpectedError(\"Response is null\");\n    }\n\n    return response;\n  };\n  /**\r\n   * Set Authority when saving Token from the hash\r\n   * @param state\r\n   * @param inCookie\r\n   * @param cacheStorage\r\n   * @param idTokenObj\r\n   * @param response\r\n   */\n\n\n  UserAgentApplication.prototype.populateAuthority = function (state, inCookie, cacheStorage, idTokenObj) {\n    this.logger.verbose(\"PopulateAuthority has been called\");\n    var authorityKey = AuthCache.generateAuthorityKey(state);\n    var cachedAuthority = cacheStorage.getItem(authorityKey, inCookie); // retrieve the authority from cache and replace with tenantID\n\n    return StringUtils.isEmpty(cachedAuthority) ? cachedAuthority : UrlUtils.replaceTenantPath(cachedAuthority, idTokenObj.tenantId);\n  };\n  /* tslint:enable:no-string-literal */\n  // #endregion\n  // #region Account\n\n  /**\r\n   * Returns the signed in account\r\n   * (the account object is created at the time of successful login)\r\n   * or null when no state is found\r\n   * @returns {@link Account} - the account object stored in MSAL\r\n   */\n\n\n  UserAgentApplication.prototype.getAccount = function () {\n    // if a session already exists, get the account from the session\n    if (this.account) {\n      return this.account;\n    } // frame is used to get idToken and populate the account for the given session\n\n\n    var rawIdToken = this.cacheStorage.getItem(PersistentCacheKeys.IDTOKEN, this.inCookie);\n    var rawClientInfo = this.cacheStorage.getItem(PersistentCacheKeys.CLIENT_INFO, this.inCookie);\n\n    if (!StringUtils.isEmpty(rawIdToken) && !StringUtils.isEmpty(rawClientInfo)) {\n      var idToken = new IdToken(rawIdToken);\n      var clientInfo = new ClientInfo(rawClientInfo, \"\");\n      this.account = Account.createAccount(idToken, clientInfo);\n      return this.account;\n    } // if login not yet done, return null\n\n\n    return null;\n  };\n  /**\r\n   * @hidden\r\n   *\r\n   * Extracts state value from the accountState sent with the authentication request.\r\n   * @returns {string} scope.\r\n   * @ignore\r\n   */\n\n\n  UserAgentApplication.prototype.getAccountState = function (state) {\n    if (state) {\n      var splitIndex = state.indexOf(Constants.resourceDelimiter);\n\n      if (splitIndex > -1 && splitIndex + 1 < state.length) {\n        return state.substring(splitIndex + 1);\n      }\n    }\n\n    return state;\n  };\n  /**\r\n   * Use to get a list of unique accounts in MSAL cache based on homeAccountIdentifier.\r\n   *\r\n   * @param {@link Array<Account>} Account - all unique accounts in MSAL cache.\r\n   */\n\n\n  UserAgentApplication.prototype.getAllAccounts = function () {\n    var accounts = [];\n    var accessTokenCacheItems = this.cacheStorage.getAllAccessTokens(Constants.clientId, Constants.homeAccountIdentifier);\n\n    for (var i = 0; i < accessTokenCacheItems.length; i++) {\n      var idToken = new IdToken(accessTokenCacheItems[i].value.idToken);\n      var clientInfo = new ClientInfo(accessTokenCacheItems[i].value.homeAccountIdentifier, \"\");\n      var account = Account.createAccount(idToken, clientInfo);\n      accounts.push(account);\n    }\n\n    return this.getUniqueAccounts(accounts);\n  };\n  /**\r\n   * @hidden\r\n   *\r\n   * Used to filter accounts based on homeAccountIdentifier\r\n   * @param {Array<Account>}  Accounts - accounts saved in the cache\r\n   * @ignore\r\n   */\n\n\n  UserAgentApplication.prototype.getUniqueAccounts = function (accounts) {\n    if (!accounts || accounts.length <= 1) {\n      return accounts;\n    }\n\n    var flags = [];\n    var uniqueAccounts = [];\n\n    for (var index = 0; index < accounts.length; ++index) {\n      if (accounts[index].homeAccountIdentifier && flags.indexOf(accounts[index].homeAccountIdentifier) === -1) {\n        flags.push(accounts[index].homeAccountIdentifier);\n        uniqueAccounts.push(accounts[index]);\n      }\n    }\n\n    return uniqueAccounts;\n  }; // #endregion\n  // #region Angular\n\n  /**\r\n   * @hidden\r\n   *\r\n   * Broadcast messages - Used only for Angular?  *\r\n   * @param eventName\r\n   * @param data\r\n   */\n\n\n  UserAgentApplication.prototype.broadcast = function (eventName, data) {\n    var evt = new CustomEvent(eventName, {\n      detail: data\n    });\n    window.dispatchEvent(evt);\n  };\n  /**\r\n   * @hidden\r\n   *\r\n   * Helper function to retrieve the cached token\r\n   *\r\n   * @param scopes\r\n   * @param {@link Account} account\r\n   * @param state\r\n   * @return {@link AuthResponse} AuthResponse\r\n   */\n\n\n  UserAgentApplication.prototype.getCachedTokenInternal = function (scopes, account, state, correlationId) {\n    // Get the current session's account object\n    var accountObject = account || this.getAccount();\n\n    if (!accountObject) {\n      return null;\n    } // Construct AuthenticationRequest based on response type; set \"redirectUri\" from the \"request\" which makes this call from Angular - for this.getRedirectUri()\n\n\n    var newAuthority = this.authorityInstance ? this.authorityInstance : AuthorityFactory.CreateInstance(this.authority, this.config.auth.validateAuthority);\n    var responseType = this.getTokenType(accountObject, scopes);\n    var serverAuthenticationRequest = new ServerRequestParameters(newAuthority, this.clientId, responseType, this.getRedirectUri(), scopes, state, correlationId); // get cached token\n\n    return this.getCachedToken(serverAuthenticationRequest, account);\n  };\n  /**\r\n   * @hidden\r\n   *\r\n   * Get scopes for the Endpoint - Used in Angular to track protected and unprotected resources without interaction from the developer app\r\n   * Note: Please check if we need to set the \"redirectUri\" from the \"request\" which makes this call from Angular - for this.getRedirectUri()\r\n   *\r\n   * @param endpoint\r\n   */\n\n\n  UserAgentApplication.prototype.getScopesForEndpoint = function (endpoint) {\n    // if user specified list of unprotectedResources, no need to send token to these endpoints, return null.\n    if (this.config.framework.unprotectedResources.length > 0) {\n      for (var i = 0; i < this.config.framework.unprotectedResources.length; i++) {\n        if (endpoint.indexOf(this.config.framework.unprotectedResources[i]) > -1) {\n          return null;\n        }\n      }\n    } // process all protected resources and send the matched one\n\n\n    if (this.config.framework.protectedResourceMap.size > 0) {\n      for (var _i = 0, _a = Array.from(this.config.framework.protectedResourceMap.keys()); _i < _a.length; _i++) {\n        var key = _a[_i]; // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1\n\n        if (endpoint.indexOf(key) > -1) {\n          return this.config.framework.protectedResourceMap.get(key);\n        }\n      }\n    }\n    /*\r\n     * default resource will be clientid if nothing specified\r\n     * App will use idtoken for calls to itself\r\n     * check if it's staring from http or https, needs to match with app host\r\n     */\n\n\n    if (endpoint.indexOf(\"http://\") > -1 || endpoint.indexOf(\"https://\") > -1) {\n      if (UrlUtils.getHostFromUri(endpoint) === UrlUtils.getHostFromUri(this.getRedirectUri())) {\n        return new Array(this.clientId);\n      }\n    } else {\n      /*\r\n       * in angular level, the url for $http interceptor call could be relative url,\r\n       * if it's relative call, we'll treat it as app backend call.\r\n       */\n      return new Array(this.clientId);\n    } // if not the app's own backend or not a domain listed in the endpoints structure\n\n\n    return null;\n  };\n  /**\r\n   * Return boolean flag to developer to help inform if login is in progress\r\n   * @returns {boolean} true/false\r\n   */\n\n\n  UserAgentApplication.prototype.getLoginInProgress = function () {\n    return this.cacheStorage.getItem(TemporaryCacheKeys.INTERACTION_STATUS) === Constants.inProgress;\n  };\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * @param loginInProgress\r\n   */\n\n\n  UserAgentApplication.prototype.setInteractionInProgress = function (inProgress) {\n    if (inProgress) {\n      this.cacheStorage.setItem(TemporaryCacheKeys.INTERACTION_STATUS, Constants.inProgress);\n    } else {\n      this.cacheStorage.removeItem(TemporaryCacheKeys.INTERACTION_STATUS);\n    }\n  };\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * @param loginInProgress\r\n   */\n\n\n  UserAgentApplication.prototype.setloginInProgress = function (loginInProgress) {\n    this.setInteractionInProgress(loginInProgress);\n  };\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * returns the status of acquireTokenInProgress\r\n   */\n\n\n  UserAgentApplication.prototype.getAcquireTokenInProgress = function () {\n    return this.cacheStorage.getItem(TemporaryCacheKeys.INTERACTION_STATUS) === Constants.inProgress;\n  };\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * @param acquireTokenInProgress\r\n   */\n\n\n  UserAgentApplication.prototype.setAcquireTokenInProgress = function (acquireTokenInProgress) {\n    this.setInteractionInProgress(acquireTokenInProgress);\n  };\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * returns the logger handle\r\n   */\n\n\n  UserAgentApplication.prototype.getLogger = function () {\n    return this.logger;\n  };\n  /**\r\n   * Sets the logger callback.\r\n   * @param logger Logger callback\r\n   */\n\n\n  UserAgentApplication.prototype.setLogger = function (logger) {\n    this.logger = logger;\n  }; // #endregion\n  // #region Getters and Setters\n\n  /**\r\n   * Use to get the redirect uri configured in MSAL or null.\r\n   * Evaluates redirectUri if its a function, otherwise simply returns its value.\r\n   *\r\n   * @returns {string} redirect URL\r\n   */\n\n\n  UserAgentApplication.prototype.getRedirectUri = function (reqRedirectUri) {\n    if (reqRedirectUri) {\n      return reqRedirectUri;\n    } else if (typeof this.config.auth.redirectUri === \"function\") {\n      return this.config.auth.redirectUri();\n    }\n\n    return this.config.auth.redirectUri;\n  };\n  /**\r\n   * Use to get the post logout redirect uri configured in MSAL or null.\r\n   * Evaluates postLogoutredirectUri if its a function, otherwise simply returns its value.\r\n   *\r\n   * @returns {string} post logout redirect URL\r\n   */\n\n\n  UserAgentApplication.prototype.getPostLogoutRedirectUri = function () {\n    if (typeof this.config.auth.postLogoutRedirectUri === \"function\") {\n      return this.config.auth.postLogoutRedirectUri();\n    }\n\n    return this.config.auth.postLogoutRedirectUri;\n  };\n  /**\r\n   * Use to get the current {@link Configuration} object in MSAL\r\n   *\r\n   * @returns {@link Configuration}\r\n   */\n\n\n  UserAgentApplication.prototype.getCurrentConfiguration = function () {\n    if (!this.config) {\n      throw ClientConfigurationError.createNoSetConfigurationError();\n    }\n\n    return this.config;\n  };\n  /**\r\n   * @ignore\r\n   *\r\n   * Utils function to create the Authentication\r\n   * @param {@link account} account object\r\n   * @param scopes\r\n   *\r\n   * @returns {string} token type: token, id_token or id_token token\r\n   *\r\n   */\n\n\n  UserAgentApplication.prototype.getTokenType = function (accountObject, scopes) {\n    var accountsMatch = Account.compareAccounts(accountObject, this.getAccount());\n    return ServerRequestParameters.determineResponseType(accountsMatch, scopes);\n  };\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * Sets the cachekeys for and stores the account information in cache\r\n   * @param account\r\n   * @param state\r\n   * @hidden\r\n   */\n\n\n  UserAgentApplication.prototype.setAccountCache = function (account, state) {\n    // Cache acquireTokenAccountKey\n    var accountId = account ? this.getAccountId(account) : Constants.no_account;\n    var acquireTokenAccountKey = AuthCache.generateAcquireTokenAccountKey(accountId, state);\n    this.cacheStorage.setItem(acquireTokenAccountKey, JSON.stringify(account));\n  };\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * Sets the cacheKey for and stores the authority information in cache\r\n   * @param state\r\n   * @param authority\r\n   * @hidden\r\n   */\n\n\n  UserAgentApplication.prototype.setAuthorityCache = function (state, authority) {\n    // Cache authorityKey\n    var authorityKey = AuthCache.generateAuthorityKey(state);\n    this.cacheStorage.setItem(authorityKey, UrlUtils.CanonicalizeUri(authority), this.inCookie);\n  };\n  /**\r\n   * Updates account, authority, and nonce in cache\r\n   * @param serverAuthenticationRequest\r\n   * @param account\r\n   * @hidden\r\n   * @ignore\r\n   */\n\n\n  UserAgentApplication.prototype.updateCacheEntries = function (serverAuthenticationRequest, account, isLoginCall, loginStartPage) {\n    // Cache Request Originator Page\n    if (loginStartPage) {\n      this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.LOGIN_REQUEST, serverAuthenticationRequest.state), loginStartPage, this.inCookie);\n    } // Cache account and authority\n\n\n    if (isLoginCall) {\n      // Cache the state\n      this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_LOGIN, serverAuthenticationRequest.state), serverAuthenticationRequest.state, this.inCookie);\n    } else {\n      this.setAccountCache(account, serverAuthenticationRequest.state);\n    } // Cache authorityKey\n\n\n    this.setAuthorityCache(serverAuthenticationRequest.state, serverAuthenticationRequest.authority); // Cache nonce\n\n    this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN, serverAuthenticationRequest.state), serverAuthenticationRequest.nonce, this.inCookie);\n  };\n  /**\r\n   * Returns the unique identifier for the logged in account\r\n   * @param account\r\n   * @hidden\r\n   * @ignore\r\n   */\n\n\n  UserAgentApplication.prototype.getAccountId = function (account) {\n    // return `${account.accountIdentifier}` + Constants.resourceDelimiter + `${account.homeAccountIdentifier}`;\n    var accountId;\n\n    if (!StringUtils.isEmpty(account.homeAccountIdentifier)) {\n      accountId = account.homeAccountIdentifier;\n    } else {\n      accountId = Constants.no_account;\n    }\n\n    return accountId;\n  };\n  /**\r\n   * @ignore\r\n   * @param extraQueryParameters\r\n   *\r\n   * Construct 'tokenRequest' from the available data in adalIdToken\r\n   */\n\n\n  UserAgentApplication.prototype.buildIDTokenRequest = function (request) {\n    var tokenRequest = {\n      scopes: Constants.oidcScopes,\n      authority: this.authority,\n      account: this.getAccount(),\n      extraQueryParameters: request.extraQueryParameters,\n      correlationId: request.correlationId\n    };\n    return tokenRequest;\n  };\n  /**\r\n   * @ignore\r\n   * @param config\r\n   * @param clientId\r\n   *\r\n   * Construct TelemetryManager from Configuration\r\n   */\n\n\n  UserAgentApplication.prototype.getTelemetryManagerFromConfig = function (config, clientId) {\n    if (!config) {\n      // if unset\n      return TelemetryManager.getTelemetrymanagerStub(clientId, this.logger);\n    } // if set then validate\n\n\n    var applicationName = config.applicationName,\n        applicationVersion = config.applicationVersion,\n        telemetryEmitter = config.telemetryEmitter;\n\n    if (!applicationName || !applicationVersion || !telemetryEmitter) {\n      throw ClientConfigurationError.createTelemetryConfigError(config);\n    } // if valid then construct\n\n\n    var telemetryPlatform = {\n      applicationName: applicationName,\n      applicationVersion: applicationVersion\n    };\n    var telemetryManagerConfig = {\n      platform: telemetryPlatform,\n      clientId: clientId\n    };\n    return new TelemetryManager(telemetryManagerConfig, telemetryEmitter, this.logger);\n  };\n\n  return UserAgentApplication;\n}();\n\nexport { UserAgentApplication };","map":{"version":3,"sources":["../src/UserAgentApplication.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\nimport { AccessTokenKey } from \"./cache/AccessTokenKey\";\r\nimport { AccessTokenValue } from \"./cache/AccessTokenValue\";\r\nimport { ServerRequestParameters } from \"./ServerRequestParameters\";\r\nimport { AuthorityType } from \"./authority/Authority\";\r\nimport { ClientInfo } from \"./ClientInfo\";\r\nimport { IdToken } from \"./IdToken\";\r\nimport { AuthCache } from \"./cache/AuthCache\";\r\nimport { Account } from \"./Account\";\r\nimport { ScopeSet } from \"./ScopeSet\";\r\nimport { StringUtils } from \"./utils/StringUtils\";\r\nimport { WindowUtils } from \"./utils/WindowUtils\";\r\nimport { TokenUtils } from \"./utils/TokenUtils\";\r\nimport { TimeUtils } from \"./utils/TimeUtils\";\r\nimport { UrlUtils } from \"./utils/UrlUtils\";\r\nimport { RequestUtils } from \"./utils/RequestUtils\";\r\nimport { ResponseUtils } from \"./utils/ResponseUtils\";\r\nimport { AuthorityFactory } from \"./authority/AuthorityFactory\";\r\nimport { buildConfiguration } from \"./Configuration\";\r\nimport { ClientConfigurationError } from \"./error/ClientConfigurationError\";\r\nimport { AuthError } from \"./error/AuthError\";\r\nimport { ClientAuthError, ClientAuthErrorMessage } from \"./error/ClientAuthError\";\r\nimport { ServerError } from \"./error/ServerError\";\r\nimport { InteractionRequiredAuthError } from \"./error/InteractionRequiredAuthError\";\r\nimport { buildResponseStateOnly } from \"./AuthResponse\";\r\nimport TelemetryManager from \"./telemetry/TelemetryManager\";\r\nimport { API_EVENT_IDENTIFIER } from \"./telemetry/ApiEvent\";\r\nimport { Constants, ServerHashParamKeys, ResponseTypes, TemporaryCacheKeys, PersistentCacheKeys, ErrorCacheKeys, FramePrefix } from \"./utils/Constants\";\r\nimport { CryptoUtils } from \"./utils/CryptoUtils\";\r\nimport { TrustedAuthority } from \"./authority/TrustedAuthority\";\r\nimport { AuthCacheUtils } from \"./utils/AuthCacheUtils\";\r\n// default authority\r\nvar DEFAULT_AUTHORITY = \"https://login.microsoftonline.com/common\";\r\n/**\r\n * UserAgentApplication class\r\n *\r\n * Object Instance that the developer can use to make loginXX OR acquireTokenXX functions\r\n */\r\nvar UserAgentApplication = /** @class */ (function () {\r\n    /**\r\n     * @constructor\r\n     * Constructor for the UserAgentApplication used to instantiate the UserAgentApplication object\r\n     *\r\n     * Important attributes in the Configuration object for auth are:\r\n     * - clientID: the application ID of your application.\r\n     * You can obtain one by registering your application with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview\r\n     * - authority: the authority URL for your application.\r\n     *\r\n     * In Azure AD, authority is a URL indicating the Azure active directory that MSAL uses to obtain tokens.\r\n     * It is of the form https://login.microsoftonline.com/&lt;Enter_the_Tenant_Info_Here&gt;.\r\n     * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\r\n     * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\r\n     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\r\n     * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\r\n     *\r\n     *\r\n     * In Azure B2C, authority is of the form https://&lt;instance&gt;/tfp/&lt;tenant&gt;/&lt;policyName&gt;/\r\n     *\r\n     * @param {@link (Configuration:type)} configuration object for the MSAL UserAgentApplication instance\r\n     */\r\n    function UserAgentApplication(configuration) {\r\n        // callbacks for token/error\r\n        this.authResponseCallback = null;\r\n        this.tokenReceivedCallback = null;\r\n        this.errorReceivedCallback = null;\r\n        // Set the Configuration\r\n        this.config = buildConfiguration(configuration);\r\n        this.logger = this.config.system.logger;\r\n        this.clientId = this.config.auth.clientId;\r\n        this.inCookie = this.config.cache.storeAuthStateInCookie;\r\n        this.telemetryManager = this.getTelemetryManagerFromConfig(this.config.system.telemetry, this.clientId);\r\n        TrustedAuthority.setTrustedAuthoritiesFromConfig(this.config.auth.validateAuthority, this.config.auth.knownAuthorities);\r\n        AuthorityFactory.saveMetadataFromConfig(this.config.auth.authority, this.config.auth.authorityMetadata);\r\n        // if no authority is passed, set the default: \"https://login.microsoftonline.com/common\"\r\n        this.authority = this.config.auth.authority || DEFAULT_AUTHORITY;\r\n        // cache keys msal - typescript throws an error if any value other than \"localStorage\" or \"sessionStorage\" is passed\r\n        this.cacheStorage = new AuthCache(this.clientId, this.config.cache.cacheLocation, this.inCookie);\r\n        // Initialize window handling code\r\n        window.activeRenewals = {};\r\n        window.renewStates = [];\r\n        window.callbackMappedToRenewStates = {};\r\n        window.promiseMappedToRenewStates = {};\r\n        window.msal = this;\r\n        var urlHash = window.location.hash;\r\n        var urlContainsHash = UrlUtils.urlContainsHash(urlHash);\r\n        // check if back button is pressed\r\n        WindowUtils.checkIfBackButtonIsPressed(this.cacheStorage);\r\n        // On the server 302 - Redirect, handle this\r\n        if (urlContainsHash) {\r\n            var stateInfo = this.getResponseState(urlHash);\r\n            if (stateInfo.method === Constants.interactionTypeRedirect) {\r\n                this.handleRedirectAuthenticationResponse(urlHash);\r\n            }\r\n        }\r\n    }\r\n    Object.defineProperty(UserAgentApplication.prototype, \"authority\", {\r\n        /**\r\n         * Method to manage the authority URL.\r\n         *\r\n         * @returns {string} authority\r\n         */\r\n        get: function () {\r\n            return this.authorityInstance.CanonicalAuthority;\r\n        },\r\n        /**\r\n         * setter for the authority URL\r\n         * @param {string} authority\r\n         */\r\n        // If the developer passes an authority, create an instance\r\n        set: function (val) {\r\n            this.authorityInstance = AuthorityFactory.CreateInstance(val, this.config.auth.validateAuthority);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Get the current authority instance from the MSAL configuration object\r\n     *\r\n     * @returns {@link Authority} authority instance\r\n     */\r\n    UserAgentApplication.prototype.getAuthorityInstance = function () {\r\n        return this.authorityInstance;\r\n    };\r\n    UserAgentApplication.prototype.handleRedirectCallback = function (authOrTokenCallback, errorReceivedCallback) {\r\n        if (!authOrTokenCallback) {\r\n            throw ClientConfigurationError.createInvalidCallbackObjectError(authOrTokenCallback);\r\n        }\r\n        // Set callbacks\r\n        if (errorReceivedCallback) {\r\n            this.tokenReceivedCallback = authOrTokenCallback;\r\n            this.errorReceivedCallback = errorReceivedCallback;\r\n            this.logger.warning(\"This overload for callback is deprecated - please change the format of the callbacks to a single callback as shown: (err: AuthError, response: AuthResponse).\");\r\n        }\r\n        else {\r\n            this.authResponseCallback = authOrTokenCallback;\r\n        }\r\n        if (this.redirectError) {\r\n            this.authErrorHandler(Constants.interactionTypeRedirect, this.redirectError, this.redirectResponse);\r\n        }\r\n        else if (this.redirectResponse) {\r\n            this.authResponseHandler(Constants.interactionTypeRedirect, this.redirectResponse);\r\n        }\r\n    };\r\n    /**\r\n     * Public API to verify if the URL contains the hash with known properties\r\n     * @param hash\r\n     */\r\n    UserAgentApplication.prototype.urlContainsHash = function (hash) {\r\n        this.logger.verbose(\"UrlContainsHash has been called\");\r\n        return UrlUtils.urlContainsHash(hash);\r\n    };\r\n    UserAgentApplication.prototype.authResponseHandler = function (interactionType, response, resolve) {\r\n        this.logger.verbose(\"AuthResponseHandler has been called\");\r\n        if (interactionType === Constants.interactionTypeRedirect) {\r\n            this.logger.verbose(\"Interaction type is redirect\");\r\n            if (this.errorReceivedCallback) {\r\n                this.logger.verbose(\"Two callbacks were provided to handleRedirectCallback, calling success callback with response\");\r\n                this.tokenReceivedCallback(response);\r\n            }\r\n            else if (this.authResponseCallback) {\r\n                this.logger.verbose(\"One callback was provided to handleRedirectCallback, calling authResponseCallback with response\");\r\n                this.authResponseCallback(null, response);\r\n            }\r\n        }\r\n        else if (interactionType === Constants.interactionTypePopup) {\r\n            this.logger.verbose(\"Interaction type is popup, resolving\");\r\n            resolve(response);\r\n        }\r\n        else {\r\n            throw ClientAuthError.createInvalidInteractionTypeError();\r\n        }\r\n    };\r\n    UserAgentApplication.prototype.authErrorHandler = function (interactionType, authErr, response, reject) {\r\n        this.logger.verbose(\"AuthErrorHandler has been called\");\r\n        // set interaction_status to complete\r\n        this.cacheStorage.removeItem(TemporaryCacheKeys.INTERACTION_STATUS);\r\n        if (interactionType === Constants.interactionTypeRedirect) {\r\n            this.logger.verbose(\"Interaction type is redirect\");\r\n            if (this.errorReceivedCallback) {\r\n                this.logger.verbose(\"Two callbacks were provided to handleRedirectCallback, calling error callback\");\r\n                this.errorReceivedCallback(authErr, response.accountState);\r\n            }\r\n            else if (this.authResponseCallback) {\r\n                this.logger.verbose(\"One callback was provided to handleRedirectCallback, calling authResponseCallback with error\");\r\n                this.authResponseCallback(authErr, response);\r\n            }\r\n            else {\r\n                this.logger.verbose(\"handleRedirectCallback has not been called and no callbacks are registered, throwing error\");\r\n                throw authErr;\r\n            }\r\n        }\r\n        else if (interactionType === Constants.interactionTypePopup) {\r\n            this.logger.verbose(\"Interaction type is popup, rejecting\");\r\n            reject(authErr);\r\n        }\r\n        else {\r\n            throw ClientAuthError.createInvalidInteractionTypeError();\r\n        }\r\n    };\r\n    // #endregion\r\n    /**\r\n     * Use when initiating the login process by redirecting the user's browser to the authorization endpoint.\r\n     * @param {@link (AuthenticationParameters:type)}\r\n     */\r\n    UserAgentApplication.prototype.loginRedirect = function (userRequest) {\r\n        this.logger.verbose(\"LoginRedirect has been called\");\r\n        // validate request\r\n        var request = RequestUtils.validateRequest(userRequest, true, this.clientId, Constants.interactionTypeRedirect);\r\n        this.acquireTokenInteractive(Constants.interactionTypeRedirect, true, request, null, null);\r\n    };\r\n    /**\r\n     * Use when you want to obtain an access_token for your API by redirecting the user's browser window to the authorization endpoint.\r\n     * @param {@link (AuthenticationParameters:type)}\r\n     *\r\n     * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\r\n     */\r\n    UserAgentApplication.prototype.acquireTokenRedirect = function (userRequest) {\r\n        this.logger.verbose(\"AcquireTokenRedirect has been called\");\r\n        // validate request\r\n        var request = RequestUtils.validateRequest(userRequest, false, this.clientId, Constants.interactionTypeRedirect);\r\n        this.acquireTokenInteractive(Constants.interactionTypeRedirect, false, request, null, null);\r\n    };\r\n    /**\r\n     * Use when initiating the login process via opening a popup window in the user's browser\r\n     *\r\n     * @param {@link (AuthenticationParameters:type)}\r\n     *\r\n     * @returns {Promise.<AuthResponse>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse} object\r\n     */\r\n    UserAgentApplication.prototype.loginPopup = function (userRequest) {\r\n        var _this = this;\r\n        this.logger.verbose(\"LoginPopup has been called\");\r\n        // validate request\r\n        var request = RequestUtils.validateRequest(userRequest, true, this.clientId, Constants.interactionTypePopup);\r\n        var apiEvent = this.telemetryManager.createAndStartApiEvent(request.correlationId, API_EVENT_IDENTIFIER.LoginPopup);\r\n        return new Promise(function (resolve, reject) {\r\n            _this.acquireTokenInteractive(Constants.interactionTypePopup, true, request, resolve, reject);\r\n        })\r\n            .then(function (resp) {\r\n            _this.logger.verbose(\"Successfully logged in\");\r\n            _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, true);\r\n            return resp;\r\n        })\r\n            .catch(function (error) {\r\n            _this.cacheStorage.resetTempCacheItems(request.state);\r\n            _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, false, error.errorCode);\r\n            throw error;\r\n        });\r\n    };\r\n    /**\r\n     * Use when you want to obtain an access_token for your API via opening a popup window in the user's browser\r\n     * @param {@link AuthenticationParameters}\r\n     *\r\n     * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\r\n     * @returns {Promise.<AuthResponse>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse} object\r\n     */\r\n    UserAgentApplication.prototype.acquireTokenPopup = function (userRequest) {\r\n        var _this = this;\r\n        this.logger.verbose(\"AcquireTokenPopup has been called\");\r\n        // validate request\r\n        var request = RequestUtils.validateRequest(userRequest, false, this.clientId, Constants.interactionTypePopup);\r\n        var apiEvent = this.telemetryManager.createAndStartApiEvent(request.correlationId, API_EVENT_IDENTIFIER.AcquireTokenPopup);\r\n        return new Promise(function (resolve, reject) {\r\n            _this.acquireTokenInteractive(Constants.interactionTypePopup, false, request, resolve, reject);\r\n        })\r\n            .then(function (resp) {\r\n            _this.logger.verbose(\"Successfully acquired token\");\r\n            _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, true);\r\n            return resp;\r\n        })\r\n            .catch(function (error) {\r\n            _this.cacheStorage.resetTempCacheItems(request.state);\r\n            _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, false, error.errorCode);\r\n            throw error;\r\n        });\r\n    };\r\n    // #region Acquire Token\r\n    /**\r\n     * Use when initiating the login process or when you want to obtain an access_token for your API,\r\n     * either by redirecting the user's browser window to the authorization endpoint or via opening a popup window in the user's browser.\r\n     * @param {@link (AuthenticationParameters:type)}\r\n     *\r\n     * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\r\n     */\r\n    UserAgentApplication.prototype.acquireTokenInteractive = function (interactionType, isLoginCall, request, resolve, reject) {\r\n        var _this = this;\r\n        this.logger.verbose(\"AcquireTokenInteractive has been called\");\r\n        // block the request if made from the hidden iframe\r\n        WindowUtils.blockReloadInHiddenIframes();\r\n        var interactionProgress = this.cacheStorage.getItem(TemporaryCacheKeys.INTERACTION_STATUS);\r\n        if (interactionType === Constants.interactionTypeRedirect) {\r\n            this.cacheStorage.setItem(TemporaryCacheKeys.REDIRECT_REQUEST, \"\" + Constants.inProgress + Constants.resourceDelimiter + request.state);\r\n        }\r\n        // If already in progress, do not proceed\r\n        if (interactionProgress === Constants.inProgress) {\r\n            var thrownError = isLoginCall ? ClientAuthError.createLoginInProgressError() : ClientAuthError.createAcquireTokenInProgressError();\r\n            var stateOnlyResponse = buildResponseStateOnly(this.getAccountState(request.state));\r\n            this.cacheStorage.resetTempCacheItems(request.state);\r\n            this.authErrorHandler(interactionType, thrownError, stateOnlyResponse, reject);\r\n            return;\r\n        }\r\n        // Get the account object if a session exists\r\n        var account;\r\n        if (request && request.account && !isLoginCall) {\r\n            account = request.account;\r\n            this.logger.verbose(\"Account set from request\");\r\n        }\r\n        else {\r\n            account = this.getAccount();\r\n            this.logger.verbose(\"Account set from MSAL Cache\");\r\n        }\r\n        // If no session exists, prompt the user to login.\r\n        if (!account && !ServerRequestParameters.isSSOParam(request)) {\r\n            if (isLoginCall) {\r\n                // extract ADAL id_token if exists\r\n                var adalIdToken = this.extractADALIdToken();\r\n                // silent login if ADAL id_token is retrieved successfully - SSO\r\n                if (adalIdToken && !request.scopes) {\r\n                    this.logger.info(\"ADAL's idToken exists. Extracting login information from ADAL's idToken\");\r\n                    var tokenRequest = this.buildIDTokenRequest(request);\r\n                    this.silentLogin = true;\r\n                    this.acquireTokenSilent(tokenRequest).then(function (response) {\r\n                        _this.silentLogin = false;\r\n                        _this.logger.info(\"Unified cache call is successful\");\r\n                        _this.authResponseHandler(interactionType, response, resolve);\r\n                        return;\r\n                    }, function (error) {\r\n                        _this.silentLogin = false;\r\n                        _this.logger.error(\"Error occurred during unified cache ATS: \" + error);\r\n                        // proceed to login since ATS failed\r\n                        _this.acquireTokenHelper(null, interactionType, isLoginCall, request, resolve, reject);\r\n                    });\r\n                }\r\n                // No ADAL token found, proceed to login\r\n                else {\r\n                    this.logger.verbose(\"Login call but no token found, proceed to login\");\r\n                    this.acquireTokenHelper(null, interactionType, isLoginCall, request, resolve, reject);\r\n                }\r\n            }\r\n            // AcquireToken call, but no account or context given, so throw error\r\n            else {\r\n                this.logger.verbose(\"AcquireToken call, no context or account given\");\r\n                this.logger.info(\"User login is required\");\r\n                var stateOnlyResponse = buildResponseStateOnly(this.getAccountState(request.state));\r\n                this.cacheStorage.resetTempCacheItems(request.state);\r\n                this.authErrorHandler(interactionType, ClientAuthError.createUserLoginRequiredError(), stateOnlyResponse, reject);\r\n                return;\r\n            }\r\n        }\r\n        // User session exists\r\n        else {\r\n            this.logger.verbose(\"User session exists, login not required\");\r\n            this.acquireTokenHelper(account, interactionType, isLoginCall, request, resolve, reject);\r\n        }\r\n    };\r\n    /**\r\n     * @hidden\r\n     * @ignore\r\n     * Helper function to acquireToken\r\n     *\r\n     */\r\n    UserAgentApplication.prototype.acquireTokenHelper = function (account, interactionType, isLoginCall, request, resolve, reject) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var requestSignature, serverAuthenticationRequest, acquireTokenAuthority, popUpWindow, responseType, loginStartPage, urlNavigate, hash, error_1, navigate, err_1;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        this.logger.verbose(\"AcquireTokenHelper has been called\");\r\n                        this.logger.verbose(\"Interaction type: \" + interactionType + \". isLoginCall: \" + isLoginCall);\r\n                        // Track the acquireToken progress\r\n                        this.cacheStorage.setItem(TemporaryCacheKeys.INTERACTION_STATUS, Constants.inProgress);\r\n                        requestSignature = request.scopes ? request.scopes.join(\" \").toLowerCase() : Constants.oidcScopes.join(\" \");\r\n                        this.logger.verbosePii(\"Request signature: \" + requestSignature);\r\n                        acquireTokenAuthority = (request && request.authority) ? AuthorityFactory.CreateInstance(request.authority, this.config.auth.validateAuthority, request.authorityMetadata) : this.authorityInstance;\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 11, , 12]);\r\n                        if (!!acquireTokenAuthority.hasCachedMetadata()) return [3 /*break*/, 3];\r\n                        this.logger.verbose(\"No cached metadata for authority\");\r\n                        return [4 /*yield*/, AuthorityFactory.saveMetadataFromNetwork(acquireTokenAuthority, this.telemetryManager, request.correlationId)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        this.logger.verbose(\"Cached metadata found for authority\");\r\n                        _a.label = 4;\r\n                    case 4:\r\n                        responseType = isLoginCall ? ResponseTypes.id_token : this.getTokenType(account, request.scopes);\r\n                        loginStartPage = request.redirectStartPage || window.location.href;\r\n                        serverAuthenticationRequest = new ServerRequestParameters(acquireTokenAuthority, this.clientId, responseType, this.getRedirectUri(request && request.redirectUri), request.scopes, request.state, request.correlationId);\r\n                        this.logger.verbose(\"Finished building server authentication request\");\r\n                        this.updateCacheEntries(serverAuthenticationRequest, account, isLoginCall, loginStartPage);\r\n                        this.logger.verbose(\"Updating cache entries\");\r\n                        // populate QueryParameters (sid/login_hint) and any other extraQueryParameters set by the developer\r\n                        serverAuthenticationRequest.populateQueryParams(account, request);\r\n                        this.logger.verbose(\"Query parameters populated from account\");\r\n                        urlNavigate = UrlUtils.createNavigateUrl(serverAuthenticationRequest) + Constants.response_mode_fragment;\r\n                        // set state in cache\r\n                        if (interactionType === Constants.interactionTypeRedirect) {\r\n                            if (!isLoginCall) {\r\n                                this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_ACQ_TOKEN, request.state), serverAuthenticationRequest.state, this.inCookie);\r\n                                this.logger.verbose(\"State cached for redirect\");\r\n                                this.logger.verbosePii(\"State cached: \" + serverAuthenticationRequest.state);\r\n                            }\r\n                            else {\r\n                                this.logger.verbose(\"Interaction type redirect but login call is true. State not cached\");\r\n                            }\r\n                        }\r\n                        else if (interactionType === Constants.interactionTypePopup) {\r\n                            window.renewStates.push(serverAuthenticationRequest.state);\r\n                            window.requestType = isLoginCall ? Constants.login : Constants.renewToken;\r\n                            this.logger.verbose(\"State saved to window\");\r\n                            this.logger.verbosePii(\"State saved: \" + serverAuthenticationRequest.state);\r\n                            // Register callback to capture results from server\r\n                            this.registerCallback(serverAuthenticationRequest.state, requestSignature, resolve, reject);\r\n                        }\r\n                        else {\r\n                            this.logger.verbose(\"Invalid interaction error. State not cached\");\r\n                            throw ClientAuthError.createInvalidInteractionTypeError();\r\n                        }\r\n                        if (!(interactionType === Constants.interactionTypePopup)) return [3 /*break*/, 9];\r\n                        this.logger.verbose(\"Interaction type is popup. Generating popup window\");\r\n                        // Generate a popup window\r\n                        try {\r\n                            popUpWindow = this.openPopup(urlNavigate, \"msal\", Constants.popUpWidth, Constants.popUpHeight);\r\n                            // Push popup window handle onto stack for tracking\r\n                            WindowUtils.trackPopup(popUpWindow);\r\n                        }\r\n                        catch (e) {\r\n                            this.logger.info(ClientAuthErrorMessage.popUpWindowError.code + \":\" + ClientAuthErrorMessage.popUpWindowError.desc);\r\n                            this.cacheStorage.setItem(ErrorCacheKeys.ERROR, ClientAuthErrorMessage.popUpWindowError.code);\r\n                            this.cacheStorage.setItem(ErrorCacheKeys.ERROR_DESC, ClientAuthErrorMessage.popUpWindowError.desc);\r\n                            if (reject) {\r\n                                reject(ClientAuthError.createPopupWindowError());\r\n                                return [2 /*return*/];\r\n                            }\r\n                        }\r\n                        if (!popUpWindow) return [3 /*break*/, 8];\r\n                        _a.label = 5;\r\n                    case 5:\r\n                        _a.trys.push([5, 7, , 8]);\r\n                        return [4 /*yield*/, WindowUtils.monitorPopupForHash(popUpWindow, this.config.system.loadFrameTimeout, urlNavigate, this.logger)];\r\n                    case 6:\r\n                        hash = _a.sent();\r\n                        this.handleAuthenticationResponse(hash);\r\n                        // Request completed successfully, set to completed\r\n                        this.cacheStorage.removeItem(TemporaryCacheKeys.INTERACTION_STATUS);\r\n                        this.logger.info(\"Closing popup window\");\r\n                        // TODO: Check how this can be extracted for any framework specific code?\r\n                        if (this.config.framework.isAngular) {\r\n                            this.broadcast(\"msal:popUpHashChanged\", hash);\r\n                        }\r\n                        WindowUtils.closePopups();\r\n                        return [3 /*break*/, 8];\r\n                    case 7:\r\n                        error_1 = _a.sent();\r\n                        if (reject) {\r\n                            reject(error_1);\r\n                        }\r\n                        if (this.config.framework.isAngular) {\r\n                            this.broadcast(\"msal:popUpClosed\", error_1.errorCode + Constants.resourceDelimiter + error_1.errorMessage);\r\n                        }\r\n                        else {\r\n                            // Request failed, set to canceled\r\n                            this.cacheStorage.removeItem(TemporaryCacheKeys.INTERACTION_STATUS);\r\n                            popUpWindow.close();\r\n                        }\r\n                        return [3 /*break*/, 8];\r\n                    case 8: return [3 /*break*/, 10];\r\n                    case 9:\r\n                        // If onRedirectNavigate is implemented, invoke it and provide urlNavigate\r\n                        if (request.onRedirectNavigate) {\r\n                            this.logger.verbose(\"Invoking onRedirectNavigate callback\");\r\n                            navigate = request.onRedirectNavigate(urlNavigate);\r\n                            // Returning false from onRedirectNavigate will stop navigation\r\n                            if (navigate !== false) {\r\n                                this.logger.verbose(\"onRedirectNavigate did not return false, navigating\");\r\n                                this.navigateWindow(urlNavigate);\r\n                            }\r\n                            else {\r\n                                this.logger.verbose(\"onRedirectNavigate returned false, stopping navigation\");\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Otherwise, perform navigation\r\n                            this.logger.verbose(\"Navigating window to urlNavigate\");\r\n                            this.navigateWindow(urlNavigate);\r\n                        }\r\n                        _a.label = 10;\r\n                    case 10: return [3 /*break*/, 12];\r\n                    case 11:\r\n                        err_1 = _a.sent();\r\n                        this.logger.error(err_1);\r\n                        this.cacheStorage.resetTempCacheItems(request.state);\r\n                        this.authErrorHandler(interactionType, ClientAuthError.createEndpointResolutionError(err_1.toString), buildResponseStateOnly(request.state), reject);\r\n                        if (popUpWindow) {\r\n                            popUpWindow.close();\r\n                        }\r\n                        return [3 /*break*/, 12];\r\n                    case 12: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * API interfacing idToken request when applications already have a session/hint acquired by authorization client applications\r\n     * @param request\r\n     */\r\n    UserAgentApplication.prototype.ssoSilent = function (request) {\r\n        this.logger.verbose(\"ssoSilent has been called\");\r\n        // throw an error on an empty request\r\n        if (!request) {\r\n            throw ClientConfigurationError.createEmptyRequestError();\r\n        }\r\n        // throw an error on no hints passed\r\n        if (!request.sid && !request.loginHint) {\r\n            throw ClientConfigurationError.createSsoSilentError();\r\n        }\r\n        return this.acquireTokenSilent(tslib_1.__assign({}, request, { scopes: Constants.oidcScopes }));\r\n    };\r\n    /**\r\n     * Use this function to obtain a token before every call to the API / resource provider\r\n     *\r\n     * MSAL return's a cached token when available\r\n     * Or it send's a request to the STS to obtain a new token using a hidden iframe.\r\n     *\r\n     * @param {@link AuthenticationParameters}\r\n     *\r\n     * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\r\n     * @returns {Promise.<AuthResponse>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse} object\r\n     *\r\n     */\r\n    UserAgentApplication.prototype.acquireTokenSilent = function (userRequest) {\r\n        var _this = this;\r\n        this.logger.verbose(\"AcquireTokenSilent has been called\");\r\n        // validate the request\r\n        var request = RequestUtils.validateRequest(userRequest, false, this.clientId, Constants.interactionTypeSilent);\r\n        var apiEvent = this.telemetryManager.createAndStartApiEvent(request.correlationId, API_EVENT_IDENTIFIER.AcquireTokenSilent);\r\n        var requestSignature = RequestUtils.createRequestSignature(request);\r\n        return new Promise(function (resolve, reject) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\r\n            var scope, account, adalIdToken, responseType, serverAuthenticationRequest, adalIdTokenObject, userContainedClaims, authErr, cacheResultResponse, logMessage, err_2;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        // block the request if made from the hidden iframe\r\n                        WindowUtils.blockReloadInHiddenIframes();\r\n                        scope = request.scopes.join(\" \").toLowerCase();\r\n                        this.logger.verbosePii(\"Serialized scopes: \" + scope);\r\n                        if (request.account) {\r\n                            account = request.account;\r\n                            this.logger.verbose(\"Account set from request\");\r\n                        }\r\n                        else {\r\n                            account = this.getAccount();\r\n                            this.logger.verbose(\"Account set from MSAL Cache\");\r\n                        }\r\n                        adalIdToken = this.cacheStorage.getItem(Constants.adalIdToken);\r\n                        // In the event of no account being passed in the config, no session id, and no pre-existing adalIdToken, user will need to log in\r\n                        if (!account && !(request.sid || request.loginHint) && StringUtils.isEmpty(adalIdToken)) {\r\n                            this.logger.info(\"User login is required\");\r\n                            // The promise rejects with a UserLoginRequiredError, which should be caught and user should be prompted to log in interactively\r\n                            return [2 /*return*/, reject(ClientAuthError.createUserLoginRequiredError())];\r\n                        }\r\n                        responseType = this.getTokenType(account, request.scopes);\r\n                        this.logger.verbose(\"Response type: \" + responseType);\r\n                        serverAuthenticationRequest = new ServerRequestParameters(AuthorityFactory.CreateInstance(request.authority, this.config.auth.validateAuthority, request.authorityMetadata), this.clientId, responseType, this.getRedirectUri(request.redirectUri), request.scopes, request.state, request.correlationId);\r\n                        this.logger.verbose(\"Finished building server authentication request\");\r\n                        // populate QueryParameters (sid/login_hint) and any other extraQueryParameters set by the developer\r\n                        if (ServerRequestParameters.isSSOParam(request) || account) {\r\n                            serverAuthenticationRequest.populateQueryParams(account, request, null, true);\r\n                            this.logger.verbose(\"Query parameters populated from existing SSO or account\");\r\n                        }\r\n                        // if user didn't pass login_hint/sid and adal's idtoken is present, extract the login_hint from the adalIdToken\r\n                        else if (!account && !StringUtils.isEmpty(adalIdToken)) {\r\n                            adalIdTokenObject = TokenUtils.extractIdToken(adalIdToken);\r\n                            this.logger.verbose(\"ADAL's idToken exists. Extracting login information from ADAL's idToken to populate query parameters\");\r\n                            serverAuthenticationRequest.populateQueryParams(account, null, adalIdTokenObject, true);\r\n                        }\r\n                        else {\r\n                            this.logger.verbose(\"No additional query parameters added\");\r\n                        }\r\n                        userContainedClaims = request.claimsRequest || serverAuthenticationRequest.claimsValue;\r\n                        // If request.forceRefresh is set to true, force a request for a new token instead of getting it from the cache\r\n                        if (!userContainedClaims && !request.forceRefresh) {\r\n                            try {\r\n                                cacheResultResponse = this.getCachedToken(serverAuthenticationRequest, account);\r\n                            }\r\n                            catch (e) {\r\n                                authErr = e;\r\n                            }\r\n                        }\r\n                        if (!cacheResultResponse) return [3 /*break*/, 1];\r\n                        this.logger.verbose(\"Token found in cache lookup\");\r\n                        this.logger.verbosePii(\"Scopes found: \" + JSON.stringify(cacheResultResponse.scopes));\r\n                        resolve(cacheResultResponse);\r\n                        return [2 /*return*/, null];\r\n                    case 1:\r\n                        if (!authErr) return [3 /*break*/, 2];\r\n                        this.logger.infoPii(authErr.errorCode + \":\" + authErr.errorMessage);\r\n                        reject(authErr);\r\n                        return [2 /*return*/, null];\r\n                    case 2:\r\n                        logMessage = void 0;\r\n                        if (userContainedClaims) {\r\n                            logMessage = \"Skipped cache lookup since claims were given\";\r\n                        }\r\n                        else if (request.forceRefresh) {\r\n                            logMessage = \"Skipped cache lookup since request.forceRefresh option was set to true\";\r\n                        }\r\n                        else {\r\n                            logMessage = \"No valid token found in cache lookup\";\r\n                        }\r\n                        this.logger.verbose(logMessage);\r\n                        // Cache result can return null if cache is empty. In that case, set authority to default value if no authority is passed to the API.\r\n                        if (!serverAuthenticationRequest.authorityInstance) {\r\n                            serverAuthenticationRequest.authorityInstance = request.authority ?\r\n                                AuthorityFactory.CreateInstance(request.authority, this.config.auth.validateAuthority, request.authorityMetadata)\r\n                                : this.authorityInstance;\r\n                        }\r\n                        this.logger.verbosePii(\"Authority instance: \" + serverAuthenticationRequest.authority);\r\n                        _a.label = 3;\r\n                    case 3:\r\n                        _a.trys.push([3, 7, , 8]);\r\n                        if (!!serverAuthenticationRequest.authorityInstance.hasCachedMetadata()) return [3 /*break*/, 5];\r\n                        this.logger.verbose(\"No cached metadata for authority\");\r\n                        return [4 /*yield*/, AuthorityFactory.saveMetadataFromNetwork(serverAuthenticationRequest.authorityInstance, this.telemetryManager, request.correlationId)];\r\n                    case 4:\r\n                        _a.sent();\r\n                        this.logger.verbose(\"Authority has been updated with endpoint discovery response\");\r\n                        return [3 /*break*/, 6];\r\n                    case 5:\r\n                        this.logger.verbose(\"Cached metadata found for authority\");\r\n                        _a.label = 6;\r\n                    case 6:\r\n                        /*\r\n                         * refresh attempt with iframe\r\n                         * Already renewing for this scope, callback when we get the token.\r\n                         */\r\n                        if (window.activeRenewals[requestSignature]) {\r\n                            this.logger.verbose(\"Renewing token in progress. Registering callback\");\r\n                            // Active renewals contains the state for each renewal.\r\n                            this.registerCallback(window.activeRenewals[requestSignature], requestSignature, resolve, reject);\r\n                        }\r\n                        else {\r\n                            if (request.scopes && ScopeSet.onlyContainsOidcScopes(request.scopes)) {\r\n                                /*\r\n                                 * App uses idToken to send to api endpoints\r\n                                 * Default scope is tracked as OIDC scopes to store this token\r\n                                 */\r\n                                this.logger.verbose(\"OpenID Connect scopes only, renewing idToken\");\r\n                                this.silentLogin = true;\r\n                                this.renewIdToken(requestSignature, resolve, reject, account, serverAuthenticationRequest);\r\n                            }\r\n                            else {\r\n                                // renew access token\r\n                                this.logger.verbose(\"Renewing access token\");\r\n                                this.renewToken(requestSignature, resolve, reject, account, serverAuthenticationRequest);\r\n                            }\r\n                        }\r\n                        return [3 /*break*/, 8];\r\n                    case 7:\r\n                        err_2 = _a.sent();\r\n                        this.logger.error(err_2);\r\n                        reject(ClientAuthError.createEndpointResolutionError(err_2.toString()));\r\n                        return [2 /*return*/, null];\r\n                    case 8: return [2 /*return*/];\r\n                }\r\n            });\r\n        }); })\r\n            .then(function (res) {\r\n            _this.logger.verbose(\"Successfully acquired token\");\r\n            _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, true);\r\n            return res;\r\n        })\r\n            .catch(function (error) {\r\n            _this.cacheStorage.resetTempCacheItems(request.state);\r\n            _this.telemetryManager.stopAndFlushApiEvent(request.correlationId, apiEvent, false, error.errorCode);\r\n            throw error;\r\n        });\r\n    };\r\n    // #endregion\r\n    // #region Popup Window Creation\r\n    /**\r\n     * @hidden\r\n     *\r\n     * Configures popup window for login.\r\n     *\r\n     * @param urlNavigate\r\n     * @param title\r\n     * @param popUpWidth\r\n     * @param popUpHeight\r\n     * @ignore\r\n     * @hidden\r\n     */\r\n    UserAgentApplication.prototype.openPopup = function (urlNavigate, title, popUpWidth, popUpHeight) {\r\n        this.logger.verbose(\"OpenPopup has been called\");\r\n        try {\r\n            /**\r\n             * adding winLeft and winTop to account for dual monitor\r\n             * using screenLeft and screenTop for IE8 and earlier\r\n             */\r\n            var winLeft = window.screenLeft ? window.screenLeft : window.screenX;\r\n            var winTop = window.screenTop ? window.screenTop : window.screenY;\r\n            /**\r\n             * window.innerWidth displays browser window\"s height and width excluding toolbars\r\n             * using document.documentElement.clientWidth for IE8 and earlier\r\n             */\r\n            var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\r\n            var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\r\n            var left = ((width / 2) - (popUpWidth / 2)) + winLeft;\r\n            var top_1 = ((height / 2) - (popUpHeight / 2)) + winTop;\r\n            // open the window\r\n            var popupWindow = window.open(urlNavigate, title, \"width=\" + popUpWidth + \", height=\" + popUpHeight + \", top=\" + top_1 + \", left=\" + left + \", scrollbars=yes\");\r\n            if (!popupWindow) {\r\n                throw ClientAuthError.createPopupWindowError();\r\n            }\r\n            if (popupWindow.focus) {\r\n                popupWindow.focus();\r\n            }\r\n            return popupWindow;\r\n        }\r\n        catch (e) {\r\n            this.cacheStorage.removeItem(TemporaryCacheKeys.INTERACTION_STATUS);\r\n            throw ClientAuthError.createPopupWindowError(e.toString());\r\n        }\r\n    };\r\n    // #endregion\r\n    // #region Iframe Management\r\n    /**\r\n     * @hidden\r\n     * Calling _loadFrame but with a timeout to signal failure in loadframeStatus. Callbacks are left.\r\n     * registered when network errors occur and subsequent token requests for same resource are registered to the pending request.\r\n     * @ignore\r\n     */\r\n    UserAgentApplication.prototype.loadIframeTimeout = function (urlNavigate, frameName, requestSignature) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var expectedState, iframe, _a, hash, error_2;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        expectedState = window.activeRenewals[requestSignature];\r\n                        this.logger.verbosePii(\"Set loading state to pending for: \" + requestSignature + \":\" + expectedState);\r\n                        this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, expectedState), Constants.inProgress);\r\n                        if (!this.config.system.navigateFrameWait) return [3 /*break*/, 2];\r\n                        return [4 /*yield*/, WindowUtils.loadFrame(urlNavigate, frameName, this.config.system.navigateFrameWait, this.logger)];\r\n                    case 1:\r\n                        _a = _b.sent();\r\n                        return [3 /*break*/, 3];\r\n                    case 2:\r\n                        _a = WindowUtils.loadFrameSync(urlNavigate, frameName, this.logger);\r\n                        _b.label = 3;\r\n                    case 3:\r\n                        iframe = _a;\r\n                        _b.label = 4;\r\n                    case 4:\r\n                        _b.trys.push([4, 6, , 7]);\r\n                        return [4 /*yield*/, WindowUtils.monitorIframeForHash(iframe.contentWindow, this.config.system.loadFrameTimeout, urlNavigate, this.logger)];\r\n                    case 5:\r\n                        hash = _b.sent();\r\n                        if (hash) {\r\n                            this.handleAuthenticationResponse(hash);\r\n                        }\r\n                        return [3 /*break*/, 7];\r\n                    case 6:\r\n                        error_2 = _b.sent();\r\n                        if (this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, expectedState)) === Constants.inProgress) {\r\n                            // fail the iframe session if it's in pending state\r\n                            this.logger.verbose(\"Loading frame has timed out after: \" + (this.config.system.loadFrameTimeout / 1000) + \" seconds for scope/authority \" + requestSignature + \":\" + expectedState);\r\n                            // Error after timeout\r\n                            if (expectedState && window.callbackMappedToRenewStates[expectedState]) {\r\n                                window.callbackMappedToRenewStates[expectedState](null, error_2);\r\n                            }\r\n                            this.cacheStorage.removeItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, expectedState));\r\n                        }\r\n                        WindowUtils.removeHiddenIframe(iframe);\r\n                        throw error_2;\r\n                    case 7:\r\n                        WindowUtils.removeHiddenIframe(iframe);\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    // #endregion\r\n    // #region General Helpers\r\n    /**\r\n     * @hidden\r\n     * Used to redirect the browser to the STS authorization endpoint\r\n     * @param {string} urlNavigate - URL of the authorization endpoint\r\n     */\r\n    UserAgentApplication.prototype.navigateWindow = function (urlNavigate, popupWindow) {\r\n        // Navigate if valid URL\r\n        if (urlNavigate && !StringUtils.isEmpty(urlNavigate)) {\r\n            var navigateWindow = popupWindow ? popupWindow : window;\r\n            var logMessage = popupWindow ? \"Navigated Popup window to:\" + urlNavigate : \"Navigate to:\" + urlNavigate;\r\n            this.logger.infoPii(logMessage);\r\n            navigateWindow.location.assign(urlNavigate);\r\n        }\r\n        else {\r\n            this.logger.info(\"Navigate url is empty\");\r\n            throw AuthError.createUnexpectedError(\"Navigate url is empty\");\r\n        }\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Used to add the developer requested callback to the array of callbacks for the specified scopes. The updated array is stored on the window object\r\n     * @param {string} expectedState - Unique state identifier (guid).\r\n     * @param {string} scope - Developer requested permissions. Not all scopes are guaranteed to be included in the access token returned.\r\n     * @param {Function} resolve - The resolve function of the promise object.\r\n     * @param {Function} reject - The reject function of the promise object.\r\n     * @ignore\r\n     */\r\n    UserAgentApplication.prototype.registerCallback = function (expectedState, requestSignature, resolve, reject) {\r\n        var _this = this;\r\n        // track active renewals\r\n        window.activeRenewals[requestSignature] = expectedState;\r\n        // initialize callbacks mapped array\r\n        if (!window.promiseMappedToRenewStates[expectedState]) {\r\n            window.promiseMappedToRenewStates[expectedState] = [];\r\n        }\r\n        // indexing on the current state, push the callback params to callbacks mapped\r\n        window.promiseMappedToRenewStates[expectedState].push({ resolve: resolve, reject: reject });\r\n        // Store the server response in the current window??\r\n        if (!window.callbackMappedToRenewStates[expectedState]) {\r\n            window.callbackMappedToRenewStates[expectedState] = function (response, error) {\r\n                // reset active renewals\r\n                window.activeRenewals[requestSignature] = null;\r\n                // for all promiseMappedtoRenewStates for a given 'state' - call the reject/resolve with error/token respectively\r\n                for (var i = 0; i < window.promiseMappedToRenewStates[expectedState].length; ++i) {\r\n                    try {\r\n                        if (error) {\r\n                            window.promiseMappedToRenewStates[expectedState][i].reject(error);\r\n                        }\r\n                        else if (response) {\r\n                            window.promiseMappedToRenewStates[expectedState][i].resolve(response);\r\n                        }\r\n                        else {\r\n                            _this.cacheStorage.resetTempCacheItems(expectedState);\r\n                            throw AuthError.createUnexpectedError(\"Error and response are both null\");\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        _this.logger.warning(e);\r\n                    }\r\n                }\r\n                // reset\r\n                window.promiseMappedToRenewStates[expectedState] = null;\r\n                window.callbackMappedToRenewStates[expectedState] = null;\r\n            };\r\n        }\r\n    };\r\n    // #endregion\r\n    // #region Logout\r\n    /**\r\n     * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n     * Default behaviour is to redirect the user to `window.location.href`.\r\n     */\r\n    UserAgentApplication.prototype.logout = function (correlationId) {\r\n        this.logger.verbose(\"Logout has been called\");\r\n        this.logoutAsync(correlationId);\r\n    };\r\n    /**\r\n     * Async version of logout(). Use to log out the current user.\r\n     * @param correlationId Request correlationId\r\n     */\r\n    UserAgentApplication.prototype.logoutAsync = function (correlationId) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var requestCorrelationId, apiEvent, correlationIdParam, postLogoutQueryParam, urlNavigate, error_3;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        requestCorrelationId = correlationId || CryptoUtils.createNewGuid();\r\n                        apiEvent = this.telemetryManager.createAndStartApiEvent(requestCorrelationId, API_EVENT_IDENTIFIER.Logout);\r\n                        this.clearCache();\r\n                        this.account = null;\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 5, , 6]);\r\n                        if (!!this.authorityInstance.hasCachedMetadata()) return [3 /*break*/, 3];\r\n                        this.logger.verbose(\"No cached metadata for authority\");\r\n                        return [4 /*yield*/, AuthorityFactory.saveMetadataFromNetwork(this.authorityInstance, this.telemetryManager, correlationId)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        this.logger.verbose(\"Cached metadata found for authority\");\r\n                        _a.label = 4;\r\n                    case 4:\r\n                        correlationIdParam = \"client-request-id=\" + requestCorrelationId;\r\n                        postLogoutQueryParam = void 0;\r\n                        if (this.getPostLogoutRedirectUri()) {\r\n                            postLogoutQueryParam = \"&post_logout_redirect_uri=\" + encodeURIComponent(this.getPostLogoutRedirectUri());\r\n                            this.logger.verbose(\"redirectUri found and set\");\r\n                        }\r\n                        else {\r\n                            postLogoutQueryParam = \"\";\r\n                            this.logger.verbose(\"No redirectUri set for app. postLogoutQueryParam is empty\");\r\n                        }\r\n                        urlNavigate = void 0;\r\n                        if (this.authorityInstance.EndSessionEndpoint) {\r\n                            urlNavigate = this.authorityInstance.EndSessionEndpoint + \"?\" + correlationIdParam + postLogoutQueryParam;\r\n                            this.logger.verbose(\"EndSessionEndpoint found and urlNavigate set\");\r\n                            this.logger.verbosePii(\"urlNavigate set to: \" + this.authorityInstance.EndSessionEndpoint);\r\n                        }\r\n                        else {\r\n                            urlNavigate = this.authority + \"oauth2/v2.0/logout?\" + correlationIdParam + postLogoutQueryParam;\r\n                            this.logger.verbose(\"No endpoint, urlNavigate set to default\");\r\n                        }\r\n                        this.telemetryManager.stopAndFlushApiEvent(requestCorrelationId, apiEvent, true);\r\n                        this.logger.verbose(\"Navigating window to urlNavigate\");\r\n                        this.navigateWindow(urlNavigate);\r\n                        return [3 /*break*/, 6];\r\n                    case 5:\r\n                        error_3 = _a.sent();\r\n                        this.telemetryManager.stopAndFlushApiEvent(requestCorrelationId, apiEvent, false, error_3.errorCode);\r\n                        return [3 /*break*/, 6];\r\n                    case 6: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Clear all access tokens and ID tokens in the cache.\r\n     * @ignore\r\n     */\r\n    UserAgentApplication.prototype.clearCache = function () {\r\n        this.logger.verbose(\"Clearing cache\");\r\n        window.renewStates = [];\r\n        var tokenCacheItems = this.cacheStorage.getAllTokens(Constants.clientId, Constants.homeAccountIdentifier);\r\n        for (var i = 0; i < tokenCacheItems.length; i++) {\r\n            this.cacheStorage.removeItem(JSON.stringify(tokenCacheItems[i].key));\r\n        }\r\n        this.cacheStorage.resetCacheItems();\r\n        this.cacheStorage.clearMsalCookie();\r\n        this.logger.verbose(\"Cache cleared\");\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Clear a given access token from the cache.\r\n     *\r\n     * @param accessToken\r\n     */\r\n    UserAgentApplication.prototype.clearCacheForScope = function (accessToken) {\r\n        this.logger.verbose(\"Clearing access token from cache\");\r\n        var accessTokenItems = this.cacheStorage.getAllAccessTokens(Constants.clientId, Constants.homeAccountIdentifier);\r\n        for (var i = 0; i < accessTokenItems.length; i++) {\r\n            var token = accessTokenItems[i];\r\n            if (token.value.accessToken === accessToken) {\r\n                this.cacheStorage.removeItem(JSON.stringify(token.key));\r\n                this.logger.verbosePii(\"Access token removed: \" + token.key);\r\n            }\r\n        }\r\n    };\r\n    // #endregion\r\n    // #region Response\r\n    /**\r\n     * @hidden\r\n     * @ignore\r\n     * Checks if the redirect response is received from the STS. In case of redirect, the url fragment has either id_token, access_token or error.\r\n     * @param {string} hash - Hash passed from redirect page.\r\n     * @returns {Boolean} - true if response contains id_token, access_token or error, false otherwise.\r\n     */\r\n    UserAgentApplication.prototype.isCallback = function (hash) {\r\n        this.logger.info(\"isCallback will be deprecated in favor of urlContainsHash in MSAL.js v2.0.\");\r\n        this.logger.verbose(\"isCallback has been called\");\r\n        return UrlUtils.urlContainsHash(hash);\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Used to call the constructor callback with the token/error\r\n     * @param {string} [hash=window.location.hash] - Hash fragment of Url.\r\n     */\r\n    UserAgentApplication.prototype.processCallBack = function (hash, stateInfo, parentCallback) {\r\n        this.logger.info(\"ProcessCallBack has been called. Processing callback from redirect response\");\r\n        // get the state info from the hash\r\n        if (!stateInfo) {\r\n            this.logger.verbose(\"StateInfo is null, getting stateInfo from hash\");\r\n            stateInfo = this.getResponseState(hash);\r\n        }\r\n        var response;\r\n        var authErr;\r\n        // Save the token info from the hash\r\n        try {\r\n            response = this.saveTokenFromHash(hash, stateInfo);\r\n        }\r\n        catch (err) {\r\n            authErr = err;\r\n        }\r\n        try {\r\n            // Clear the cookie in the hash\r\n            this.cacheStorage.clearMsalCookie(stateInfo.state);\r\n            var accountState = this.getAccountState(stateInfo.state);\r\n            if (response) {\r\n                if ((stateInfo.requestType === Constants.renewToken) || response.accessToken) {\r\n                    if (window.parent !== window) {\r\n                        this.logger.verbose(\"Window is in iframe, acquiring token silently\");\r\n                    }\r\n                    else {\r\n                        this.logger.verbose(\"Acquiring token interactive in progress\");\r\n                    }\r\n                    this.logger.verbose(\"Response tokenType set to \" + ServerHashParamKeys.ACCESS_TOKEN);\r\n                    response.tokenType = ServerHashParamKeys.ACCESS_TOKEN;\r\n                }\r\n                else if (stateInfo.requestType === Constants.login) {\r\n                    this.logger.verbose(\"Response tokenType set to \" + ServerHashParamKeys.ID_TOKEN);\r\n                    response.tokenType = ServerHashParamKeys.ID_TOKEN;\r\n                }\r\n                if (!parentCallback) {\r\n                    this.logger.verbose(\"Setting redirectResponse\");\r\n                    this.redirectResponse = response;\r\n                    return;\r\n                }\r\n            }\r\n            else if (!parentCallback) {\r\n                this.logger.verbose(\"Response is null, setting redirectResponse with state\");\r\n                this.redirectResponse = buildResponseStateOnly(accountState);\r\n                this.redirectError = authErr;\r\n                this.cacheStorage.resetTempCacheItems(stateInfo.state);\r\n                return;\r\n            }\r\n            this.logger.verbose(\"Calling callback provided to processCallback\");\r\n            parentCallback(response, authErr);\r\n        }\r\n        catch (err) {\r\n            this.logger.error(\"Error occurred in token received callback function: \" + err);\r\n            throw ClientAuthError.createErrorInCallbackFunction(err.toString());\r\n        }\r\n    };\r\n    /**\r\n     * @hidden\r\n     * This method must be called for processing the response received from the STS if using popups or iframes. It extracts the hash, processes the token or error\r\n     * information and saves it in the cache. It then resolves the promises with the result.\r\n     * @param {string} [hash=window.location.hash] - Hash fragment of Url.\r\n     */\r\n    UserAgentApplication.prototype.handleAuthenticationResponse = function (hash) {\r\n        this.logger.verbose(\"HandleAuthenticationResponse has been called\");\r\n        // retrieve the hash\r\n        var locationHash = hash || window.location.hash;\r\n        // if (window.parent !== window), by using self, window.parent becomes equal to window in getResponseState method specifically\r\n        var stateInfo = this.getResponseState(locationHash);\r\n        this.logger.verbose(\"Obtained state from response\");\r\n        var tokenResponseCallback = window.callbackMappedToRenewStates[stateInfo.state];\r\n        this.processCallBack(locationHash, stateInfo, tokenResponseCallback);\r\n    };\r\n    /**\r\n     * @hidden\r\n     * This method must be called for processing the response received from the STS when using redirect flows. It extracts the hash, processes the token or error\r\n     * information and saves it in the cache. The result can then be accessed by user registered callbacks.\r\n     * @param {string} [hash=window.location.hash] - Hash fragment of Url.\r\n     */\r\n    UserAgentApplication.prototype.handleRedirectAuthenticationResponse = function (hash) {\r\n        this.logger.info(\"Returned from redirect url\");\r\n        this.logger.verbose(\"HandleRedirectAuthenticationResponse has been called\");\r\n        // clear hash from window\r\n        WindowUtils.clearUrlFragment();\r\n        this.logger.verbose(\"Window.location.hash cleared\");\r\n        // if (window.parent !== window), by using self, window.parent becomes equal to window in getResponseState method specifically\r\n        var stateInfo = this.getResponseState(hash);\r\n        // if set to navigate to loginRequest page post login\r\n        if (this.config.auth.navigateToLoginRequestUrl && window.parent === window) {\r\n            this.logger.verbose(\"Window.parent is equal to window, not in popup or iframe. Navigation to login request url after login turned on\");\r\n            var loginRequestUrl = this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.LOGIN_REQUEST, stateInfo.state), this.inCookie);\r\n            // Redirect to home page if login request url is null (real null or the string null)\r\n            if (!loginRequestUrl || loginRequestUrl === \"null\") {\r\n                this.logger.error(\"Unable to get valid login request url from cache, redirecting to home page\");\r\n                window.location.assign(\"/\");\r\n                return;\r\n            }\r\n            else {\r\n                this.logger.verbose(\"Valid login request url obtained from cache\");\r\n                var currentUrl = UrlUtils.removeHashFromUrl(window.location.href);\r\n                var finalRedirectUrl = UrlUtils.removeHashFromUrl(loginRequestUrl);\r\n                if (currentUrl !== finalRedirectUrl) {\r\n                    this.logger.verbose(\"Current url is not login request url, navigating\");\r\n                    this.logger.verbosePii(\"CurrentUrl: \" + currentUrl + \", finalRedirectUrl: \" + finalRedirectUrl);\r\n                    window.location.assign(\"\" + finalRedirectUrl + hash);\r\n                    return;\r\n                }\r\n                else {\r\n                    this.logger.verbose(\"Current url matches login request url\");\r\n                    var loginRequestUrlComponents = UrlUtils.GetUrlComponents(loginRequestUrl);\r\n                    if (loginRequestUrlComponents.Hash) {\r\n                        this.logger.verbose(\"Login request url contains hash, resetting non-msal hash\");\r\n                        window.location.hash = loginRequestUrlComponents.Hash;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (!this.config.auth.navigateToLoginRequestUrl) {\r\n            this.logger.verbose(\"Default navigation to start page after login turned off\");\r\n        }\r\n        this.processCallBack(hash, stateInfo, null);\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Creates a stateInfo object from the URL fragment and returns it.\r\n     * @param {string} hash  -  Hash passed from redirect page\r\n     * @returns {TokenResponse} an object created from the redirect response from AAD comprising of the keys - parameters, requestType, stateMatch, stateResponse and valid.\r\n     * @ignore\r\n     */\r\n    UserAgentApplication.prototype.getResponseState = function (hash) {\r\n        this.logger.verbose(\"GetResponseState has been called\");\r\n        var parameters = UrlUtils.deserializeHash(hash);\r\n        var stateResponse;\r\n        if (!parameters) {\r\n            throw AuthError.createUnexpectedError(\"Hash was not parsed correctly.\");\r\n        }\r\n        if (parameters.hasOwnProperty(ServerHashParamKeys.STATE)) {\r\n            this.logger.verbose(\"Hash contains state. Creating stateInfo object\");\r\n            var parsedState = RequestUtils.parseLibraryState(parameters.state);\r\n            stateResponse = {\r\n                requestType: Constants.unknown,\r\n                state: parameters.state,\r\n                timestamp: parsedState.ts,\r\n                method: parsedState.method,\r\n                stateMatch: false\r\n            };\r\n        }\r\n        else {\r\n            throw AuthError.createUnexpectedError(\"Hash does not contain state.\");\r\n        }\r\n        /*\r\n         * async calls can fire iframe and login request at the same time if developer does not use the API as expected\r\n         * incoming callback needs to be looked up to find the request type\r\n         */\r\n        // loginRedirect\r\n        if (stateResponse.state === this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_LOGIN, stateResponse.state), this.inCookie) || stateResponse.state === this.silentAuthenticationState) {\r\n            this.logger.verbose(\"State matches cached state, setting requestType to login\");\r\n            stateResponse.requestType = Constants.login;\r\n            stateResponse.stateMatch = true;\r\n            return stateResponse;\r\n        }\r\n        // acquireTokenRedirect\r\n        else if (stateResponse.state === this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_ACQ_TOKEN, stateResponse.state), this.inCookie)) {\r\n            this.logger.verbose(\"State matches cached state, setting requestType to renewToken\");\r\n            stateResponse.requestType = Constants.renewToken;\r\n            stateResponse.stateMatch = true;\r\n            return stateResponse;\r\n        }\r\n        // external api requests may have many renewtoken requests for different resource\r\n        if (!stateResponse.stateMatch) {\r\n            this.logger.verbose(\"State does not match cached state, setting requestType to type from window\");\r\n            stateResponse.requestType = window.requestType;\r\n            var statesInParentContext = window.renewStates;\r\n            for (var i = 0; i < statesInParentContext.length; i++) {\r\n                if (statesInParentContext[i] === stateResponse.state) {\r\n                    this.logger.verbose(\"Matching state found for request\");\r\n                    stateResponse.stateMatch = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!stateResponse.stateMatch) {\r\n                this.logger.verbose(\"Matching state not found for request\");\r\n            }\r\n        }\r\n        return stateResponse;\r\n    };\r\n    // #endregion\r\n    // #region Token Processing (Extract to TokenProcessing.ts)\r\n    /**\r\n     * @hidden\r\n     * Used to get token for the specified set of scopes from the cache\r\n     * @param {@link ServerRequestParameters} - Request sent to the STS to obtain an id_token/access_token\r\n     * @param {Account} account - Account for which the scopes were requested\r\n     */\r\n    UserAgentApplication.prototype.getCachedToken = function (serverAuthenticationRequest, account) {\r\n        this.logger.verbose(\"GetCachedToken has been called\");\r\n        var scopes = serverAuthenticationRequest.scopes;\r\n        /**\r\n         * Id Token should be returned in every acquireTokenSilent call. The only exception is a response_type = token\r\n         * request when a valid ID Token is not present in the cache.\r\n         */\r\n        var idToken = this.getCachedIdToken(serverAuthenticationRequest, account);\r\n        var authResponse = this.getCachedAccessToken(serverAuthenticationRequest, account, scopes);\r\n        var accountState = this.getAccountState(serverAuthenticationRequest.state);\r\n        return ResponseUtils.buildAuthResponse(idToken, authResponse, serverAuthenticationRequest, account, scopes, accountState);\r\n    };\r\n    /**\r\n     * @hidden\r\n     *\r\n     * Uses passed in authority to further filter an array of tokenCacheItems until only the token being searched for remains, then returns that tokenCacheItem.\r\n     * This method will throw if authority filtering still yields multiple matching tokens and will return null if not tokens match the authority passed in.\r\n     *\r\n     * @param authority\r\n     * @param tokenCacheItems\r\n     * @param request\r\n     * @param requestScopes\r\n     * @param tokenType\r\n     */\r\n    UserAgentApplication.prototype.getTokenCacheItemByAuthority = function (authority, tokenCacheItems, requestScopes, tokenType) {\r\n        var _this = this;\r\n        var filteredAuthorityItems;\r\n        if (UrlUtils.isCommonAuthority(authority) || UrlUtils.isOrganizationsAuthority(authority)) {\r\n            filteredAuthorityItems = AuthCacheUtils.filterTokenCacheItemsByDomain(tokenCacheItems, UrlUtils.GetUrlComponents(authority).HostNameAndPort);\r\n        }\r\n        else {\r\n            filteredAuthorityItems = AuthCacheUtils.filterTokenCacheItemsByAuthority(tokenCacheItems, authority);\r\n        }\r\n        if (filteredAuthorityItems.length === 1) {\r\n            return filteredAuthorityItems[0];\r\n        }\r\n        else if (filteredAuthorityItems.length > 1) {\r\n            this.logger.warning(\"Multiple matching tokens found. Cleaning cache and requesting a new token.\");\r\n            filteredAuthorityItems.forEach(function (accessTokenCacheItem) {\r\n                _this.cacheStorage.removeItem(JSON.stringify(accessTokenCacheItem.key));\r\n            });\r\n            return null;\r\n        }\r\n        else {\r\n            this.logger.verbose(\"No matching tokens of type \" + tokenType + \" found\");\r\n            return null;\r\n        }\r\n    };\r\n    /**\r\n     *\r\n     * @hidden\r\n     *\r\n     * Searches the token cache for an ID Token that matches the request parameter and returns it as an IdToken object.\r\n     *\r\n     * @param serverAuthenticationRequest\r\n     * @param account\r\n     */\r\n    UserAgentApplication.prototype.getCachedIdToken = function (serverAuthenticationRequest, account) {\r\n        this.logger.verbose(\"Getting all cached tokens of type ID Token\");\r\n        var idTokenCacheItems = this.cacheStorage.getAllIdTokens(this.clientId, account ? account.homeAccountIdentifier : null);\r\n        var matchAuthority = serverAuthenticationRequest.authority || this.authority;\r\n        var idTokenCacheItem = this.getTokenCacheItemByAuthority(matchAuthority, idTokenCacheItems, null, ServerHashParamKeys.ID_TOKEN);\r\n        if (idTokenCacheItem) {\r\n            this.logger.verbose(\"Evaluating ID token found\");\r\n            var idTokenIsStillValid = this.evaluateTokenExpiration(idTokenCacheItem);\r\n            if (idTokenIsStillValid) {\r\n                this.logger.verbose(\"ID token expiration is within offset, using ID token found in cache\");\r\n                var idTokenValue = idTokenCacheItem.value;\r\n                if (idTokenValue) {\r\n                    this.logger.verbose(\"ID Token found in cache is valid and unexpired\");\r\n                }\r\n                else {\r\n                    this.logger.verbose(\"ID Token found in cache is invalid\");\r\n                }\r\n                return (idTokenValue) ? new IdToken(idTokenValue.idToken) : null;\r\n            }\r\n            else {\r\n                this.logger.verbose(\"Cached ID token is expired, removing from cache\");\r\n                this.cacheStorage.removeItem(JSON.stringify(idTokenCacheItem.key));\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            this.logger.verbose(\"No tokens found\");\r\n            return null;\r\n        }\r\n    };\r\n    /**\r\n     *\r\n     * @hidden\r\n     *\r\n     * Searches the token cache for an access token that matches the request parameters and returns it as an AuthResponse.\r\n     *\r\n     * @param serverAuthenticationRequest\r\n     * @param account\r\n     * @param scopes\r\n     */\r\n    UserAgentApplication.prototype.getCachedAccessToken = function (serverAuthenticationRequest, account, scopes) {\r\n        this.logger.verbose(\"Getting all cached tokens of type Access Token\");\r\n        var tokenCacheItems = this.cacheStorage.getAllAccessTokens(this.clientId, account ? account.homeAccountIdentifier : null);\r\n        var scopeFilteredTokenCacheItems = AuthCacheUtils.filterTokenCacheItemsByScope(tokenCacheItems, scopes);\r\n        var matchAuthority = serverAuthenticationRequest.authority || this.authority;\r\n        // serverAuthenticationRequest.authority can only be common or organizations if not null\r\n        var accessTokenCacheItem = this.getTokenCacheItemByAuthority(matchAuthority, scopeFilteredTokenCacheItems, scopes, ServerHashParamKeys.ACCESS_TOKEN);\r\n        if (!accessTokenCacheItem) {\r\n            this.logger.verbose(\"No matching token found when filtering by scope and authority\");\r\n            var authorityList = this.getUniqueAuthority(tokenCacheItems, \"authority\");\r\n            if (authorityList.length > 1) {\r\n                throw ClientAuthError.createMultipleAuthoritiesInCacheError(scopes.toString());\r\n            }\r\n            this.logger.verbose(\"Single authority used, setting authorityInstance\");\r\n            serverAuthenticationRequest.authorityInstance = AuthorityFactory.CreateInstance(authorityList[0], this.config.auth.validateAuthority);\r\n            return null;\r\n        }\r\n        else {\r\n            serverAuthenticationRequest.authorityInstance = AuthorityFactory.CreateInstance(accessTokenCacheItem.key.authority, this.config.auth.validateAuthority);\r\n            this.logger.verbose(\"Evaluating access token found\");\r\n            var tokenIsStillValid = this.evaluateTokenExpiration(accessTokenCacheItem);\r\n            // The response value will stay null if token retrieved from the cache is expired, otherwise it will be populated with said token's data\r\n            if (tokenIsStillValid) {\r\n                this.logger.verbose(\"Access token expiration is within offset, using access token found in cache\");\r\n                if (!account) {\r\n                    account = this.getAccount();\r\n                    if (!account) {\r\n                        throw AuthError.createUnexpectedError(\"Account should not be null here.\");\r\n                    }\r\n                }\r\n                var aState = this.getAccountState(serverAuthenticationRequest.state);\r\n                var response = {\r\n                    uniqueId: \"\",\r\n                    tenantId: \"\",\r\n                    tokenType: ServerHashParamKeys.ACCESS_TOKEN,\r\n                    idToken: null,\r\n                    idTokenClaims: null,\r\n                    accessToken: accessTokenCacheItem.value.accessToken,\r\n                    scopes: accessTokenCacheItem.key.scopes.split(\" \"),\r\n                    expiresOn: new Date(Number(accessTokenCacheItem.value.expiresIn) * 1000),\r\n                    account: account,\r\n                    accountState: aState,\r\n                    fromCache: true\r\n                };\r\n                return response;\r\n            }\r\n            else {\r\n                this.logger.verbose(\"Access token expired, removing from cache\");\r\n                this.cacheStorage.removeItem(JSON.stringify(accessTokenCacheItem.key));\r\n                return null;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns true if the token passed in is within the acceptable expiration time offset, false if it is expired.\r\n     * @param tokenCacheItem\r\n     * @param serverAuthenticationRequest\r\n     */\r\n    UserAgentApplication.prototype.evaluateTokenExpiration = function (tokenCacheItem) {\r\n        var expiration = Number(tokenCacheItem.value.expiresIn);\r\n        return TokenUtils.validateExpirationIsWithinOffset(expiration, this.config.system.tokenRenewalOffsetSeconds);\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Used to get a unique list of authorities from the cache\r\n     * @param {Array<AccessTokenCacheItem>}  accessTokenCacheItems - accessTokenCacheItems saved in the cache\r\n     * @ignore\r\n     */\r\n    UserAgentApplication.prototype.getUniqueAuthority = function (accessTokenCacheItems, property) {\r\n        this.logger.verbose(\"GetUniqueAuthority has been called\");\r\n        var authorityList = [];\r\n        var flags = [];\r\n        accessTokenCacheItems.forEach(function (element) {\r\n            if (element.key.hasOwnProperty(property) && (flags.indexOf(element.key[property]) === -1)) {\r\n                flags.push(element.key[property]);\r\n                authorityList.push(element.key[property]);\r\n            }\r\n        });\r\n        return authorityList;\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Check if ADAL id_token exists and return if exists.\r\n     *\r\n     */\r\n    UserAgentApplication.prototype.extractADALIdToken = function () {\r\n        this.logger.verbose(\"ExtractADALIdToken has been called\");\r\n        var adalIdToken = this.cacheStorage.getItem(Constants.adalIdToken);\r\n        return (!StringUtils.isEmpty(adalIdToken)) ? TokenUtils.extractIdToken(adalIdToken) : null;\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Acquires access token using a hidden iframe.\r\n     * @ignore\r\n     */\r\n    UserAgentApplication.prototype.renewToken = function (requestSignature, resolve, reject, account, serverAuthenticationRequest) {\r\n        this.logger.verbose(\"RenewToken has been called\");\r\n        this.logger.verbosePii(\"RenewToken scope and authority: \" + requestSignature);\r\n        var frameName = WindowUtils.generateFrameName(FramePrefix.TOKEN_FRAME, requestSignature);\r\n        WindowUtils.addHiddenIFrame(frameName, this.logger);\r\n        this.updateCacheEntries(serverAuthenticationRequest, account, false);\r\n        this.logger.verbosePii(\"RenewToken expected state: \" + serverAuthenticationRequest.state);\r\n        // Build urlNavigate with \"prompt=none\" and navigate to URL in hidden iFrame\r\n        var urlNavigate = UrlUtils.urlRemoveQueryStringParameter(UrlUtils.createNavigateUrl(serverAuthenticationRequest), Constants.prompt) + Constants.prompt_none + Constants.response_mode_fragment;\r\n        window.renewStates.push(serverAuthenticationRequest.state);\r\n        window.requestType = Constants.renewToken;\r\n        this.logger.verbose(\"Set window.renewState and requestType\");\r\n        this.registerCallback(serverAuthenticationRequest.state, requestSignature, resolve, reject);\r\n        this.logger.infoPii(\"Navigate to: \" + urlNavigate);\r\n        this.loadIframeTimeout(urlNavigate, frameName, requestSignature).catch(function (error) { return reject(error); });\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Renews idtoken for app's own backend when clientId is passed as a single scope in the scopes array.\r\n     * @ignore\r\n     */\r\n    UserAgentApplication.prototype.renewIdToken = function (requestSignature, resolve, reject, account, serverAuthenticationRequest) {\r\n        this.logger.info(\"RenewIdToken has been called\");\r\n        var frameName = WindowUtils.generateFrameName(FramePrefix.ID_TOKEN_FRAME, requestSignature);\r\n        WindowUtils.addHiddenIFrame(frameName, this.logger);\r\n        this.updateCacheEntries(serverAuthenticationRequest, account, false);\r\n        this.logger.verbose(\"RenewIdToken expected state: \" + serverAuthenticationRequest.state);\r\n        // Build urlNavigate with \"prompt=none\" and navigate to URL in hidden iFrame\r\n        var urlNavigate = UrlUtils.urlRemoveQueryStringParameter(UrlUtils.createNavigateUrl(serverAuthenticationRequest), Constants.prompt) + Constants.prompt_none + Constants.response_mode_fragment;\r\n        if (this.silentLogin) {\r\n            this.logger.verbose(\"Silent login is true, set silentAuthenticationState\");\r\n            window.requestType = Constants.login;\r\n            this.silentAuthenticationState = serverAuthenticationRequest.state;\r\n        }\r\n        else {\r\n            this.logger.verbose(\"Not silent login, set window.renewState and requestType\");\r\n            window.requestType = Constants.renewToken;\r\n            window.renewStates.push(serverAuthenticationRequest.state);\r\n        }\r\n        // note: scope here is clientId\r\n        this.registerCallback(serverAuthenticationRequest.state, requestSignature, resolve, reject);\r\n        this.logger.infoPii(\"Navigate to:\\\" \" + urlNavigate);\r\n        this.loadIframeTimeout(urlNavigate, frameName, requestSignature).catch(function (error) { return reject(error); });\r\n    };\r\n    /**\r\n     * @hidden\r\n     *\r\n     * This method builds an Access Token Cache item and saves it to the cache, returning the original\r\n     * AuthResponse augmented with a parsed expiresOn attribute.\r\n     *\r\n     * @param response The AuthResponse object that contains the token to be saved\r\n     * @param authority The authority under which the ID token will be cached\r\n     * @param scopes The scopes to be added to the cache item key (undefined for ID token cache items)\r\n     * @param clientInfo Client Info object that is used to generate the homeAccountIdentifier\r\n     * @param expiration Token expiration timestamp\r\n     */\r\n    UserAgentApplication.prototype.saveToken = function (response, authority, scopes, clientInfo, expiration) {\r\n        var accessTokenKey = new AccessTokenKey(authority, this.clientId, scopes, clientInfo.uid, clientInfo.utid);\r\n        var accessTokenValue = new AccessTokenValue(response.accessToken, response.idToken.rawIdToken, expiration.toString(), clientInfo.encodeClientInfo());\r\n        this.cacheStorage.setItem(JSON.stringify(accessTokenKey), JSON.stringify(accessTokenValue));\r\n        if (expiration) {\r\n            this.logger.verbose(\"New expiration set for token\");\r\n            response.expiresOn = new Date(expiration * 1000);\r\n        }\r\n        else {\r\n            this.logger.error(\"Could not parse expiresIn parameter for access token\");\r\n        }\r\n        return response;\r\n    };\r\n    /**\r\n     * @hidden\r\n     *\r\n     * This method sets up the elements of an ID Token cache item and calls saveToken to save it in\r\n     * Access Token Cache item format for the client application to use.\r\n     *\r\n     * @param response The AuthResponse object that will be used to build the cache item\r\n     * @param authority The authority under which the ID token will be cached\r\n     * @param parameters The response's Hash Params, which contain the ID token returned from the server\r\n     * @param clientInfo Client Info object that is used to generate the homeAccountIdentifier\r\n     * @param idTokenObj ID Token object from which the ID token's expiration is extracted\r\n     */\r\n    /* tslint:disable:no-string-literal */\r\n    UserAgentApplication.prototype.saveIdToken = function (response, authority, parameters, clientInfo, idTokenObj) {\r\n        this.logger.verbose(\"SaveIdToken has been called\");\r\n        var idTokenResponse = tslib_1.__assign({}, response);\r\n        // Scopes are undefined so they don't show up in ID token cache key\r\n        var scopes;\r\n        idTokenResponse.scopes = Constants.oidcScopes;\r\n        idTokenResponse.accessToken = parameters[ServerHashParamKeys.ID_TOKEN];\r\n        var expiration = Number(idTokenObj.expiration);\r\n        // Set ID Token item in cache\r\n        this.logger.verbose(\"Saving ID token to cache\");\r\n        return this.saveToken(idTokenResponse, authority, scopes, clientInfo, expiration);\r\n    };\r\n    /**\r\n     * @hidden\r\n     *\r\n     * This method sets up the elements of an Access Token cache item and calls saveToken to save it to the cache\r\n     *\r\n     * @param response The AuthResponse object that will be used to build the cache item\r\n     * @param authority The authority under which the access token will be cached\r\n     * @param parameters The response's Hash Params, which contain the access token returned from the server\r\n     * @param clientInfo Client Info object that is used to generate the homeAccountIdentifier\r\n     */\r\n    /* tslint:disable:no-string-literal */\r\n    UserAgentApplication.prototype.saveAccessToken = function (response, authority, parameters, clientInfo) {\r\n        this.logger.verbose(\"SaveAccessToken has been called\");\r\n        var accessTokenResponse = tslib_1.__assign({}, response);\r\n        // read the scopes\r\n        var scope = parameters[ServerHashParamKeys.SCOPE];\r\n        var consentedScopes = scope.split(\" \");\r\n        // retrieve all access tokens from the cache, remove the dup scopes\r\n        var accessTokenCacheItems = this.cacheStorage.getAllAccessTokens(this.clientId, authority);\r\n        this.logger.verbose(\"Retrieving all access tokens from cache and removing duplicates\");\r\n        for (var i = 0; i < accessTokenCacheItems.length; i++) {\r\n            var accessTokenCacheItem = accessTokenCacheItems[i];\r\n            if (accessTokenCacheItem.key.homeAccountIdentifier === response.account.homeAccountIdentifier) {\r\n                var cachedScopes = accessTokenCacheItem.key.scopes.split(\" \");\r\n                if (ScopeSet.isIntersectingScopes(cachedScopes, consentedScopes)) {\r\n                    this.cacheStorage.removeItem(JSON.stringify(accessTokenCacheItem.key));\r\n                }\r\n            }\r\n        }\r\n        accessTokenResponse.accessToken = parameters[ServerHashParamKeys.ACCESS_TOKEN];\r\n        accessTokenResponse.scopes = consentedScopes;\r\n        var expiresIn = TimeUtils.parseExpiresIn(parameters[ServerHashParamKeys.EXPIRES_IN]);\r\n        var parsedState = RequestUtils.parseLibraryState(parameters[ServerHashParamKeys.STATE]);\r\n        var expiration = parsedState.ts + expiresIn;\r\n        this.logger.verbose(\"Saving access token to cache\");\r\n        return this.saveToken(accessTokenResponse, authority, scope, clientInfo, expiration);\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Saves token or error received in the response from AAD in the cache. In case of id_token, it also creates the account object.\r\n     * @ignore\r\n     */\r\n    UserAgentApplication.prototype.saveTokenFromHash = function (hash, stateInfo) {\r\n        this.logger.verbose(\"SaveTokenFromHash has been called\");\r\n        this.logger.info(\"State status: \" + stateInfo.stateMatch + \"; Request type: \" + stateInfo.requestType);\r\n        var response = {\r\n            uniqueId: \"\",\r\n            tenantId: \"\",\r\n            tokenType: \"\",\r\n            idToken: null,\r\n            idTokenClaims: null,\r\n            accessToken: null,\r\n            scopes: [],\r\n            expiresOn: null,\r\n            account: null,\r\n            accountState: \"\",\r\n            fromCache: false\r\n        };\r\n        var error;\r\n        var hashParams = UrlUtils.deserializeHash(hash);\r\n        var authorityKey = \"\";\r\n        var acquireTokenAccountKey = \"\";\r\n        var idTokenObj = null;\r\n        // If server returns an error\r\n        if (hashParams.hasOwnProperty(ServerHashParamKeys.ERROR_DESCRIPTION) || hashParams.hasOwnProperty(ServerHashParamKeys.ERROR)) {\r\n            this.logger.verbose(\"Server returned an error\");\r\n            this.logger.infoPii(\"Error : \" + hashParams[ServerHashParamKeys.ERROR] + \"; Error description: \" + hashParams[ServerHashParamKeys.ERROR_DESCRIPTION]);\r\n            this.cacheStorage.setItem(ErrorCacheKeys.ERROR, hashParams[ServerHashParamKeys.ERROR]);\r\n            this.cacheStorage.setItem(ErrorCacheKeys.ERROR_DESC, hashParams[ServerHashParamKeys.ERROR_DESCRIPTION]);\r\n            // login\r\n            if (stateInfo.requestType === Constants.login) {\r\n                this.logger.verbose(\"RequestType is login, caching login error, generating authorityKey\");\r\n                this.cacheStorage.setItem(ErrorCacheKeys.LOGIN_ERROR, hashParams[ServerHashParamKeys.ERROR_DESCRIPTION] + \":\" + hashParams[ServerHashParamKeys.ERROR]);\r\n                authorityKey = AuthCache.generateAuthorityKey(stateInfo.state);\r\n            }\r\n            // acquireToken\r\n            if (stateInfo.requestType === Constants.renewToken) {\r\n                this.logger.verbose(\"RequestType is renewToken, generating acquireTokenAccountKey\");\r\n                authorityKey = AuthCache.generateAuthorityKey(stateInfo.state);\r\n                var account = this.getAccount();\r\n                var accountId = void 0;\r\n                if (account && !StringUtils.isEmpty(account.homeAccountIdentifier)) {\r\n                    accountId = account.homeAccountIdentifier;\r\n                    this.logger.verbose(\"AccountId is set\");\r\n                }\r\n                else {\r\n                    accountId = Constants.no_account;\r\n                    this.logger.verbose(\"AccountId is set as no_account\");\r\n                }\r\n                acquireTokenAccountKey = AuthCache.generateAcquireTokenAccountKey(accountId, stateInfo.state);\r\n            }\r\n            var _a = ServerHashParamKeys.ERROR, hashErr = hashParams[_a], _b = ServerHashParamKeys.ERROR_DESCRIPTION, hashErrDesc = hashParams[_b];\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(hashErr) ||\r\n                InteractionRequiredAuthError.isInteractionRequiredError(hashErrDesc)) {\r\n                error = new InteractionRequiredAuthError(hashParams[ServerHashParamKeys.ERROR], hashParams[ServerHashParamKeys.ERROR_DESCRIPTION]);\r\n            }\r\n            else {\r\n                error = new ServerError(hashParams[ServerHashParamKeys.ERROR], hashParams[ServerHashParamKeys.ERROR_DESCRIPTION]);\r\n            }\r\n        }\r\n        // If the server returns \"Success\"\r\n        else {\r\n            this.logger.verbose(\"Server returns success\");\r\n            // Verify the state from redirect and record tokens to storage if exists\r\n            if (stateInfo.stateMatch) {\r\n                this.logger.info(\"State is right\");\r\n                if (hashParams.hasOwnProperty(ServerHashParamKeys.SESSION_STATE)) {\r\n                    this.logger.verbose(\"Fragment has session state, caching\");\r\n                    this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.SESSION_STATE, stateInfo.state), hashParams[ServerHashParamKeys.SESSION_STATE]);\r\n                }\r\n                response.accountState = this.getAccountState(stateInfo.state);\r\n                var clientInfo = void 0;\r\n                // Process access_token\r\n                if (hashParams.hasOwnProperty(ServerHashParamKeys.ACCESS_TOKEN)) {\r\n                    this.logger.info(\"Fragment has access token\");\r\n                    response.accessToken = hashParams[ServerHashParamKeys.ACCESS_TOKEN];\r\n                    if (hashParams.hasOwnProperty(ServerHashParamKeys.SCOPE)) {\r\n                        response.scopes = hashParams[ServerHashParamKeys.SCOPE].split(\" \");\r\n                    }\r\n                    // retrieve the id_token from response if present\r\n                    if (hashParams.hasOwnProperty(ServerHashParamKeys.ID_TOKEN)) {\r\n                        this.logger.verbose(\"Fragment has id_token\");\r\n                        idTokenObj = new IdToken(hashParams[ServerHashParamKeys.ID_TOKEN]);\r\n                    }\r\n                    else {\r\n                        this.logger.verbose(\"No idToken on fragment, getting idToken from cache\");\r\n                        idTokenObj = new IdToken(this.cacheStorage.getItem(PersistentCacheKeys.IDTOKEN));\r\n                    }\r\n                    response = ResponseUtils.setResponseIdToken(response, idTokenObj);\r\n                    // set authority\r\n                    var authority = this.populateAuthority(stateInfo.state, this.inCookie, this.cacheStorage, idTokenObj);\r\n                    this.logger.verbose(\"Got authority from cache\");\r\n                    // retrieve client_info - if it is not found, generate the uid and utid from idToken\r\n                    if (hashParams.hasOwnProperty(ServerHashParamKeys.CLIENT_INFO)) {\r\n                        this.logger.verbose(\"Fragment has clientInfo\");\r\n                        clientInfo = new ClientInfo(hashParams[ServerHashParamKeys.CLIENT_INFO], authority);\r\n                    }\r\n                    else if (this.authorityInstance.AuthorityType === AuthorityType.Adfs) {\r\n                        clientInfo = ClientInfo.createClientInfoFromIdToken(idTokenObj, authority);\r\n                    }\r\n                    else {\r\n                        this.logger.warning(\"ClientInfo not received in the response from AAD\");\r\n                    }\r\n                    response.account = Account.createAccount(idTokenObj, clientInfo);\r\n                    this.logger.verbose(\"Account object created from response\");\r\n                    var accountKey = void 0;\r\n                    if (response.account && !StringUtils.isEmpty(response.account.homeAccountIdentifier)) {\r\n                        this.logger.verbose(\"AccountKey set\");\r\n                        accountKey = response.account.homeAccountIdentifier;\r\n                    }\r\n                    else {\r\n                        this.logger.verbose(\"AccountKey set as no_account\");\r\n                        accountKey = Constants.no_account;\r\n                    }\r\n                    acquireTokenAccountKey = AuthCache.generateAcquireTokenAccountKey(accountKey, stateInfo.state);\r\n                    var acquireTokenAccountKey_noaccount = AuthCache.generateAcquireTokenAccountKey(Constants.no_account, stateInfo.state);\r\n                    this.logger.verbose(\"AcquireTokenAccountKey generated\");\r\n                    var cachedAccount = this.cacheStorage.getItem(acquireTokenAccountKey);\r\n                    var acquireTokenAccount = void 0;\r\n                    // Check with the account in the Cache\r\n                    if (!StringUtils.isEmpty(cachedAccount)) {\r\n                        acquireTokenAccount = JSON.parse(cachedAccount);\r\n                        this.logger.verbose(\"AcquireToken request account retrieved from cache\");\r\n                        if (response.account && acquireTokenAccount && Account.compareAccounts(response.account, acquireTokenAccount)) {\r\n                            response = this.saveAccessToken(response, authority, hashParams, clientInfo);\r\n                            this.logger.info(\"The user object received in the response is the same as the one passed in the acquireToken request\");\r\n                        }\r\n                        else {\r\n                            this.logger.warning(\"The account object created from the response is not the same as the one passed in the acquireToken request\");\r\n                        }\r\n                    }\r\n                    else if (!StringUtils.isEmpty(this.cacheStorage.getItem(acquireTokenAccountKey_noaccount))) {\r\n                        this.logger.verbose(\"No acquireToken account retrieved from cache\");\r\n                        response = this.saveAccessToken(response, authority, hashParams, clientInfo);\r\n                    }\r\n                }\r\n                // Process id_token\r\n                if (hashParams.hasOwnProperty(ServerHashParamKeys.ID_TOKEN)) {\r\n                    this.logger.info(\"Fragment has idToken\");\r\n                    // set the idToken\r\n                    idTokenObj = new IdToken(hashParams[ServerHashParamKeys.ID_TOKEN]);\r\n                    // set authority\r\n                    var authority = this.populateAuthority(stateInfo.state, this.inCookie, this.cacheStorage, idTokenObj);\r\n                    response = ResponseUtils.setResponseIdToken(response, idTokenObj);\r\n                    if (hashParams.hasOwnProperty(ServerHashParamKeys.CLIENT_INFO)) {\r\n                        this.logger.verbose(\"Fragment has clientInfo\");\r\n                        clientInfo = new ClientInfo(hashParams[ServerHashParamKeys.CLIENT_INFO], authority);\r\n                    }\r\n                    else if (this.authorityInstance.AuthorityType === AuthorityType.Adfs) {\r\n                        clientInfo = ClientInfo.createClientInfoFromIdToken(idTokenObj, authority);\r\n                    }\r\n                    else {\r\n                        this.logger.warning(\"ClientInfo not received in the response from AAD\");\r\n                    }\r\n                    this.account = Account.createAccount(idTokenObj, clientInfo);\r\n                    response.account = this.account;\r\n                    this.logger.verbose(\"Account object created from response\");\r\n                    if (idTokenObj && idTokenObj.nonce) {\r\n                        this.logger.verbose(\"IdToken has nonce\");\r\n                        // check nonce integrity if idToken has nonce - throw an error if not matched\r\n                        var cachedNonce = this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN, stateInfo.state), this.inCookie);\r\n                        if (idTokenObj.nonce !== cachedNonce) {\r\n                            this.account = null;\r\n                            this.cacheStorage.setItem(ErrorCacheKeys.LOGIN_ERROR, \"Nonce Mismatch. Expected Nonce: \" + cachedNonce + \",\" + \"Actual Nonce: \" + idTokenObj.nonce);\r\n                            this.logger.error(\"Nonce Mismatch. Expected Nonce: \" + cachedNonce + \", Actual Nonce: \" + idTokenObj.nonce);\r\n                            error = ClientAuthError.createNonceMismatchError(cachedNonce, idTokenObj.nonce);\r\n                        }\r\n                        // Save the token\r\n                        else {\r\n                            this.logger.verbose(\"Nonce matches, saving idToken to cache\");\r\n                            this.cacheStorage.setItem(PersistentCacheKeys.IDTOKEN, hashParams[ServerHashParamKeys.ID_TOKEN], this.inCookie);\r\n                            this.cacheStorage.setItem(PersistentCacheKeys.CLIENT_INFO, clientInfo.encodeClientInfo(), this.inCookie);\r\n                            // Save idToken as access token item for app itself\r\n                            this.saveIdToken(response, authority, hashParams, clientInfo, idTokenObj);\r\n                        }\r\n                    }\r\n                    else {\r\n                        this.logger.verbose(\"No idToken or no nonce. Cache key for Authority set as state\");\r\n                        authorityKey = stateInfo.state;\r\n                        acquireTokenAccountKey = stateInfo.state;\r\n                        this.logger.error(\"Invalid id_token received in the response\");\r\n                        error = ClientAuthError.createInvalidIdTokenError(idTokenObj);\r\n                        this.cacheStorage.setItem(ErrorCacheKeys.ERROR, error.errorCode);\r\n                        this.cacheStorage.setItem(ErrorCacheKeys.ERROR_DESC, error.errorMessage);\r\n                    }\r\n                }\r\n            }\r\n            // State mismatch - unexpected/invalid state\r\n            else {\r\n                this.logger.verbose(\"State mismatch\");\r\n                authorityKey = stateInfo.state;\r\n                acquireTokenAccountKey = stateInfo.state;\r\n                var expectedState = this.cacheStorage.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_LOGIN, stateInfo.state), this.inCookie);\r\n                this.logger.error(\"State Mismatch. Expected State: \" + expectedState + \", Actual State: \" + stateInfo.state);\r\n                error = ClientAuthError.createInvalidStateError(stateInfo.state, expectedState);\r\n                this.cacheStorage.setItem(ErrorCacheKeys.ERROR, error.errorCode);\r\n                this.cacheStorage.setItem(ErrorCacheKeys.ERROR_DESC, error.errorMessage);\r\n            }\r\n        }\r\n        // Set status to completed\r\n        this.cacheStorage.removeItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, stateInfo.state));\r\n        this.cacheStorage.resetTempCacheItems(stateInfo.state);\r\n        this.logger.verbose(\"Status set to complete, temporary cache cleared\");\r\n        // this is required if navigateToLoginRequestUrl=false\r\n        if (this.inCookie) {\r\n            this.logger.verbose(\"InCookie is true, setting authorityKey in cookie\");\r\n            this.cacheStorage.setItemCookie(authorityKey, \"\", -1);\r\n            this.cacheStorage.clearMsalCookie(stateInfo.state);\r\n        }\r\n        if (error) {\r\n            // Error case, set status to cancelled\r\n            throw error;\r\n        }\r\n        if (!response) {\r\n            throw AuthError.createUnexpectedError(\"Response is null\");\r\n        }\r\n        return response;\r\n    };\r\n    /**\r\n     * Set Authority when saving Token from the hash\r\n     * @param state\r\n     * @param inCookie\r\n     * @param cacheStorage\r\n     * @param idTokenObj\r\n     * @param response\r\n     */\r\n    UserAgentApplication.prototype.populateAuthority = function (state, inCookie, cacheStorage, idTokenObj) {\r\n        this.logger.verbose(\"PopulateAuthority has been called\");\r\n        var authorityKey = AuthCache.generateAuthorityKey(state);\r\n        var cachedAuthority = cacheStorage.getItem(authorityKey, inCookie);\r\n        // retrieve the authority from cache and replace with tenantID\r\n        return StringUtils.isEmpty(cachedAuthority) ? cachedAuthority : UrlUtils.replaceTenantPath(cachedAuthority, idTokenObj.tenantId);\r\n    };\r\n    /* tslint:enable:no-string-literal */\r\n    // #endregion\r\n    // #region Account\r\n    /**\r\n     * Returns the signed in account\r\n     * (the account object is created at the time of successful login)\r\n     * or null when no state is found\r\n     * @returns {@link Account} - the account object stored in MSAL\r\n     */\r\n    UserAgentApplication.prototype.getAccount = function () {\r\n        // if a session already exists, get the account from the session\r\n        if (this.account) {\r\n            return this.account;\r\n        }\r\n        // frame is used to get idToken and populate the account for the given session\r\n        var rawIdToken = this.cacheStorage.getItem(PersistentCacheKeys.IDTOKEN, this.inCookie);\r\n        var rawClientInfo = this.cacheStorage.getItem(PersistentCacheKeys.CLIENT_INFO, this.inCookie);\r\n        if (!StringUtils.isEmpty(rawIdToken) && !StringUtils.isEmpty(rawClientInfo)) {\r\n            var idToken = new IdToken(rawIdToken);\r\n            var clientInfo = new ClientInfo(rawClientInfo, \"\");\r\n            this.account = Account.createAccount(idToken, clientInfo);\r\n            return this.account;\r\n        }\r\n        // if login not yet done, return null\r\n        return null;\r\n    };\r\n    /**\r\n     * @hidden\r\n     *\r\n     * Extracts state value from the accountState sent with the authentication request.\r\n     * @returns {string} scope.\r\n     * @ignore\r\n     */\r\n    UserAgentApplication.prototype.getAccountState = function (state) {\r\n        if (state) {\r\n            var splitIndex = state.indexOf(Constants.resourceDelimiter);\r\n            if (splitIndex > -1 && splitIndex + 1 < state.length) {\r\n                return state.substring(splitIndex + 1);\r\n            }\r\n        }\r\n        return state;\r\n    };\r\n    /**\r\n     * Use to get a list of unique accounts in MSAL cache based on homeAccountIdentifier.\r\n     *\r\n     * @param {@link Array<Account>} Account - all unique accounts in MSAL cache.\r\n     */\r\n    UserAgentApplication.prototype.getAllAccounts = function () {\r\n        var accounts = [];\r\n        var accessTokenCacheItems = this.cacheStorage.getAllAccessTokens(Constants.clientId, Constants.homeAccountIdentifier);\r\n        for (var i = 0; i < accessTokenCacheItems.length; i++) {\r\n            var idToken = new IdToken(accessTokenCacheItems[i].value.idToken);\r\n            var clientInfo = new ClientInfo(accessTokenCacheItems[i].value.homeAccountIdentifier, \"\");\r\n            var account = Account.createAccount(idToken, clientInfo);\r\n            accounts.push(account);\r\n        }\r\n        return this.getUniqueAccounts(accounts);\r\n    };\r\n    /**\r\n     * @hidden\r\n     *\r\n     * Used to filter accounts based on homeAccountIdentifier\r\n     * @param {Array<Account>}  Accounts - accounts saved in the cache\r\n     * @ignore\r\n     */\r\n    UserAgentApplication.prototype.getUniqueAccounts = function (accounts) {\r\n        if (!accounts || accounts.length <= 1) {\r\n            return accounts;\r\n        }\r\n        var flags = [];\r\n        var uniqueAccounts = [];\r\n        for (var index = 0; index < accounts.length; ++index) {\r\n            if (accounts[index].homeAccountIdentifier && flags.indexOf(accounts[index].homeAccountIdentifier) === -1) {\r\n                flags.push(accounts[index].homeAccountIdentifier);\r\n                uniqueAccounts.push(accounts[index]);\r\n            }\r\n        }\r\n        return uniqueAccounts;\r\n    };\r\n    // #endregion\r\n    // #region Angular\r\n    /**\r\n     * @hidden\r\n     *\r\n     * Broadcast messages - Used only for Angular?  *\r\n     * @param eventName\r\n     * @param data\r\n     */\r\n    UserAgentApplication.prototype.broadcast = function (eventName, data) {\r\n        var evt = new CustomEvent(eventName, { detail: data });\r\n        window.dispatchEvent(evt);\r\n    };\r\n    /**\r\n     * @hidden\r\n     *\r\n     * Helper function to retrieve the cached token\r\n     *\r\n     * @param scopes\r\n     * @param {@link Account} account\r\n     * @param state\r\n     * @return {@link AuthResponse} AuthResponse\r\n     */\r\n    UserAgentApplication.prototype.getCachedTokenInternal = function (scopes, account, state, correlationId) {\r\n        // Get the current session's account object\r\n        var accountObject = account || this.getAccount();\r\n        if (!accountObject) {\r\n            return null;\r\n        }\r\n        // Construct AuthenticationRequest based on response type; set \"redirectUri\" from the \"request\" which makes this call from Angular - for this.getRedirectUri()\r\n        var newAuthority = this.authorityInstance ? this.authorityInstance : AuthorityFactory.CreateInstance(this.authority, this.config.auth.validateAuthority);\r\n        var responseType = this.getTokenType(accountObject, scopes);\r\n        var serverAuthenticationRequest = new ServerRequestParameters(newAuthority, this.clientId, responseType, this.getRedirectUri(), scopes, state, correlationId);\r\n        // get cached token\r\n        return this.getCachedToken(serverAuthenticationRequest, account);\r\n    };\r\n    /**\r\n     * @hidden\r\n     *\r\n     * Get scopes for the Endpoint - Used in Angular to track protected and unprotected resources without interaction from the developer app\r\n     * Note: Please check if we need to set the \"redirectUri\" from the \"request\" which makes this call from Angular - for this.getRedirectUri()\r\n     *\r\n     * @param endpoint\r\n     */\r\n    UserAgentApplication.prototype.getScopesForEndpoint = function (endpoint) {\r\n        // if user specified list of unprotectedResources, no need to send token to these endpoints, return null.\r\n        if (this.config.framework.unprotectedResources.length > 0) {\r\n            for (var i = 0; i < this.config.framework.unprotectedResources.length; i++) {\r\n                if (endpoint.indexOf(this.config.framework.unprotectedResources[i]) > -1) {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n        // process all protected resources and send the matched one\r\n        if (this.config.framework.protectedResourceMap.size > 0) {\r\n            for (var _i = 0, _a = Array.from(this.config.framework.protectedResourceMap.keys()); _i < _a.length; _i++) {\r\n                var key = _a[_i];\r\n                // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1\r\n                if (endpoint.indexOf(key) > -1) {\r\n                    return this.config.framework.protectedResourceMap.get(key);\r\n                }\r\n            }\r\n        }\r\n        /*\r\n         * default resource will be clientid if nothing specified\r\n         * App will use idtoken for calls to itself\r\n         * check if it's staring from http or https, needs to match with app host\r\n         */\r\n        if (endpoint.indexOf(\"http://\") > -1 || endpoint.indexOf(\"https://\") > -1) {\r\n            if (UrlUtils.getHostFromUri(endpoint) === UrlUtils.getHostFromUri(this.getRedirectUri())) {\r\n                return new Array(this.clientId);\r\n            }\r\n        }\r\n        else {\r\n            /*\r\n             * in angular level, the url for $http interceptor call could be relative url,\r\n             * if it's relative call, we'll treat it as app backend call.\r\n             */\r\n            return new Array(this.clientId);\r\n        }\r\n        // if not the app's own backend or not a domain listed in the endpoints structure\r\n        return null;\r\n    };\r\n    /**\r\n     * Return boolean flag to developer to help inform if login is in progress\r\n     * @returns {boolean} true/false\r\n     */\r\n    UserAgentApplication.prototype.getLoginInProgress = function () {\r\n        return this.cacheStorage.getItem(TemporaryCacheKeys.INTERACTION_STATUS) === Constants.inProgress;\r\n    };\r\n    /**\r\n     * @hidden\r\n     * @ignore\r\n     *\r\n     * @param loginInProgress\r\n     */\r\n    UserAgentApplication.prototype.setInteractionInProgress = function (inProgress) {\r\n        if (inProgress) {\r\n            this.cacheStorage.setItem(TemporaryCacheKeys.INTERACTION_STATUS, Constants.inProgress);\r\n        }\r\n        else {\r\n            this.cacheStorage.removeItem(TemporaryCacheKeys.INTERACTION_STATUS);\r\n        }\r\n    };\r\n    /**\r\n     * @hidden\r\n     * @ignore\r\n     *\r\n     * @param loginInProgress\r\n     */\r\n    UserAgentApplication.prototype.setloginInProgress = function (loginInProgress) {\r\n        this.setInteractionInProgress(loginInProgress);\r\n    };\r\n    /**\r\n     * @hidden\r\n     * @ignore\r\n     *\r\n     * returns the status of acquireTokenInProgress\r\n     */\r\n    UserAgentApplication.prototype.getAcquireTokenInProgress = function () {\r\n        return this.cacheStorage.getItem(TemporaryCacheKeys.INTERACTION_STATUS) === Constants.inProgress;\r\n    };\r\n    /**\r\n     * @hidden\r\n     * @ignore\r\n     *\r\n     * @param acquireTokenInProgress\r\n     */\r\n    UserAgentApplication.prototype.setAcquireTokenInProgress = function (acquireTokenInProgress) {\r\n        this.setInteractionInProgress(acquireTokenInProgress);\r\n    };\r\n    /**\r\n     * @hidden\r\n     * @ignore\r\n     *\r\n     * returns the logger handle\r\n     */\r\n    UserAgentApplication.prototype.getLogger = function () {\r\n        return this.logger;\r\n    };\r\n    /**\r\n     * Sets the logger callback.\r\n     * @param logger Logger callback\r\n     */\r\n    UserAgentApplication.prototype.setLogger = function (logger) {\r\n        this.logger = logger;\r\n    };\r\n    // #endregion\r\n    // #region Getters and Setters\r\n    /**\r\n     * Use to get the redirect uri configured in MSAL or null.\r\n     * Evaluates redirectUri if its a function, otherwise simply returns its value.\r\n     *\r\n     * @returns {string} redirect URL\r\n     */\r\n    UserAgentApplication.prototype.getRedirectUri = function (reqRedirectUri) {\r\n        if (reqRedirectUri) {\r\n            return reqRedirectUri;\r\n        }\r\n        else if (typeof this.config.auth.redirectUri === \"function\") {\r\n            return this.config.auth.redirectUri();\r\n        }\r\n        return this.config.auth.redirectUri;\r\n    };\r\n    /**\r\n     * Use to get the post logout redirect uri configured in MSAL or null.\r\n     * Evaluates postLogoutredirectUri if its a function, otherwise simply returns its value.\r\n     *\r\n     * @returns {string} post logout redirect URL\r\n     */\r\n    UserAgentApplication.prototype.getPostLogoutRedirectUri = function () {\r\n        if (typeof this.config.auth.postLogoutRedirectUri === \"function\") {\r\n            return this.config.auth.postLogoutRedirectUri();\r\n        }\r\n        return this.config.auth.postLogoutRedirectUri;\r\n    };\r\n    /**\r\n     * Use to get the current {@link Configuration} object in MSAL\r\n     *\r\n     * @returns {@link Configuration}\r\n     */\r\n    UserAgentApplication.prototype.getCurrentConfiguration = function () {\r\n        if (!this.config) {\r\n            throw ClientConfigurationError.createNoSetConfigurationError();\r\n        }\r\n        return this.config;\r\n    };\r\n    /**\r\n     * @ignore\r\n     *\r\n     * Utils function to create the Authentication\r\n     * @param {@link account} account object\r\n     * @param scopes\r\n     *\r\n     * @returns {string} token type: token, id_token or id_token token\r\n     *\r\n     */\r\n    UserAgentApplication.prototype.getTokenType = function (accountObject, scopes) {\r\n        var accountsMatch = Account.compareAccounts(accountObject, this.getAccount());\r\n        return ServerRequestParameters.determineResponseType(accountsMatch, scopes);\r\n    };\r\n    /**\r\n     * @hidden\r\n     * @ignore\r\n     *\r\n     * Sets the cachekeys for and stores the account information in cache\r\n     * @param account\r\n     * @param state\r\n     * @hidden\r\n     */\r\n    UserAgentApplication.prototype.setAccountCache = function (account, state) {\r\n        // Cache acquireTokenAccountKey\r\n        var accountId = account ? this.getAccountId(account) : Constants.no_account;\r\n        var acquireTokenAccountKey = AuthCache.generateAcquireTokenAccountKey(accountId, state);\r\n        this.cacheStorage.setItem(acquireTokenAccountKey, JSON.stringify(account));\r\n    };\r\n    /**\r\n     * @hidden\r\n     * @ignore\r\n     *\r\n     * Sets the cacheKey for and stores the authority information in cache\r\n     * @param state\r\n     * @param authority\r\n     * @hidden\r\n     */\r\n    UserAgentApplication.prototype.setAuthorityCache = function (state, authority) {\r\n        // Cache authorityKey\r\n        var authorityKey = AuthCache.generateAuthorityKey(state);\r\n        this.cacheStorage.setItem(authorityKey, UrlUtils.CanonicalizeUri(authority), this.inCookie);\r\n    };\r\n    /**\r\n     * Updates account, authority, and nonce in cache\r\n     * @param serverAuthenticationRequest\r\n     * @param account\r\n     * @hidden\r\n     * @ignore\r\n     */\r\n    UserAgentApplication.prototype.updateCacheEntries = function (serverAuthenticationRequest, account, isLoginCall, loginStartPage) {\r\n        // Cache Request Originator Page\r\n        if (loginStartPage) {\r\n            this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.LOGIN_REQUEST, serverAuthenticationRequest.state), loginStartPage, this.inCookie);\r\n        }\r\n        // Cache account and authority\r\n        if (isLoginCall) {\r\n            // Cache the state\r\n            this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_LOGIN, serverAuthenticationRequest.state), serverAuthenticationRequest.state, this.inCookie);\r\n        }\r\n        else {\r\n            this.setAccountCache(account, serverAuthenticationRequest.state);\r\n        }\r\n        // Cache authorityKey\r\n        this.setAuthorityCache(serverAuthenticationRequest.state, serverAuthenticationRequest.authority);\r\n        // Cache nonce\r\n        this.cacheStorage.setItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN, serverAuthenticationRequest.state), serverAuthenticationRequest.nonce, this.inCookie);\r\n    };\r\n    /**\r\n     * Returns the unique identifier for the logged in account\r\n     * @param account\r\n     * @hidden\r\n     * @ignore\r\n     */\r\n    UserAgentApplication.prototype.getAccountId = function (account) {\r\n        // return `${account.accountIdentifier}` + Constants.resourceDelimiter + `${account.homeAccountIdentifier}`;\r\n        var accountId;\r\n        if (!StringUtils.isEmpty(account.homeAccountIdentifier)) {\r\n            accountId = account.homeAccountIdentifier;\r\n        }\r\n        else {\r\n            accountId = Constants.no_account;\r\n        }\r\n        return accountId;\r\n    };\r\n    /**\r\n     * @ignore\r\n     * @param extraQueryParameters\r\n     *\r\n     * Construct 'tokenRequest' from the available data in adalIdToken\r\n     */\r\n    UserAgentApplication.prototype.buildIDTokenRequest = function (request) {\r\n        var tokenRequest = {\r\n            scopes: Constants.oidcScopes,\r\n            authority: this.authority,\r\n            account: this.getAccount(),\r\n            extraQueryParameters: request.extraQueryParameters,\r\n            correlationId: request.correlationId\r\n        };\r\n        return tokenRequest;\r\n    };\r\n    /**\r\n     * @ignore\r\n     * @param config\r\n     * @param clientId\r\n     *\r\n     * Construct TelemetryManager from Configuration\r\n     */\r\n    UserAgentApplication.prototype.getTelemetryManagerFromConfig = function (config, clientId) {\r\n        if (!config) { // if unset\r\n            return TelemetryManager.getTelemetrymanagerStub(clientId, this.logger);\r\n        }\r\n        // if set then validate\r\n        var applicationName = config.applicationName, applicationVersion = config.applicationVersion, telemetryEmitter = config.telemetryEmitter;\r\n        if (!applicationName || !applicationVersion || !telemetryEmitter) {\r\n            throw ClientConfigurationError.createTelemetryConfigError(config);\r\n        }\r\n        // if valid then construct\r\n        var telemetryPlatform = {\r\n            applicationName: applicationName,\r\n            applicationVersion: applicationVersion\r\n        };\r\n        var telemetryManagerConfig = {\r\n            platform: telemetryPlatform,\r\n            clientId: clientId\r\n        };\r\n        return new TelemetryManager(telemetryManagerConfig, telemetryEmitter, this.logger);\r\n    };\r\n    return UserAgentApplication;\r\n}());\r\nexport { UserAgentApplication };\r\n//# sourceMappingURL=UserAgentApplication.js.map"]},"metadata":{},"sourceType":"module"}