{"ast":null,"code":"/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nimport * as tslib_1 from \"tslib\";\nimport { Constants, PromptState, BlacklistedEQParams } from \"./Constants\";\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\nimport { ScopeSet } from \"../ScopeSet\";\nimport { StringUtils } from \"./StringUtils\";\nimport { CryptoUtils } from \"./CryptoUtils\";\nimport { TimeUtils } from \"./TimeUtils\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\n/**\r\n * @hidden\r\n */\n\nvar RequestUtils =\n/** @class */\nfunction () {\n  function RequestUtils() {}\n  /**\r\n   * @ignore\r\n   *\r\n   * @param request\r\n   * @param isLoginCall\r\n   * @param cacheStorage\r\n   * @param clientId\r\n   *\r\n   * validates all request parameters and generates a consumable request object\r\n   */\n\n\n  RequestUtils.validateRequest = function (request, isLoginCall, clientId, interactionType) {\n    // Throw error if request is empty for acquire * calls\n    if (!isLoginCall && !request) {\n      throw ClientConfigurationError.createEmptyRequestError();\n    }\n\n    var scopes;\n    var extraQueryParameters;\n\n    if (request) {\n      // if extraScopesToConsent is passed in loginCall, append them to the login request; Validate and filter scopes (the validate function will throw if validation fails)\n      scopes = isLoginCall ? ScopeSet.appendScopes(request.scopes, request.extraScopesToConsent) : request.scopes;\n      ScopeSet.validateInputScope(scopes, !isLoginCall);\n      scopes = ScopeSet.translateClientIdIfSingleScope(scopes, clientId); // validate prompt parameter\n\n      this.validatePromptParameter(request.prompt); // validate extraQueryParameters\n\n      extraQueryParameters = this.validateEQParameters(request.extraQueryParameters, request.claimsRequest); // validate claimsRequest\n\n      this.validateClaimsRequest(request.claimsRequest);\n    } // validate and generate state and correlationId\n\n\n    var state = this.validateAndGenerateState(request && request.state, interactionType);\n    var correlationId = this.validateAndGenerateCorrelationId(request && request.correlationId);\n\n    var validatedRequest = tslib_1.__assign({}, request, {\n      extraQueryParameters: extraQueryParameters,\n      scopes: scopes,\n      state: state,\n      correlationId: correlationId\n    });\n\n    return validatedRequest;\n  };\n  /**\r\n   * @ignore\r\n   *\r\n   * Utility to test if valid prompt value is passed in the request\r\n   * @param request\r\n   */\n\n\n  RequestUtils.validatePromptParameter = function (prompt) {\n    if (prompt) {\n      if ([PromptState.LOGIN, PromptState.SELECT_ACCOUNT, PromptState.CONSENT, PromptState.NONE].indexOf(prompt) < 0) {\n        throw ClientConfigurationError.createInvalidPromptError(prompt);\n      }\n    }\n  };\n  /**\r\n   * @ignore\r\n   *\r\n   * Removes unnecessary or duplicate query parameters from extraQueryParameters\r\n   * @param request\r\n   */\n\n\n  RequestUtils.validateEQParameters = function (extraQueryParameters, claimsRequest) {\n    var eQParams = tslib_1.__assign({}, extraQueryParameters);\n\n    if (!eQParams) {\n      return null;\n    }\n\n    if (claimsRequest) {\n      // this.logger.warning(\"Removed duplicate claims from extraQueryParameters. Please use either the claimsRequest field OR pass as extraQueryParameter - not both.\");\n      delete eQParams[Constants.claims];\n    }\n\n    BlacklistedEQParams.forEach(function (param) {\n      if (eQParams[param]) {\n        // this.logger.warning(\"Removed duplicate \" + param + \" from extraQueryParameters. Please use the \" + param + \" field in request object.\");\n        delete eQParams[param];\n      }\n    });\n    return eQParams;\n  };\n  /**\r\n   * @ignore\r\n   *\r\n   * Validates the claims passed in request is a JSON\r\n   * TODO: More validation will be added when the server team tells us how they have actually implemented claims\r\n   * @param claimsRequest\r\n   */\n\n\n  RequestUtils.validateClaimsRequest = function (claimsRequest) {\n    if (!claimsRequest) {\n      return;\n    }\n\n    try {\n      JSON.parse(claimsRequest);\n    } catch (e) {\n      throw ClientConfigurationError.createClaimsRequestParsingError(e);\n    }\n  };\n  /**\r\n   * @ignore\r\n   *\r\n   * generate unique state per request\r\n   * @param userState User-provided state value\r\n   * @returns State string include library state and user state\r\n   */\n\n\n  RequestUtils.validateAndGenerateState = function (userState, interactionType) {\n    return !StringUtils.isEmpty(userState) ? \"\" + RequestUtils.generateLibraryState(interactionType) + Constants.resourceDelimiter + userState : RequestUtils.generateLibraryState(interactionType);\n  };\n  /**\r\n   * Generates the state value used by the library.\r\n   *\r\n   * @returns Base64 encoded string representing the state\r\n   */\n\n\n  RequestUtils.generateLibraryState = function (interactionType) {\n    var stateObject = {\n      id: CryptoUtils.createNewGuid(),\n      ts: TimeUtils.now(),\n      method: interactionType\n    };\n    var stateString = JSON.stringify(stateObject);\n    return CryptoUtils.base64Encode(stateString);\n  };\n  /**\r\n   * Decodes the state value into a StateObject\r\n   *\r\n   * @param state State value returned in the request\r\n   * @returns Parsed values from the encoded state value\r\n   */\n\n\n  RequestUtils.parseLibraryState = function (state) {\n    var libraryState = decodeURIComponent(state).split(Constants.resourceDelimiter)[0];\n\n    if (CryptoUtils.isGuid(libraryState)) {\n      // If state is guid, assume timestamp is now and is redirect, as redirect should be only method where this can happen.\n      return {\n        id: libraryState,\n        ts: TimeUtils.now(),\n        method: Constants.interactionTypeRedirect\n      };\n    }\n\n    try {\n      var stateString = CryptoUtils.base64Decode(libraryState);\n      var stateObject = JSON.parse(stateString);\n      return stateObject;\n    } catch (e) {\n      throw ClientAuthError.createInvalidStateError(state, null);\n    }\n  };\n  /**\r\n   * @ignore\r\n   *\r\n   * validate correlationId and generate if not valid or not set by the user\r\n   * @param correlationId\r\n   */\n\n\n  RequestUtils.validateAndGenerateCorrelationId = function (correlationId) {\n    // validate user set correlationId or set one for the user if null\n    if (correlationId && !CryptoUtils.isGuid(correlationId)) {\n      throw ClientConfigurationError.createInvalidCorrelationIdError();\n    }\n\n    return CryptoUtils.isGuid(correlationId) ? correlationId : CryptoUtils.createNewGuid();\n  };\n  /**\r\n   * Create a request signature\r\n   * @param request\r\n   */\n\n\n  RequestUtils.createRequestSignature = function (request) {\n    return \"\" + request.scopes.join(\" \").toLowerCase() + Constants.resourceDelimiter + request.authority;\n  };\n\n  return RequestUtils;\n}();\n\nexport { RequestUtils };","map":{"version":3,"sources":["../../src/utils/RequestUtils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\nimport { Constants, PromptState, BlacklistedEQParams } from \"./Constants\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { ScopeSet } from \"../ScopeSet\";\r\nimport { StringUtils } from \"./StringUtils\";\r\nimport { CryptoUtils } from \"./CryptoUtils\";\r\nimport { TimeUtils } from \"./TimeUtils\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\n/**\r\n * @hidden\r\n */\r\nvar RequestUtils = /** @class */ (function () {\r\n    function RequestUtils() {\r\n    }\r\n    /**\r\n     * @ignore\r\n     *\r\n     * @param request\r\n     * @param isLoginCall\r\n     * @param cacheStorage\r\n     * @param clientId\r\n     *\r\n     * validates all request parameters and generates a consumable request object\r\n     */\r\n    RequestUtils.validateRequest = function (request, isLoginCall, clientId, interactionType) {\r\n        // Throw error if request is empty for acquire * calls\r\n        if (!isLoginCall && !request) {\r\n            throw ClientConfigurationError.createEmptyRequestError();\r\n        }\r\n        var scopes;\r\n        var extraQueryParameters;\r\n        if (request) {\r\n            // if extraScopesToConsent is passed in loginCall, append them to the login request; Validate and filter scopes (the validate function will throw if validation fails)\r\n            scopes = isLoginCall ? ScopeSet.appendScopes(request.scopes, request.extraScopesToConsent) : request.scopes;\r\n            ScopeSet.validateInputScope(scopes, !isLoginCall);\r\n            scopes = ScopeSet.translateClientIdIfSingleScope(scopes, clientId);\r\n            // validate prompt parameter\r\n            this.validatePromptParameter(request.prompt);\r\n            // validate extraQueryParameters\r\n            extraQueryParameters = this.validateEQParameters(request.extraQueryParameters, request.claimsRequest);\r\n            // validate claimsRequest\r\n            this.validateClaimsRequest(request.claimsRequest);\r\n        }\r\n        // validate and generate state and correlationId\r\n        var state = this.validateAndGenerateState(request && request.state, interactionType);\r\n        var correlationId = this.validateAndGenerateCorrelationId(request && request.correlationId);\r\n        var validatedRequest = tslib_1.__assign({}, request, { extraQueryParameters: extraQueryParameters,\r\n            scopes: scopes,\r\n            state: state,\r\n            correlationId: correlationId });\r\n        return validatedRequest;\r\n    };\r\n    /**\r\n     * @ignore\r\n     *\r\n     * Utility to test if valid prompt value is passed in the request\r\n     * @param request\r\n     */\r\n    RequestUtils.validatePromptParameter = function (prompt) {\r\n        if (prompt) {\r\n            if ([PromptState.LOGIN, PromptState.SELECT_ACCOUNT, PromptState.CONSENT, PromptState.NONE].indexOf(prompt) < 0) {\r\n                throw ClientConfigurationError.createInvalidPromptError(prompt);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     *\r\n     * Removes unnecessary or duplicate query parameters from extraQueryParameters\r\n     * @param request\r\n     */\r\n    RequestUtils.validateEQParameters = function (extraQueryParameters, claimsRequest) {\r\n        var eQParams = tslib_1.__assign({}, extraQueryParameters);\r\n        if (!eQParams) {\r\n            return null;\r\n        }\r\n        if (claimsRequest) {\r\n            // this.logger.warning(\"Removed duplicate claims from extraQueryParameters. Please use either the claimsRequest field OR pass as extraQueryParameter - not both.\");\r\n            delete eQParams[Constants.claims];\r\n        }\r\n        BlacklistedEQParams.forEach(function (param) {\r\n            if (eQParams[param]) {\r\n                // this.logger.warning(\"Removed duplicate \" + param + \" from extraQueryParameters. Please use the \" + param + \" field in request object.\");\r\n                delete eQParams[param];\r\n            }\r\n        });\r\n        return eQParams;\r\n    };\r\n    /**\r\n     * @ignore\r\n     *\r\n     * Validates the claims passed in request is a JSON\r\n     * TODO: More validation will be added when the server team tells us how they have actually implemented claims\r\n     * @param claimsRequest\r\n     */\r\n    RequestUtils.validateClaimsRequest = function (claimsRequest) {\r\n        if (!claimsRequest) {\r\n            return;\r\n        }\r\n        try {\r\n            JSON.parse(claimsRequest);\r\n        }\r\n        catch (e) {\r\n            throw ClientConfigurationError.createClaimsRequestParsingError(e);\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     *\r\n     * generate unique state per request\r\n     * @param userState User-provided state value\r\n     * @returns State string include library state and user state\r\n     */\r\n    RequestUtils.validateAndGenerateState = function (userState, interactionType) {\r\n        return !StringUtils.isEmpty(userState) ? \"\" + RequestUtils.generateLibraryState(interactionType) + Constants.resourceDelimiter + userState : RequestUtils.generateLibraryState(interactionType);\r\n    };\r\n    /**\r\n     * Generates the state value used by the library.\r\n     *\r\n     * @returns Base64 encoded string representing the state\r\n     */\r\n    RequestUtils.generateLibraryState = function (interactionType) {\r\n        var stateObject = {\r\n            id: CryptoUtils.createNewGuid(),\r\n            ts: TimeUtils.now(),\r\n            method: interactionType\r\n        };\r\n        var stateString = JSON.stringify(stateObject);\r\n        return CryptoUtils.base64Encode(stateString);\r\n    };\r\n    /**\r\n     * Decodes the state value into a StateObject\r\n     *\r\n     * @param state State value returned in the request\r\n     * @returns Parsed values from the encoded state value\r\n     */\r\n    RequestUtils.parseLibraryState = function (state) {\r\n        var libraryState = decodeURIComponent(state).split(Constants.resourceDelimiter)[0];\r\n        if (CryptoUtils.isGuid(libraryState)) {\r\n            // If state is guid, assume timestamp is now and is redirect, as redirect should be only method where this can happen.\r\n            return {\r\n                id: libraryState,\r\n                ts: TimeUtils.now(),\r\n                method: Constants.interactionTypeRedirect\r\n            };\r\n        }\r\n        try {\r\n            var stateString = CryptoUtils.base64Decode(libraryState);\r\n            var stateObject = JSON.parse(stateString);\r\n            return stateObject;\r\n        }\r\n        catch (e) {\r\n            throw ClientAuthError.createInvalidStateError(state, null);\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     *\r\n     * validate correlationId and generate if not valid or not set by the user\r\n     * @param correlationId\r\n     */\r\n    RequestUtils.validateAndGenerateCorrelationId = function (correlationId) {\r\n        // validate user set correlationId or set one for the user if null\r\n        if (correlationId && !CryptoUtils.isGuid(correlationId)) {\r\n            throw ClientConfigurationError.createInvalidCorrelationIdError();\r\n        }\r\n        return CryptoUtils.isGuid(correlationId) ? correlationId : CryptoUtils.createNewGuid();\r\n    };\r\n    /**\r\n     * Create a request signature\r\n     * @param request\r\n     */\r\n    RequestUtils.createRequestSignature = function (request) {\r\n        return \"\" + request.scopes.join(\" \").toLowerCase() + Constants.resourceDelimiter + request.authority;\r\n    };\r\n    return RequestUtils;\r\n}());\r\nexport { RequestUtils };\r\n//# sourceMappingURL=RequestUtils.js.map"]},"metadata":{},"sourceType":"module"}