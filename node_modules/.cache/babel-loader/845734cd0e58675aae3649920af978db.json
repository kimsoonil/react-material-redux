{"ast":null,"code":"/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * @hidden\r\n */\nvar StringUtils =\n/** @class */\nfunction () {\n  function StringUtils() {}\n  /**\r\n   * Check if a string is empty\r\n   *\r\n   * @param str\r\n   */\n\n\n  StringUtils.isEmpty = function (str) {\n    return typeof str === \"undefined\" || !str || 0 === str.length;\n  };\n  /**\r\n   * Check if a string's value is a valid JSON object\r\n   *\r\n   * @param str\r\n   */\n\n\n  StringUtils.validateAndParseJsonCacheKey = function (str) {\n    try {\n      var parsedKey = JSON.parse(str);\n      /**\r\n       * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n       * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n       * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n       *\r\n       */\n\n      return parsedKey && typeof parsedKey === \"object\" ? parsedKey : null;\n    } catch (error) {\n      return null;\n    }\n  };\n\n  return StringUtils;\n}();\n\nexport { StringUtils };","map":{"version":3,"sources":["../../src/utils/StringUtils.ts"],"names":[],"mappings":"AAAA;;;AAGG;;AAIH;;AAEG;AACH,IAAA,WAAA;AAAA;AAAA,YAAA;AAAA,WAAA,WAAA,GAAA,CA6BC;AA5BG;;;;AAIG;;;AACI,EAAA,WAAA,CAAA,OAAA,GAAP,UAAe,GAAf,EAA0B;AACtB,WAAQ,OAAO,GAAP,KAAe,WAAf,IAA8B,CAAC,GAA/B,IAAsC,MAAM,GAAG,CAAC,MAAxD;AACH,GAFM;AAIP;;;;AAIG;;;AACI,EAAA,WAAA,CAAA,4BAAA,GAAP,UAAoC,GAApC,EAA+C;AAC3C,QAAI;AACA,UAAM,SAAS,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAAlB;AACA;;;;;AAKG;;AACH,aAAQ,SAAS,IAAI,OAAO,SAAP,KAAqB,QAAnC,GAA+C,SAA/C,GAA2D,IAAlE;AACH,KATD,CASE,OAAO,KAAP,EAAc;AACZ,aAAO,IAAP;AACH;AACJ,GAbM;;AAcX,SAAA,WAAA;AAAC,CA7BD,EAAA","sourceRoot":"","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * @hidden\r\n */\r\nvar StringUtils = /** @class */ (function () {\r\n    function StringUtils() {\r\n    }\r\n    /**\r\n     * Check if a string is empty\r\n     *\r\n     * @param str\r\n     */\r\n    StringUtils.isEmpty = function (str) {\r\n        return (typeof str === \"undefined\" || !str || 0 === str.length);\r\n    };\r\n    /**\r\n     * Check if a string's value is a valid JSON object\r\n     *\r\n     * @param str\r\n     */\r\n    StringUtils.validateAndParseJsonCacheKey = function (str) {\r\n        try {\r\n            var parsedKey = JSON.parse(str);\r\n            /**\r\n             * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n             * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n             * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n             *\r\n             */\r\n            return (parsedKey && typeof parsedKey === \"object\") ? parsedKey : null;\r\n        }\r\n        catch (error) {\r\n            return null;\r\n        }\r\n    };\r\n    return StringUtils;\r\n}());\r\nexport { StringUtils };\r\n//# sourceMappingURL=StringUtils.js.map"]},"metadata":{},"sourceType":"module"}