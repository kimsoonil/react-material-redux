{"ast":null,"code":"/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nimport { CryptoUtils } from \"./utils/CryptoUtils\";\nimport { SSOTypes, Constants, PromptState, libraryVersion, ResponseTypes } from \"./utils/Constants\";\nimport { StringUtils } from \"./utils/StringUtils\";\nimport { ScopeSet } from \"./ScopeSet\";\n/**\r\n * Nonce: OIDC Nonce definition: https://openid.net/specs/openid-connect-core-1_0.html#IDToken\r\n * State: OAuth Spec: https://tools.ietf.org/html/rfc6749#section-10.12\r\n * @hidden\r\n */\n\nvar ServerRequestParameters =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor\r\n   * @param authority\r\n   * @param clientId\r\n   * @param scope\r\n   * @param responseType\r\n   * @param redirectUri\r\n   * @param state\r\n   */\n  function ServerRequestParameters(authority, clientId, responseType, redirectUri, scopes, state, correlationId) {\n    this.authorityInstance = authority;\n    this.clientId = clientId;\n    this.nonce = CryptoUtils.createNewGuid(); // set scope to clientId if null\n\n    this.scopes = scopes ? scopes.slice() : Constants.oidcScopes;\n    this.scopes = ScopeSet.trimScopes(this.scopes); // set state (already set at top level)\n\n    this.state = state; // set correlationId\n\n    this.correlationId = correlationId; // telemetry information\n\n    this.xClientSku = \"MSAL.JS\";\n    this.xClientVer = libraryVersion();\n    this.responseType = responseType;\n    this.redirectUri = redirectUri;\n  }\n\n  Object.defineProperty(ServerRequestParameters.prototype, \"authority\", {\n    get: function () {\n      return this.authorityInstance ? this.authorityInstance.CanonicalAuthority : null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * Utility to populate QueryParameters and ExtraQueryParameters to ServerRequestParamerers\r\n   * @param request\r\n   * @param serverAuthenticationRequest\r\n   */\n\n  ServerRequestParameters.prototype.populateQueryParams = function (account, request, adalIdTokenObject, silentCall) {\n    var queryParameters = {};\n\n    if (request) {\n      // add the prompt parameter to serverRequestParameters if passed\n      if (request.prompt) {\n        this.promptValue = request.prompt;\n      } // Add claims challenge to serverRequestParameters if passed\n\n\n      if (request.claimsRequest) {\n        this.claimsValue = request.claimsRequest;\n      } // if the developer provides one of these, give preference to developer choice\n\n\n      if (ServerRequestParameters.isSSOParam(request)) {\n        queryParameters = this.constructUnifiedCacheQueryParameter(request, null);\n      }\n    }\n\n    if (adalIdTokenObject) {\n      queryParameters = this.constructUnifiedCacheQueryParameter(null, adalIdTokenObject);\n    }\n    /*\r\n     * adds sid/login_hint if not populated\r\n     * this.logger.verbose(\"Calling addHint parameters\");\r\n     */\n\n\n    queryParameters = this.addHintParameters(account, queryParameters); // sanity check for developer passed extraQueryParameters\n\n    var eQParams = request ? request.extraQueryParameters : null; // Populate the extraQueryParameters to be sent to the server\n\n    this.queryParameters = ServerRequestParameters.generateQueryParametersString(queryParameters);\n    this.extraQueryParameters = ServerRequestParameters.generateQueryParametersString(eQParams, silentCall);\n  }; // #region QueryParam helpers\n\n  /**\r\n   * Constructs extraQueryParameters to be sent to the server for the AuthenticationParameters set by the developer\r\n   * in any login() or acquireToken() calls\r\n   * @param idTokenObject\r\n   * @param extraQueryParameters\r\n   * @param sid\r\n   * @param loginHint\r\n   */\n  // TODO: check how this behaves when domain_hint only is sent in extraparameters and idToken has no upn.\n\n\n  ServerRequestParameters.prototype.constructUnifiedCacheQueryParameter = function (request, idTokenObject) {\n    // preference order: account > sid > login_hint\n    var ssoType;\n    var ssoData;\n    var serverReqParam = {}; // if account info is passed, account.sid > account.login_hint\n\n    if (request) {\n      if (request.account) {\n        var account = request.account;\n\n        if (account.sid) {\n          ssoType = SSOTypes.SID;\n          ssoData = account.sid;\n        } else if (account.userName) {\n          ssoType = SSOTypes.LOGIN_HINT;\n          ssoData = account.userName;\n        }\n      } // sid from request\n      else if (request.sid) {\n          ssoType = SSOTypes.SID;\n          ssoData = request.sid;\n        } // loginHint from request\n        else if (request.loginHint) {\n            ssoType = SSOTypes.LOGIN_HINT;\n            ssoData = request.loginHint;\n          }\n    } // adalIdToken retrieved from cache\n    else if (idTokenObject) {\n        if (idTokenObject.hasOwnProperty(Constants.upn)) {\n          ssoType = SSOTypes.ID_TOKEN;\n          ssoData = idTokenObject.upn;\n        }\n      }\n\n    serverReqParam = this.addSSOParameter(ssoType, ssoData);\n    return serverReqParam;\n  };\n  /**\r\n   * @hidden\r\n   *\r\n   * Adds login_hint to authorization URL which is used to pre-fill the username field of sign in page for the user if known ahead of time\r\n   * domain_hint if added skips the email based discovery process of the user - only supported for interactive calls in implicit_flow\r\n   * domain_req utid received as part of the clientInfo\r\n   * login_req uid received as part of clientInfo\r\n   * Also does a sanity check for extraQueryParameters passed by the user to ensure no repeat queryParameters\r\n   *\r\n   * @param {@link Account} account - Account for which the token is requested\r\n   * @param queryparams\r\n   * @param {@link ServerRequestParameters}\r\n   * @ignore\r\n   */\n\n\n  ServerRequestParameters.prototype.addHintParameters = function (account, qParams) {\n    /*\r\n     * This is a final check for all queryParams added so far; preference order: sid > login_hint\r\n     * sid cannot be passed along with login_hint or domain_hint, hence we check both are not populated yet in queryParameters\r\n     */\n    if (account && !qParams[SSOTypes.SID]) {\n      // sid - populate only if login_hint is not already populated and the account has sid\n      var populateSID = !qParams[SSOTypes.LOGIN_HINT] && account.sid && this.promptValue === PromptState.NONE;\n\n      if (populateSID) {\n        qParams = this.addSSOParameter(SSOTypes.SID, account.sid, qParams);\n      } // login_hint - account.userName\n      else {\n          var populateLoginHint = !qParams[SSOTypes.LOGIN_HINT] && account.userName && !StringUtils.isEmpty(account.userName);\n\n          if (populateLoginHint) {\n            qParams = this.addSSOParameter(SSOTypes.LOGIN_HINT, account.userName, qParams);\n          }\n        }\n    }\n\n    return qParams;\n  };\n  /**\r\n   * Add SID to extraQueryParameters\r\n   * @param sid\r\n   */\n\n\n  ServerRequestParameters.prototype.addSSOParameter = function (ssoType, ssoData, ssoParam) {\n    if (!ssoParam) {\n      ssoParam = {};\n    }\n\n    if (!ssoData) {\n      return ssoParam;\n    }\n\n    switch (ssoType) {\n      case SSOTypes.SID:\n        {\n          ssoParam[SSOTypes.SID] = ssoData;\n          break;\n        }\n\n      case SSOTypes.ID_TOKEN:\n        {\n          ssoParam[SSOTypes.LOGIN_HINT] = ssoData;\n          break;\n        }\n\n      case SSOTypes.LOGIN_HINT:\n        {\n          ssoParam[SSOTypes.LOGIN_HINT] = ssoData;\n          break;\n        }\n    }\n\n    return ssoParam;\n  };\n  /**\r\n   * Utility to generate a QueryParameterString from a Key-Value mapping of extraQueryParameters passed\r\n   * @param extraQueryParameters\r\n   */\n\n\n  ServerRequestParameters.generateQueryParametersString = function (queryParameters, silentCall) {\n    var paramsString = null;\n\n    if (queryParameters) {\n      Object.keys(queryParameters).forEach(function (key) {\n        // sid cannot be passed along with login_hint or domain_hint\n        if (key === Constants.domain_hint && (silentCall || queryParameters[SSOTypes.SID])) {\n          return;\n        }\n\n        if (paramsString == null) {\n          paramsString = key + \"=\" + encodeURIComponent(queryParameters[key]);\n        } else {\n          paramsString += \"&\" + key + \"=\" + encodeURIComponent(queryParameters[key]);\n        }\n      });\n    }\n\n    return paramsString;\n  }; // #endregion\n\n  /**\r\n   * Check to see if there are SSO params set in the Request\r\n   * @param request\r\n   */\n\n\n  ServerRequestParameters.isSSOParam = function (request) {\n    return request && (request.account || request.sid || request.loginHint);\n  };\n  /**\r\n   * Returns the correct response_type string attribute for an acquireToken request configuration\r\n   * @param accountsMatch boolean: Determines whether the account in the request matches the cached account\r\n   * @param scopes Array<string>: AuthenticationRequest scopes configuration\r\n   * @param loginScopesOnly boolean: True if the scopes array ONLY contains the clientId or any combination of OIDC scopes, without resource scopes\r\n   */\n\n\n  ServerRequestParameters.determineResponseType = function (accountsMatch, scopes) {\n    // Supports getting an id_token by sending in clientId as only scope or OIDC scopes as only scopes\n    if (ScopeSet.onlyContainsOidcScopes(scopes)) {\n      return ResponseTypes.id_token;\n    } // If accounts match, check if OIDC scopes are included, otherwise return id_token_token\n\n\n    return accountsMatch ? this.responseTypeForMatchingAccounts(scopes) : ResponseTypes.id_token_token;\n  };\n  /**\r\n   * Returns the correct response_type string attribute for an acquireToken request configuration that contains an\r\n   * account that matches the account in the MSAL cache.\r\n   * @param scopes Array<string>: AuthenticationRequest scopes configuration\r\n   */\n\n\n  ServerRequestParameters.responseTypeForMatchingAccounts = function (scopes) {\n    // Opt-into also requesting an ID token by sending in 'openid', 'profile' or both along with resource scopes when login is not necessary.\n    return ScopeSet.containsAnyOidcScopes(scopes) ? ResponseTypes.id_token_token : ResponseTypes.token;\n  };\n\n  return ServerRequestParameters;\n}();\n\nexport { ServerRequestParameters };","map":{"version":3,"sources":["../src/ServerRequestParameters.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { CryptoUtils } from \"./utils/CryptoUtils\";\r\nimport { SSOTypes, Constants, PromptState, libraryVersion, ResponseTypes } from \"./utils/Constants\";\r\nimport { StringUtils } from \"./utils/StringUtils\";\r\nimport { ScopeSet } from \"./ScopeSet\";\r\n/**\r\n * Nonce: OIDC Nonce definition: https://openid.net/specs/openid-connect-core-1_0.html#IDToken\r\n * State: OAuth Spec: https://tools.ietf.org/html/rfc6749#section-10.12\r\n * @hidden\r\n */\r\nvar ServerRequestParameters = /** @class */ (function () {\r\n    /**\r\n     * Constructor\r\n     * @param authority\r\n     * @param clientId\r\n     * @param scope\r\n     * @param responseType\r\n     * @param redirectUri\r\n     * @param state\r\n     */\r\n    function ServerRequestParameters(authority, clientId, responseType, redirectUri, scopes, state, correlationId) {\r\n        this.authorityInstance = authority;\r\n        this.clientId = clientId;\r\n        this.nonce = CryptoUtils.createNewGuid();\r\n        // set scope to clientId if null\r\n        this.scopes = scopes ? scopes.slice() : Constants.oidcScopes;\r\n        this.scopes = ScopeSet.trimScopes(this.scopes);\r\n        // set state (already set at top level)\r\n        this.state = state;\r\n        // set correlationId\r\n        this.correlationId = correlationId;\r\n        // telemetry information\r\n        this.xClientSku = \"MSAL.JS\";\r\n        this.xClientVer = libraryVersion();\r\n        this.responseType = responseType;\r\n        this.redirectUri = redirectUri;\r\n    }\r\n    Object.defineProperty(ServerRequestParameters.prototype, \"authority\", {\r\n        get: function () {\r\n            return this.authorityInstance ? this.authorityInstance.CanonicalAuthority : null;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @hidden\r\n     * @ignore\r\n     *\r\n     * Utility to populate QueryParameters and ExtraQueryParameters to ServerRequestParamerers\r\n     * @param request\r\n     * @param serverAuthenticationRequest\r\n     */\r\n    ServerRequestParameters.prototype.populateQueryParams = function (account, request, adalIdTokenObject, silentCall) {\r\n        var queryParameters = {};\r\n        if (request) {\r\n            // add the prompt parameter to serverRequestParameters if passed\r\n            if (request.prompt) {\r\n                this.promptValue = request.prompt;\r\n            }\r\n            // Add claims challenge to serverRequestParameters if passed\r\n            if (request.claimsRequest) {\r\n                this.claimsValue = request.claimsRequest;\r\n            }\r\n            // if the developer provides one of these, give preference to developer choice\r\n            if (ServerRequestParameters.isSSOParam(request)) {\r\n                queryParameters = this.constructUnifiedCacheQueryParameter(request, null);\r\n            }\r\n        }\r\n        if (adalIdTokenObject) {\r\n            queryParameters = this.constructUnifiedCacheQueryParameter(null, adalIdTokenObject);\r\n        }\r\n        /*\r\n         * adds sid/login_hint if not populated\r\n         * this.logger.verbose(\"Calling addHint parameters\");\r\n         */\r\n        queryParameters = this.addHintParameters(account, queryParameters);\r\n        // sanity check for developer passed extraQueryParameters\r\n        var eQParams = request ? request.extraQueryParameters : null;\r\n        // Populate the extraQueryParameters to be sent to the server\r\n        this.queryParameters = ServerRequestParameters.generateQueryParametersString(queryParameters);\r\n        this.extraQueryParameters = ServerRequestParameters.generateQueryParametersString(eQParams, silentCall);\r\n    };\r\n    // #region QueryParam helpers\r\n    /**\r\n     * Constructs extraQueryParameters to be sent to the server for the AuthenticationParameters set by the developer\r\n     * in any login() or acquireToken() calls\r\n     * @param idTokenObject\r\n     * @param extraQueryParameters\r\n     * @param sid\r\n     * @param loginHint\r\n     */\r\n    // TODO: check how this behaves when domain_hint only is sent in extraparameters and idToken has no upn.\r\n    ServerRequestParameters.prototype.constructUnifiedCacheQueryParameter = function (request, idTokenObject) {\r\n        // preference order: account > sid > login_hint\r\n        var ssoType;\r\n        var ssoData;\r\n        var serverReqParam = {};\r\n        // if account info is passed, account.sid > account.login_hint\r\n        if (request) {\r\n            if (request.account) {\r\n                var account = request.account;\r\n                if (account.sid) {\r\n                    ssoType = SSOTypes.SID;\r\n                    ssoData = account.sid;\r\n                }\r\n                else if (account.userName) {\r\n                    ssoType = SSOTypes.LOGIN_HINT;\r\n                    ssoData = account.userName;\r\n                }\r\n            }\r\n            // sid from request\r\n            else if (request.sid) {\r\n                ssoType = SSOTypes.SID;\r\n                ssoData = request.sid;\r\n            }\r\n            // loginHint from request\r\n            else if (request.loginHint) {\r\n                ssoType = SSOTypes.LOGIN_HINT;\r\n                ssoData = request.loginHint;\r\n            }\r\n        }\r\n        // adalIdToken retrieved from cache\r\n        else if (idTokenObject) {\r\n            if (idTokenObject.hasOwnProperty(Constants.upn)) {\r\n                ssoType = SSOTypes.ID_TOKEN;\r\n                ssoData = idTokenObject.upn;\r\n            }\r\n        }\r\n        serverReqParam = this.addSSOParameter(ssoType, ssoData);\r\n        return serverReqParam;\r\n    };\r\n    /**\r\n     * @hidden\r\n     *\r\n     * Adds login_hint to authorization URL which is used to pre-fill the username field of sign in page for the user if known ahead of time\r\n     * domain_hint if added skips the email based discovery process of the user - only supported for interactive calls in implicit_flow\r\n     * domain_req utid received as part of the clientInfo\r\n     * login_req uid received as part of clientInfo\r\n     * Also does a sanity check for extraQueryParameters passed by the user to ensure no repeat queryParameters\r\n     *\r\n     * @param {@link Account} account - Account for which the token is requested\r\n     * @param queryparams\r\n     * @param {@link ServerRequestParameters}\r\n     * @ignore\r\n     */\r\n    ServerRequestParameters.prototype.addHintParameters = function (account, qParams) {\r\n        /*\r\n         * This is a final check for all queryParams added so far; preference order: sid > login_hint\r\n         * sid cannot be passed along with login_hint or domain_hint, hence we check both are not populated yet in queryParameters\r\n         */\r\n        if (account && !qParams[SSOTypes.SID]) {\r\n            // sid - populate only if login_hint is not already populated and the account has sid\r\n            var populateSID = !qParams[SSOTypes.LOGIN_HINT] && account.sid && this.promptValue === PromptState.NONE;\r\n            if (populateSID) {\r\n                qParams = this.addSSOParameter(SSOTypes.SID, account.sid, qParams);\r\n            }\r\n            // login_hint - account.userName\r\n            else {\r\n                var populateLoginHint = !qParams[SSOTypes.LOGIN_HINT] && account.userName && !StringUtils.isEmpty(account.userName);\r\n                if (populateLoginHint) {\r\n                    qParams = this.addSSOParameter(SSOTypes.LOGIN_HINT, account.userName, qParams);\r\n                }\r\n            }\r\n        }\r\n        return qParams;\r\n    };\r\n    /**\r\n     * Add SID to extraQueryParameters\r\n     * @param sid\r\n     */\r\n    ServerRequestParameters.prototype.addSSOParameter = function (ssoType, ssoData, ssoParam) {\r\n        if (!ssoParam) {\r\n            ssoParam = {};\r\n        }\r\n        if (!ssoData) {\r\n            return ssoParam;\r\n        }\r\n        switch (ssoType) {\r\n            case SSOTypes.SID: {\r\n                ssoParam[SSOTypes.SID] = ssoData;\r\n                break;\r\n            }\r\n            case SSOTypes.ID_TOKEN: {\r\n                ssoParam[SSOTypes.LOGIN_HINT] = ssoData;\r\n                break;\r\n            }\r\n            case SSOTypes.LOGIN_HINT: {\r\n                ssoParam[SSOTypes.LOGIN_HINT] = ssoData;\r\n                break;\r\n            }\r\n        }\r\n        return ssoParam;\r\n    };\r\n    /**\r\n     * Utility to generate a QueryParameterString from a Key-Value mapping of extraQueryParameters passed\r\n     * @param extraQueryParameters\r\n     */\r\n    ServerRequestParameters.generateQueryParametersString = function (queryParameters, silentCall) {\r\n        var paramsString = null;\r\n        if (queryParameters) {\r\n            Object.keys(queryParameters).forEach(function (key) {\r\n                // sid cannot be passed along with login_hint or domain_hint\r\n                if (key === Constants.domain_hint && (silentCall || queryParameters[SSOTypes.SID])) {\r\n                    return;\r\n                }\r\n                if (paramsString == null) {\r\n                    paramsString = key + \"=\" + encodeURIComponent(queryParameters[key]);\r\n                }\r\n                else {\r\n                    paramsString += \"&\" + key + \"=\" + encodeURIComponent(queryParameters[key]);\r\n                }\r\n            });\r\n        }\r\n        return paramsString;\r\n    };\r\n    // #endregion\r\n    /**\r\n     * Check to see if there are SSO params set in the Request\r\n     * @param request\r\n     */\r\n    ServerRequestParameters.isSSOParam = function (request) {\r\n        return request && (request.account || request.sid || request.loginHint);\r\n    };\r\n    /**\r\n     * Returns the correct response_type string attribute for an acquireToken request configuration\r\n     * @param accountsMatch boolean: Determines whether the account in the request matches the cached account\r\n     * @param scopes Array<string>: AuthenticationRequest scopes configuration\r\n     * @param loginScopesOnly boolean: True if the scopes array ONLY contains the clientId or any combination of OIDC scopes, without resource scopes\r\n     */\r\n    ServerRequestParameters.determineResponseType = function (accountsMatch, scopes) {\r\n        // Supports getting an id_token by sending in clientId as only scope or OIDC scopes as only scopes\r\n        if (ScopeSet.onlyContainsOidcScopes(scopes)) {\r\n            return ResponseTypes.id_token;\r\n        }\r\n        // If accounts match, check if OIDC scopes are included, otherwise return id_token_token\r\n        return (accountsMatch) ? this.responseTypeForMatchingAccounts(scopes) : ResponseTypes.id_token_token;\r\n    };\r\n    /**\r\n     * Returns the correct response_type string attribute for an acquireToken request configuration that contains an\r\n     * account that matches the account in the MSAL cache.\r\n     * @param scopes Array<string>: AuthenticationRequest scopes configuration\r\n     */\r\n    ServerRequestParameters.responseTypeForMatchingAccounts = function (scopes) {\r\n        // Opt-into also requesting an ID token by sending in 'openid', 'profile' or both along with resource scopes when login is not necessary.\r\n        return (ScopeSet.containsAnyOidcScopes(scopes)) ? ResponseTypes.id_token_token : ResponseTypes.token;\r\n    };\r\n    return ServerRequestParameters;\r\n}());\r\nexport { ServerRequestParameters };\r\n//# sourceMappingURL=ServerRequestParameters.js.map"]},"metadata":{},"sourceType":"module"}