{"ast":null,"code":"/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nimport * as tslib_1 from \"tslib\";\nimport DefaultEvent from \"./DefaultEvent\";\nimport { libraryVersion, Constants } from \"../utils/Constants\";\nimport ApiEvent from \"./ApiEvent\";\nimport HttpEvent from \"./HttpEvent\";\n\nvar TelemetryManager =\n/** @class */\nfunction () {\n  function TelemetryManager(config, telemetryEmitter, logger) {\n    // correlation Id to list of events\n    this.completedEvents = {}; // event key to event\n\n    this.inProgressEvents = {}; // correlation id to map of eventname to count\n\n    this.eventCountByCorrelationId = {}; // Implement after API EVENT\n\n    this.onlySendFailureTelemetry = false; // TODO THROW if bad options\n\n    this.telemetryPlatform = tslib_1.__assign({\n      sdk: Constants.libraryName,\n      sdkVersion: libraryVersion(),\n      networkInformation: {\n        // @ts-ignore\n        connectionSpeed: typeof navigator !== \"undefined\" && navigator.connection && navigator.connection.effectiveType\n      }\n    }, config.platform);\n    this.clientId = config.clientId;\n    this.onlySendFailureTelemetry = config.onlySendFailureTelemetry;\n    /*\r\n     * TODO, when i get to wiring this through, think about what it means if\r\n     * a developer does not implement telem at all, we still instrument, but telemetryEmitter can be\r\n     * optional?\r\n     */\n\n    this.telemetryEmitter = telemetryEmitter;\n    this.logger = logger;\n  }\n\n  TelemetryManager.getTelemetrymanagerStub = function (clientId, logger) {\n    var applicationName = \"UnSetStub\";\n    var applicationVersion = \"0.0\";\n\n    var telemetryEmitter = function () {};\n\n    var telemetryPlatform = {\n      applicationName: applicationName,\n      applicationVersion: applicationVersion\n    };\n    var telemetryManagerConfig = {\n      platform: telemetryPlatform,\n      clientId: clientId\n    };\n    return new this(telemetryManagerConfig, telemetryEmitter, logger);\n  };\n\n  TelemetryManager.prototype.startEvent = function (event) {\n    this.logger.verbose(\"Telemetry Event started: \" + event.key);\n\n    if (!this.telemetryEmitter) {\n      return;\n    }\n\n    event.start();\n    this.inProgressEvents[event.key] = event;\n  };\n\n  TelemetryManager.prototype.stopEvent = function (event) {\n    this.logger.verbose(\"Telemetry Event stopped: \" + event.key);\n\n    if (!this.telemetryEmitter || !this.inProgressEvents[event.key]) {\n      return;\n    }\n\n    event.stop();\n    this.incrementEventCount(event);\n    var completedEvents = this.completedEvents[event.telemetryCorrelationId];\n    this.completedEvents[event.telemetryCorrelationId] = (completedEvents || []).concat([event]);\n    delete this.inProgressEvents[event.key];\n  };\n\n  TelemetryManager.prototype.flush = function (correlationId) {\n    var _this = this;\n\n    this.logger.verbose(\"Flushing telemetry events: \" + correlationId); // If there is only unfinished events should this still return them?\n\n    if (!this.telemetryEmitter || !this.completedEvents[correlationId]) {\n      return;\n    }\n\n    var orphanedEvents = this.getOrphanedEvents(correlationId);\n    orphanedEvents.forEach(function (event) {\n      return _this.incrementEventCount(event);\n    });\n    var eventsToFlush = this.completedEvents[correlationId].concat(orphanedEvents);\n    delete this.completedEvents[correlationId];\n    var eventCountsToFlush = this.eventCountByCorrelationId[correlationId];\n    delete this.eventCountByCorrelationId[correlationId]; // TODO add funcitonality for onlyFlushFailures after implementing api event? ??\n\n    if (!eventsToFlush || !eventsToFlush.length) {\n      return;\n    }\n\n    var defaultEvent = new DefaultEvent(this.telemetryPlatform, correlationId, this.clientId, eventCountsToFlush);\n    var eventsWithDefaultEvent = eventsToFlush.concat([defaultEvent]);\n    this.telemetryEmitter(eventsWithDefaultEvent.map(function (e) {\n      return e.get();\n    }));\n  };\n\n  TelemetryManager.prototype.createAndStartApiEvent = function (correlationId, apiEventIdentifier) {\n    var apiEvent = new ApiEvent(correlationId, this.logger.isPiiLoggingEnabled(), apiEventIdentifier);\n    this.startEvent(apiEvent);\n    return apiEvent;\n  };\n\n  TelemetryManager.prototype.stopAndFlushApiEvent = function (correlationId, apiEvent, wasSuccessful, errorCode) {\n    apiEvent.wasSuccessful = wasSuccessful;\n\n    if (errorCode) {\n      apiEvent.apiErrorCode = errorCode;\n    }\n\n    this.stopEvent(apiEvent);\n    this.flush(correlationId);\n  };\n\n  TelemetryManager.prototype.createAndStartHttpEvent = function (correlation, httpMethod, url, eventLabel) {\n    var httpEvent = new HttpEvent(correlation, eventLabel);\n    httpEvent.url = url;\n    httpEvent.httpMethod = httpMethod;\n    this.startEvent(httpEvent);\n    return httpEvent;\n  };\n\n  TelemetryManager.prototype.incrementEventCount = function (event) {\n    var _a;\n    /*\r\n     * TODO, name cache event different?\r\n     * if type is cache event, change name\r\n     */\n\n\n    var eventName = event.eventName;\n    var eventCount = this.eventCountByCorrelationId[event.telemetryCorrelationId];\n\n    if (!eventCount) {\n      this.eventCountByCorrelationId[event.telemetryCorrelationId] = (_a = {}, _a[eventName] = 1, _a);\n    } else {\n      eventCount[eventName] = eventCount[eventName] ? eventCount[eventName] + 1 : 1;\n    }\n  };\n\n  TelemetryManager.prototype.getOrphanedEvents = function (correlationId) {\n    var _this = this;\n\n    return Object.keys(this.inProgressEvents).reduce(function (memo, eventKey) {\n      if (eventKey.indexOf(correlationId) !== -1) {\n        var event_1 = _this.inProgressEvents[eventKey];\n        delete _this.inProgressEvents[eventKey];\n        return memo.concat([event_1]);\n      }\n\n      return memo;\n    }, []);\n  };\n\n  return TelemetryManager;\n}();\n\nexport default TelemetryManager;","map":{"version":3,"sources":["../../src/telemetry/TelemetryManager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\nimport DefaultEvent from \"./DefaultEvent\";\r\nimport { libraryVersion, Constants } from \"../utils/Constants\";\r\nimport ApiEvent from \"./ApiEvent\";\r\nimport HttpEvent from \"./HttpEvent\";\r\nvar TelemetryManager = /** @class */ (function () {\r\n    function TelemetryManager(config, telemetryEmitter, logger) {\r\n        // correlation Id to list of events\r\n        this.completedEvents = {};\r\n        // event key to event\r\n        this.inProgressEvents = {};\r\n        // correlation id to map of eventname to count\r\n        this.eventCountByCorrelationId = {};\r\n        // Implement after API EVENT\r\n        this.onlySendFailureTelemetry = false;\r\n        // TODO THROW if bad options\r\n        this.telemetryPlatform = tslib_1.__assign({ sdk: Constants.libraryName, sdkVersion: libraryVersion(), networkInformation: {\r\n                // @ts-ignore\r\n                connectionSpeed: typeof navigator !== \"undefined\" && navigator.connection && navigator.connection.effectiveType\r\n            } }, config.platform);\r\n        this.clientId = config.clientId;\r\n        this.onlySendFailureTelemetry = config.onlySendFailureTelemetry;\r\n        /*\r\n         * TODO, when i get to wiring this through, think about what it means if\r\n         * a developer does not implement telem at all, we still instrument, but telemetryEmitter can be\r\n         * optional?\r\n         */\r\n        this.telemetryEmitter = telemetryEmitter;\r\n        this.logger = logger;\r\n    }\r\n    TelemetryManager.getTelemetrymanagerStub = function (clientId, logger) {\r\n        var applicationName = \"UnSetStub\";\r\n        var applicationVersion = \"0.0\";\r\n        var telemetryEmitter = function () { };\r\n        var telemetryPlatform = {\r\n            applicationName: applicationName,\r\n            applicationVersion: applicationVersion\r\n        };\r\n        var telemetryManagerConfig = {\r\n            platform: telemetryPlatform,\r\n            clientId: clientId\r\n        };\r\n        return new this(telemetryManagerConfig, telemetryEmitter, logger);\r\n    };\r\n    TelemetryManager.prototype.startEvent = function (event) {\r\n        this.logger.verbose(\"Telemetry Event started: \" + event.key);\r\n        if (!this.telemetryEmitter) {\r\n            return;\r\n        }\r\n        event.start();\r\n        this.inProgressEvents[event.key] = event;\r\n    };\r\n    TelemetryManager.prototype.stopEvent = function (event) {\r\n        this.logger.verbose(\"Telemetry Event stopped: \" + event.key);\r\n        if (!this.telemetryEmitter || !this.inProgressEvents[event.key]) {\r\n            return;\r\n        }\r\n        event.stop();\r\n        this.incrementEventCount(event);\r\n        var completedEvents = this.completedEvents[event.telemetryCorrelationId];\r\n        this.completedEvents[event.telemetryCorrelationId] = (completedEvents || []).concat([event]);\r\n        delete this.inProgressEvents[event.key];\r\n    };\r\n    TelemetryManager.prototype.flush = function (correlationId) {\r\n        var _this = this;\r\n        this.logger.verbose(\"Flushing telemetry events: \" + correlationId);\r\n        // If there is only unfinished events should this still return them?\r\n        if (!this.telemetryEmitter || !this.completedEvents[correlationId]) {\r\n            return;\r\n        }\r\n        var orphanedEvents = this.getOrphanedEvents(correlationId);\r\n        orphanedEvents.forEach(function (event) { return _this.incrementEventCount(event); });\r\n        var eventsToFlush = this.completedEvents[correlationId].concat(orphanedEvents);\r\n        delete this.completedEvents[correlationId];\r\n        var eventCountsToFlush = this.eventCountByCorrelationId[correlationId];\r\n        delete this.eventCountByCorrelationId[correlationId];\r\n        // TODO add funcitonality for onlyFlushFailures after implementing api event? ??\r\n        if (!eventsToFlush || !eventsToFlush.length) {\r\n            return;\r\n        }\r\n        var defaultEvent = new DefaultEvent(this.telemetryPlatform, correlationId, this.clientId, eventCountsToFlush);\r\n        var eventsWithDefaultEvent = eventsToFlush.concat([defaultEvent]);\r\n        this.telemetryEmitter(eventsWithDefaultEvent.map(function (e) { return e.get(); }));\r\n    };\r\n    TelemetryManager.prototype.createAndStartApiEvent = function (correlationId, apiEventIdentifier) {\r\n        var apiEvent = new ApiEvent(correlationId, this.logger.isPiiLoggingEnabled(), apiEventIdentifier);\r\n        this.startEvent(apiEvent);\r\n        return apiEvent;\r\n    };\r\n    TelemetryManager.prototype.stopAndFlushApiEvent = function (correlationId, apiEvent, wasSuccessful, errorCode) {\r\n        apiEvent.wasSuccessful = wasSuccessful;\r\n        if (errorCode) {\r\n            apiEvent.apiErrorCode = errorCode;\r\n        }\r\n        this.stopEvent(apiEvent);\r\n        this.flush(correlationId);\r\n    };\r\n    TelemetryManager.prototype.createAndStartHttpEvent = function (correlation, httpMethod, url, eventLabel) {\r\n        var httpEvent = new HttpEvent(correlation, eventLabel);\r\n        httpEvent.url = url;\r\n        httpEvent.httpMethod = httpMethod;\r\n        this.startEvent(httpEvent);\r\n        return httpEvent;\r\n    };\r\n    TelemetryManager.prototype.incrementEventCount = function (event) {\r\n        var _a;\r\n        /*\r\n         * TODO, name cache event different?\r\n         * if type is cache event, change name\r\n         */\r\n        var eventName = event.eventName;\r\n        var eventCount = this.eventCountByCorrelationId[event.telemetryCorrelationId];\r\n        if (!eventCount) {\r\n            this.eventCountByCorrelationId[event.telemetryCorrelationId] = (_a = {},\r\n                _a[eventName] = 1,\r\n                _a);\r\n        }\r\n        else {\r\n            eventCount[eventName] = eventCount[eventName] ? eventCount[eventName] + 1 : 1;\r\n        }\r\n    };\r\n    TelemetryManager.prototype.getOrphanedEvents = function (correlationId) {\r\n        var _this = this;\r\n        return Object.keys(this.inProgressEvents)\r\n            .reduce(function (memo, eventKey) {\r\n            if (eventKey.indexOf(correlationId) !== -1) {\r\n                var event_1 = _this.inProgressEvents[eventKey];\r\n                delete _this.inProgressEvents[eventKey];\r\n                return memo.concat([event_1]);\r\n            }\r\n            return memo;\r\n        }, []);\r\n    };\r\n    return TelemetryManager;\r\n}());\r\nexport default TelemetryManager;\r\n//# sourceMappingURL=TelemetryManager.js.map"]},"metadata":{},"sourceType":"module"}