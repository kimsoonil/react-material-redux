{"ast":null,"code":"/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nimport * as tslib_1 from \"tslib\";\nimport { Constants, PersistentCacheKeys, TemporaryCacheKeys, ErrorCacheKeys, ServerHashParamKeys } from \"../utils/Constants\";\nimport { AccessTokenCacheItem } from \"./AccessTokenCacheItem\";\nimport { BrowserStorage } from \"./BrowserStorage\";\nimport { RequestUtils } from \"../utils/RequestUtils\";\nimport { StringUtils } from \"../utils/StringUtils\";\n/**\r\n * @hidden\r\n */\n\nvar AuthCache =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(AuthCache, _super);\n\n  function AuthCache(clientId, cacheLocation, storeAuthStateInCookie) {\n    var _this = _super.call(this, cacheLocation) || this;\n\n    _this.clientId = clientId; // This is hardcoded to true for now. We may make this configurable in the future\n\n    _this.rollbackEnabled = true;\n\n    _this.migrateCacheEntries(storeAuthStateInCookie);\n\n    return _this;\n  }\n  /**\r\n   * Support roll back to old cache schema until the next major release: true by default now\r\n   * @param storeAuthStateInCookie\r\n   */\n\n\n  AuthCache.prototype.migrateCacheEntries = function (storeAuthStateInCookie) {\n    var _this = this;\n\n    var idTokenKey = Constants.cachePrefix + \".\" + PersistentCacheKeys.IDTOKEN;\n    var clientInfoKey = Constants.cachePrefix + \".\" + PersistentCacheKeys.CLIENT_INFO;\n    var errorKey = Constants.cachePrefix + \".\" + ErrorCacheKeys.ERROR;\n    var errorDescKey = Constants.cachePrefix + \".\" + ErrorCacheKeys.ERROR_DESC;\n\n    var idTokenValue = _super.prototype.getItem.call(this, idTokenKey);\n\n    var clientInfoValue = _super.prototype.getItem.call(this, clientInfoKey);\n\n    var errorValue = _super.prototype.getItem.call(this, errorKey);\n\n    var errorDescValue = _super.prototype.getItem.call(this, errorDescKey);\n\n    var values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n    var keysToMigrate = [PersistentCacheKeys.IDTOKEN, PersistentCacheKeys.CLIENT_INFO, ErrorCacheKeys.ERROR, ErrorCacheKeys.ERROR_DESC];\n    keysToMigrate.forEach(function (cacheKey, index) {\n      return _this.duplicateCacheEntry(cacheKey, values[index], storeAuthStateInCookie);\n    });\n  };\n  /**\r\n   * Utility function to help with roll back keys\r\n   * @param newKey\r\n   * @param value\r\n   * @param storeAuthStateInCookie\r\n   */\n\n\n  AuthCache.prototype.duplicateCacheEntry = function (newKey, value, storeAuthStateInCookie) {\n    if (value) {\n      this.setItem(newKey, value, storeAuthStateInCookie);\n    }\n  };\n  /**\r\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n   * @param key\r\n   * @param addInstanceId\r\n   */\n\n\n  AuthCache.prototype.generateCacheKey = function (key, addInstanceId) {\n    try {\n      // Defined schemas do not need the key appended\n      JSON.parse(key);\n      return key;\n    } catch (e) {\n      if (key.indexOf(\"\" + Constants.cachePrefix) === 0 || key.indexOf(Constants.adalIdToken) === 0) {\n        return key;\n      }\n\n      return addInstanceId ? Constants.cachePrefix + \".\" + this.clientId + \".\" + key : Constants.cachePrefix + \".\" + key;\n    }\n  };\n  /**\r\n   * Validates that the input cache key contains the account search terms (clientId and homeAccountIdentifier) and\r\n   * then whether or not it contains the \"scopes\", depending on the token type being searched for. With matching account\r\n   * search terms, Access Token search tries to match the \"scopes\" keyword, while Id Token search expects \"scopes\" to not be included.\r\n   * @param key\r\n   * @param clientId\r\n   * @param homeAccountIdentifier\r\n   * @param tokenType\r\n   */\n\n\n  AuthCache.prototype.matchKeyForType = function (key, clientId, homeAccountIdentifier, tokenType) {\n    // All valid token cache item keys are valid JSON objects, ignore keys that aren't\n    var parsedKey = StringUtils.validateAndParseJsonCacheKey(key);\n\n    if (!parsedKey) {\n      return null;\n    } // Does the cache item match the request account\n\n\n    var accountMatches = key.match(clientId) && key.match(homeAccountIdentifier); // Does the cache item match the requested token type\n\n    var tokenTypeMatches = false;\n\n    switch (tokenType) {\n      case ServerHashParamKeys.ACCESS_TOKEN:\n        // Cache item is an access token if scopes are included in the cache item key\n        tokenTypeMatches = !!key.match(Constants.scopes);\n        break;\n\n      case ServerHashParamKeys.ID_TOKEN:\n        // Cache may be an ID token if scopes are NOT included in the cache item key\n        tokenTypeMatches = !key.match(Constants.scopes);\n        break;\n    }\n\n    return accountMatches && tokenTypeMatches ? parsedKey : null;\n  };\n  /**\r\n   * add value to storage\r\n   * @param key\r\n   * @param value\r\n   * @param enableCookieStorage\r\n   */\n\n\n  AuthCache.prototype.setItem = function (key, value, enableCookieStorage) {\n    _super.prototype.setItem.call(this, this.generateCacheKey(key, true), value, enableCookieStorage); // Values stored in cookies will have rollback disabled to minimize cookie length\n\n\n    if (this.rollbackEnabled && !enableCookieStorage) {\n      _super.prototype.setItem.call(this, this.generateCacheKey(key, false), value, enableCookieStorage);\n    }\n  };\n  /**\r\n   * get one item by key from storage\r\n   * @param key\r\n   * @param enableCookieStorage\r\n   */\n\n\n  AuthCache.prototype.getItem = function (key, enableCookieStorage) {\n    return _super.prototype.getItem.call(this, this.generateCacheKey(key, true), enableCookieStorage);\n  };\n  /**\r\n   * remove value from storage\r\n   * @param key\r\n   */\n\n\n  AuthCache.prototype.removeItem = function (key) {\n    _super.prototype.removeItem.call(this, this.generateCacheKey(key, true));\n\n    if (this.rollbackEnabled) {\n      _super.prototype.removeItem.call(this, this.generateCacheKey(key, false));\n    }\n  };\n  /**\r\n   * Reset the cache items\r\n   */\n\n\n  AuthCache.prototype.resetCacheItems = function () {\n    var storage = window[this.cacheLocation];\n    var key;\n\n    for (key in storage) {\n      // Check if key contains msal prefix; For now, we are clearing all cache items created by MSAL.js\n      if (storage.hasOwnProperty(key) && key.indexOf(Constants.cachePrefix) !== -1) {\n        _super.prototype.removeItem.call(this, key); // TODO: Clear cache based on client id (clarify use cases where this is needed)\n\n      }\n    }\n  };\n  /**\r\n   * Reset all temporary cache items\r\n   */\n\n\n  AuthCache.prototype.resetTempCacheItems = function (state) {\n    var _this = this;\n\n    var stateId = state && RequestUtils.parseLibraryState(state).id;\n    var isTokenRenewalInProgress = this.tokenRenewalInProgress(state);\n    var storage = window[this.cacheLocation]; // check state and remove associated cache\n\n    if (stateId && !isTokenRenewalInProgress) {\n      Object.keys(storage).forEach(function (key) {\n        if (key.indexOf(stateId) !== -1) {\n          _this.removeItem(key);\n\n          _super.prototype.clearItemCookie.call(_this, key);\n        }\n      });\n    } // delete the interaction status cache\n\n\n    this.removeItem(TemporaryCacheKeys.INTERACTION_STATUS);\n    this.removeItem(TemporaryCacheKeys.REDIRECT_REQUEST);\n  };\n  /**\r\n   * Set cookies for IE\r\n   * @param cName\r\n   * @param cValue\r\n   * @param expires\r\n   */\n\n\n  AuthCache.prototype.setItemCookie = function (cName, cValue, expires) {\n    _super.prototype.setItemCookie.call(this, this.generateCacheKey(cName, true), cValue, expires);\n\n    if (this.rollbackEnabled) {\n      _super.prototype.setItemCookie.call(this, this.generateCacheKey(cName, false), cValue, expires);\n    }\n  };\n\n  AuthCache.prototype.clearItemCookie = function (cName) {\n    _super.prototype.clearItemCookie.call(this, this.generateCacheKey(cName, true));\n\n    if (this.rollbackEnabled) {\n      _super.prototype.clearItemCookie.call(this, this.generateCacheKey(cName, false));\n    }\n  };\n  /**\r\n   * get one item by key from cookies\r\n   * @param cName\r\n   */\n\n\n  AuthCache.prototype.getItemCookie = function (cName) {\n    return _super.prototype.getItemCookie.call(this, this.generateCacheKey(cName, true));\n  };\n  /**\r\n   * Get all tokens of a certain type from the cache\r\n   * @param clientId\r\n   * @param homeAccountIdentifier\r\n   * @param tokenType\r\n   */\n\n\n  AuthCache.prototype.getAllTokensByType = function (clientId, homeAccountIdentifier, tokenType) {\n    var _this = this;\n\n    var results = Object.keys(window[this.cacheLocation]).reduce(function (tokens, key) {\n      var matchedTokenKey = _this.matchKeyForType(key, clientId, homeAccountIdentifier, tokenType);\n\n      if (matchedTokenKey) {\n        var value = _this.getItem(key);\n\n        if (value) {\n          try {\n            var newAccessTokenCacheItem = new AccessTokenCacheItem(matchedTokenKey, JSON.parse(value));\n            return tokens.concat([newAccessTokenCacheItem]);\n          } catch (err) {\n            // Skip cache items with non-valid JSON values\n            return tokens;\n          }\n        }\n      }\n\n      return tokens;\n    }, []);\n    return results;\n  };\n  /**\r\n   * Get all access tokens in the cache\r\n   * @param clientId\r\n   * @param homeAccountIdentifier\r\n   */\n\n\n  AuthCache.prototype.getAllAccessTokens = function (clientId, homeAccountIdentifier) {\n    return this.getAllTokensByType(clientId, homeAccountIdentifier, ServerHashParamKeys.ACCESS_TOKEN);\n  };\n  /**\r\n   * Get all id tokens in the cache in the form of AccessTokenCacheItem objects so they are\r\n   * in a normalized format and can make use of the existing cached access token validation logic\r\n   */\n\n\n  AuthCache.prototype.getAllIdTokens = function (clientId, homeAccountIdentifier) {\n    return this.getAllTokensByType(clientId, homeAccountIdentifier, ServerHashParamKeys.ID_TOKEN);\n  };\n  /**\r\n   * Get all access and ID tokens in the cache\r\n   * @param clientId\r\n   * @param homeAccountIdentifier\r\n   */\n\n\n  AuthCache.prototype.getAllTokens = function (clientId, homeAccountIdentifier) {\n    var accessTokens = this.getAllAccessTokens(clientId, homeAccountIdentifier);\n    var idTokens = this.getAllIdTokens(clientId, homeAccountIdentifier);\n    return accessTokens.concat(idTokens);\n  };\n  /**\r\n   * Return if the token renewal is still in progress\r\n   *\r\n   * @param stateValue\r\n   */\n\n\n  AuthCache.prototype.tokenRenewalInProgress = function (stateValue) {\n    var renewStatus = this.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, stateValue));\n    return !!(renewStatus && renewStatus === Constants.inProgress);\n  };\n  /**\r\n   * Clear all cookies\r\n   */\n\n\n  AuthCache.prototype.clearMsalCookie = function (state) {\n    var _this = this;\n    /*\r\n     * If state is truthy, remove values associated with that request.\r\n     * Otherwise, remove all MSAL cookies.\r\n     */\n\n\n    if (state) {\n      this.clearItemCookie(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN, state));\n      this.clearItemCookie(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_LOGIN, state));\n      this.clearItemCookie(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.LOGIN_REQUEST, state));\n      this.clearItemCookie(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_ACQ_TOKEN, state));\n    } else {\n      var cookies = document.cookie.split(\";\");\n      cookies.forEach(function (cookieString) {\n        var cookieName = cookieString.trim().split(\"=\")[0];\n\n        if (cookieName.indexOf(Constants.cachePrefix) > -1) {\n          _super.prototype.clearItemCookie.call(_this, cookieName);\n        }\n      });\n    }\n  };\n  /**\r\n   * Create acquireTokenAccountKey to cache account object\r\n   * @param accountId\r\n   * @param state\r\n   */\n\n\n  AuthCache.generateAcquireTokenAccountKey = function (accountId, state) {\n    var stateId = RequestUtils.parseLibraryState(state).id;\n    return \"\" + TemporaryCacheKeys.ACQUIRE_TOKEN_ACCOUNT + Constants.resourceDelimiter + accountId + Constants.resourceDelimiter + stateId;\n  };\n  /**\r\n   * Create authorityKey to cache authority\r\n   * @param state\r\n   */\n\n\n  AuthCache.generateAuthorityKey = function (state) {\n    return AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.AUTHORITY, state);\n  };\n  /**\r\n   * Generates the cache key for temporary cache items, using request state\r\n   * @param tempCacheKey Cache key prefix\r\n   * @param state Request state value\r\n   */\n\n\n  AuthCache.generateTemporaryCacheKey = function (tempCacheKey, state) {\n    // Use the state id (a guid), in the interest of shorter key names, which is important for cookies.\n    var stateId = RequestUtils.parseLibraryState(state).id;\n    return \"\" + tempCacheKey + Constants.resourceDelimiter + stateId;\n  };\n\n  return AuthCache;\n}(BrowserStorage);\n\nexport { AuthCache };","map":{"version":3,"sources":["../../src/cache/AuthCache.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\nimport { Constants, PersistentCacheKeys, TemporaryCacheKeys, ErrorCacheKeys, ServerHashParamKeys } from \"../utils/Constants\";\r\nimport { AccessTokenCacheItem } from \"./AccessTokenCacheItem\";\r\nimport { BrowserStorage } from \"./BrowserStorage\";\r\nimport { RequestUtils } from \"../utils/RequestUtils\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\n/**\r\n * @hidden\r\n */\r\nvar AuthCache = /** @class */ (function (_super) {\r\n    tslib_1.__extends(AuthCache, _super);\r\n    function AuthCache(clientId, cacheLocation, storeAuthStateInCookie) {\r\n        var _this = _super.call(this, cacheLocation) || this;\r\n        _this.clientId = clientId;\r\n        // This is hardcoded to true for now. We may make this configurable in the future\r\n        _this.rollbackEnabled = true;\r\n        _this.migrateCacheEntries(storeAuthStateInCookie);\r\n        return _this;\r\n    }\r\n    /**\r\n     * Support roll back to old cache schema until the next major release: true by default now\r\n     * @param storeAuthStateInCookie\r\n     */\r\n    AuthCache.prototype.migrateCacheEntries = function (storeAuthStateInCookie) {\r\n        var _this = this;\r\n        var idTokenKey = Constants.cachePrefix + \".\" + PersistentCacheKeys.IDTOKEN;\r\n        var clientInfoKey = Constants.cachePrefix + \".\" + PersistentCacheKeys.CLIENT_INFO;\r\n        var errorKey = Constants.cachePrefix + \".\" + ErrorCacheKeys.ERROR;\r\n        var errorDescKey = Constants.cachePrefix + \".\" + ErrorCacheKeys.ERROR_DESC;\r\n        var idTokenValue = _super.prototype.getItem.call(this, idTokenKey);\r\n        var clientInfoValue = _super.prototype.getItem.call(this, clientInfoKey);\r\n        var errorValue = _super.prototype.getItem.call(this, errorKey);\r\n        var errorDescValue = _super.prototype.getItem.call(this, errorDescKey);\r\n        var values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\r\n        var keysToMigrate = [PersistentCacheKeys.IDTOKEN, PersistentCacheKeys.CLIENT_INFO, ErrorCacheKeys.ERROR, ErrorCacheKeys.ERROR_DESC];\r\n        keysToMigrate.forEach(function (cacheKey, index) { return _this.duplicateCacheEntry(cacheKey, values[index], storeAuthStateInCookie); });\r\n    };\r\n    /**\r\n     * Utility function to help with roll back keys\r\n     * @param newKey\r\n     * @param value\r\n     * @param storeAuthStateInCookie\r\n     */\r\n    AuthCache.prototype.duplicateCacheEntry = function (newKey, value, storeAuthStateInCookie) {\r\n        if (value) {\r\n            this.setItem(newKey, value, storeAuthStateInCookie);\r\n        }\r\n    };\r\n    /**\r\n     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n     * @param key\r\n     * @param addInstanceId\r\n     */\r\n    AuthCache.prototype.generateCacheKey = function (key, addInstanceId) {\r\n        try {\r\n            // Defined schemas do not need the key appended\r\n            JSON.parse(key);\r\n            return key;\r\n        }\r\n        catch (e) {\r\n            if (key.indexOf(\"\" + Constants.cachePrefix) === 0 || key.indexOf(Constants.adalIdToken) === 0) {\r\n                return key;\r\n            }\r\n            return addInstanceId ? Constants.cachePrefix + \".\" + this.clientId + \".\" + key : Constants.cachePrefix + \".\" + key;\r\n        }\r\n    };\r\n    /**\r\n     * Validates that the input cache key contains the account search terms (clientId and homeAccountIdentifier) and\r\n     * then whether or not it contains the \"scopes\", depending on the token type being searched for. With matching account\r\n     * search terms, Access Token search tries to match the \"scopes\" keyword, while Id Token search expects \"scopes\" to not be included.\r\n     * @param key\r\n     * @param clientId\r\n     * @param homeAccountIdentifier\r\n     * @param tokenType\r\n     */\r\n    AuthCache.prototype.matchKeyForType = function (key, clientId, homeAccountIdentifier, tokenType) {\r\n        // All valid token cache item keys are valid JSON objects, ignore keys that aren't\r\n        var parsedKey = StringUtils.validateAndParseJsonCacheKey(key);\r\n        if (!parsedKey) {\r\n            return null;\r\n        }\r\n        // Does the cache item match the request account\r\n        var accountMatches = key.match(clientId) && key.match(homeAccountIdentifier);\r\n        // Does the cache item match the requested token type\r\n        var tokenTypeMatches = false;\r\n        switch (tokenType) {\r\n            case ServerHashParamKeys.ACCESS_TOKEN:\r\n                // Cache item is an access token if scopes are included in the cache item key\r\n                tokenTypeMatches = !!key.match(Constants.scopes);\r\n                break;\r\n            case ServerHashParamKeys.ID_TOKEN:\r\n                // Cache may be an ID token if scopes are NOT included in the cache item key\r\n                tokenTypeMatches = !key.match(Constants.scopes);\r\n                break;\r\n        }\r\n        return (accountMatches && tokenTypeMatches) ? parsedKey : null;\r\n    };\r\n    /**\r\n     * add value to storage\r\n     * @param key\r\n     * @param value\r\n     * @param enableCookieStorage\r\n     */\r\n    AuthCache.prototype.setItem = function (key, value, enableCookieStorage) {\r\n        _super.prototype.setItem.call(this, this.generateCacheKey(key, true), value, enableCookieStorage);\r\n        // Values stored in cookies will have rollback disabled to minimize cookie length\r\n        if (this.rollbackEnabled && !enableCookieStorage) {\r\n            _super.prototype.setItem.call(this, this.generateCacheKey(key, false), value, enableCookieStorage);\r\n        }\r\n    };\r\n    /**\r\n     * get one item by key from storage\r\n     * @param key\r\n     * @param enableCookieStorage\r\n     */\r\n    AuthCache.prototype.getItem = function (key, enableCookieStorage) {\r\n        return _super.prototype.getItem.call(this, this.generateCacheKey(key, true), enableCookieStorage);\r\n    };\r\n    /**\r\n     * remove value from storage\r\n     * @param key\r\n     */\r\n    AuthCache.prototype.removeItem = function (key) {\r\n        _super.prototype.removeItem.call(this, this.generateCacheKey(key, true));\r\n        if (this.rollbackEnabled) {\r\n            _super.prototype.removeItem.call(this, this.generateCacheKey(key, false));\r\n        }\r\n    };\r\n    /**\r\n     * Reset the cache items\r\n     */\r\n    AuthCache.prototype.resetCacheItems = function () {\r\n        var storage = window[this.cacheLocation];\r\n        var key;\r\n        for (key in storage) {\r\n            // Check if key contains msal prefix; For now, we are clearing all cache items created by MSAL.js\r\n            if (storage.hasOwnProperty(key) && (key.indexOf(Constants.cachePrefix) !== -1)) {\r\n                _super.prototype.removeItem.call(this, key);\r\n                // TODO: Clear cache based on client id (clarify use cases where this is needed)\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Reset all temporary cache items\r\n     */\r\n    AuthCache.prototype.resetTempCacheItems = function (state) {\r\n        var _this = this;\r\n        var stateId = state && RequestUtils.parseLibraryState(state).id;\r\n        var isTokenRenewalInProgress = this.tokenRenewalInProgress(state);\r\n        var storage = window[this.cacheLocation];\r\n        // check state and remove associated cache\r\n        if (stateId && !isTokenRenewalInProgress) {\r\n            Object.keys(storage).forEach(function (key) {\r\n                if (key.indexOf(stateId) !== -1) {\r\n                    _this.removeItem(key);\r\n                    _super.prototype.clearItemCookie.call(_this, key);\r\n                }\r\n            });\r\n        }\r\n        // delete the interaction status cache\r\n        this.removeItem(TemporaryCacheKeys.INTERACTION_STATUS);\r\n        this.removeItem(TemporaryCacheKeys.REDIRECT_REQUEST);\r\n    };\r\n    /**\r\n     * Set cookies for IE\r\n     * @param cName\r\n     * @param cValue\r\n     * @param expires\r\n     */\r\n    AuthCache.prototype.setItemCookie = function (cName, cValue, expires) {\r\n        _super.prototype.setItemCookie.call(this, this.generateCacheKey(cName, true), cValue, expires);\r\n        if (this.rollbackEnabled) {\r\n            _super.prototype.setItemCookie.call(this, this.generateCacheKey(cName, false), cValue, expires);\r\n        }\r\n    };\r\n    AuthCache.prototype.clearItemCookie = function (cName) {\r\n        _super.prototype.clearItemCookie.call(this, this.generateCacheKey(cName, true));\r\n        if (this.rollbackEnabled) {\r\n            _super.prototype.clearItemCookie.call(this, this.generateCacheKey(cName, false));\r\n        }\r\n    };\r\n    /**\r\n     * get one item by key from cookies\r\n     * @param cName\r\n     */\r\n    AuthCache.prototype.getItemCookie = function (cName) {\r\n        return _super.prototype.getItemCookie.call(this, this.generateCacheKey(cName, true));\r\n    };\r\n    /**\r\n     * Get all tokens of a certain type from the cache\r\n     * @param clientId\r\n     * @param homeAccountIdentifier\r\n     * @param tokenType\r\n     */\r\n    AuthCache.prototype.getAllTokensByType = function (clientId, homeAccountIdentifier, tokenType) {\r\n        var _this = this;\r\n        var results = Object.keys(window[this.cacheLocation]).reduce(function (tokens, key) {\r\n            var matchedTokenKey = _this.matchKeyForType(key, clientId, homeAccountIdentifier, tokenType);\r\n            if (matchedTokenKey) {\r\n                var value = _this.getItem(key);\r\n                if (value) {\r\n                    try {\r\n                        var newAccessTokenCacheItem = new AccessTokenCacheItem(matchedTokenKey, JSON.parse(value));\r\n                        return tokens.concat([newAccessTokenCacheItem]);\r\n                    }\r\n                    catch (err) {\r\n                        // Skip cache items with non-valid JSON values\r\n                        return tokens;\r\n                    }\r\n                }\r\n            }\r\n            return tokens;\r\n        }, []);\r\n        return results;\r\n    };\r\n    /**\r\n     * Get all access tokens in the cache\r\n     * @param clientId\r\n     * @param homeAccountIdentifier\r\n     */\r\n    AuthCache.prototype.getAllAccessTokens = function (clientId, homeAccountIdentifier) {\r\n        return this.getAllTokensByType(clientId, homeAccountIdentifier, ServerHashParamKeys.ACCESS_TOKEN);\r\n    };\r\n    /**\r\n     * Get all id tokens in the cache in the form of AccessTokenCacheItem objects so they are\r\n     * in a normalized format and can make use of the existing cached access token validation logic\r\n     */\r\n    AuthCache.prototype.getAllIdTokens = function (clientId, homeAccountIdentifier) {\r\n        return this.getAllTokensByType(clientId, homeAccountIdentifier, ServerHashParamKeys.ID_TOKEN);\r\n    };\r\n    /**\r\n     * Get all access and ID tokens in the cache\r\n     * @param clientId\r\n     * @param homeAccountIdentifier\r\n     */\r\n    AuthCache.prototype.getAllTokens = function (clientId, homeAccountIdentifier) {\r\n        var accessTokens = this.getAllAccessTokens(clientId, homeAccountIdentifier);\r\n        var idTokens = this.getAllIdTokens(clientId, homeAccountIdentifier);\r\n        return accessTokens.concat(idTokens);\r\n    };\r\n    /**\r\n     * Return if the token renewal is still in progress\r\n     *\r\n     * @param stateValue\r\n     */\r\n    AuthCache.prototype.tokenRenewalInProgress = function (stateValue) {\r\n        var renewStatus = this.getItem(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.RENEW_STATUS, stateValue));\r\n        return !!(renewStatus && renewStatus === Constants.inProgress);\r\n    };\r\n    /**\r\n     * Clear all cookies\r\n     */\r\n    AuthCache.prototype.clearMsalCookie = function (state) {\r\n        var _this = this;\r\n        /*\r\n         * If state is truthy, remove values associated with that request.\r\n         * Otherwise, remove all MSAL cookies.\r\n         */\r\n        if (state) {\r\n            this.clearItemCookie(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN, state));\r\n            this.clearItemCookie(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_LOGIN, state));\r\n            this.clearItemCookie(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.LOGIN_REQUEST, state));\r\n            this.clearItemCookie(AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.STATE_ACQ_TOKEN, state));\r\n        }\r\n        else {\r\n            var cookies = document.cookie.split(\";\");\r\n            cookies.forEach(function (cookieString) {\r\n                var cookieName = cookieString.trim().split(\"=\")[0];\r\n                if (cookieName.indexOf(Constants.cachePrefix) > -1) {\r\n                    _super.prototype.clearItemCookie.call(_this, cookieName);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Create acquireTokenAccountKey to cache account object\r\n     * @param accountId\r\n     * @param state\r\n     */\r\n    AuthCache.generateAcquireTokenAccountKey = function (accountId, state) {\r\n        var stateId = RequestUtils.parseLibraryState(state).id;\r\n        return \"\" + TemporaryCacheKeys.ACQUIRE_TOKEN_ACCOUNT + Constants.resourceDelimiter + accountId + Constants.resourceDelimiter + stateId;\r\n    };\r\n    /**\r\n     * Create authorityKey to cache authority\r\n     * @param state\r\n     */\r\n    AuthCache.generateAuthorityKey = function (state) {\r\n        return AuthCache.generateTemporaryCacheKey(TemporaryCacheKeys.AUTHORITY, state);\r\n    };\r\n    /**\r\n     * Generates the cache key for temporary cache items, using request state\r\n     * @param tempCacheKey Cache key prefix\r\n     * @param state Request state value\r\n     */\r\n    AuthCache.generateTemporaryCacheKey = function (tempCacheKey, state) {\r\n        // Use the state id (a guid), in the interest of shorter key names, which is important for cookies.\r\n        var stateId = RequestUtils.parseLibraryState(state).id;\r\n        return \"\" + tempCacheKey + Constants.resourceDelimiter + stateId;\r\n    };\r\n    return AuthCache;\r\n}(BrowserStorage));\r\nexport { AuthCache };\r\n//# sourceMappingURL=AuthCache.js.map"]},"metadata":{},"sourceType":"module"}