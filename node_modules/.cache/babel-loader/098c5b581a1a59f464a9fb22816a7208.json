{"ast":null,"code":"/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nimport { ClientAuthError } from \"../error/ClientAuthError\";\nimport { UrlUtils } from \"./UrlUtils\";\nimport { TemporaryCacheKeys, Constants } from \"./Constants\";\nimport { TimeUtils } from \"./TimeUtils\";\n\nvar WindowUtils =\n/** @class */\nfunction () {\n  function WindowUtils() {}\n  /**\r\n   * @hidden\r\n   * Checks if the current page is running in an iframe.\r\n   * @ignore\r\n   */\n\n\n  WindowUtils.isInIframe = function () {\n    return window.parent !== window;\n  };\n  /**\r\n   * @hidden\r\n   * Check if the current page is running in a popup.\r\n   * @ignore\r\n   */\n\n\n  WindowUtils.isInPopup = function () {\n    return !!(window.opener && window.opener !== window);\n  };\n  /**\r\n   * @hidden\r\n   * @param prefix\r\n   * @param scopes\r\n   * @param authority\r\n   */\n\n\n  WindowUtils.generateFrameName = function (prefix, requestSignature) {\n    return \"\" + prefix + Constants.resourceDelimiter + requestSignature;\n  };\n  /**\r\n   * @hidden\r\n   * Polls an iframe until it loads a url with a hash\r\n   * @ignore\r\n   */\n\n\n  WindowUtils.monitorIframeForHash = function (contentWindow, timeout, urlNavigate, logger) {\n    return new Promise(function (resolve, reject) {\n      /*\r\n       * Polling for iframes can be purely timing based,\r\n       * since we don't need to account for interaction.\r\n       */\n      var nowMark = TimeUtils.relativeNowMs();\n      var timeoutMark = nowMark + timeout;\n      logger.verbose(\"monitorWindowForIframe polling started\");\n      var intervalId = setInterval(function () {\n        if (TimeUtils.relativeNowMs() > timeoutMark) {\n          logger.error(\"monitorIframeForHash unable to find hash in url, timing out\");\n          logger.errorPii(\"monitorIframeForHash polling timed out for url: \" + urlNavigate);\n          clearInterval(intervalId);\n          reject(ClientAuthError.createTokenRenewalTimeoutError());\n          return;\n        }\n\n        var href;\n\n        try {\n          /*\r\n           * Will throw if cross origin,\r\n           * which should be caught and ignored\r\n           * since we need the interval to keep running while on STS UI.\r\n           */\n          href = contentWindow.location.href;\n        } catch (e) {}\n\n        if (href && UrlUtils.urlContainsHash(href)) {\n          logger.verbose(\"monitorIframeForHash found url in hash\");\n          clearInterval(intervalId);\n          resolve(contentWindow.location.hash);\n        }\n      }, WindowUtils.POLLING_INTERVAL_MS);\n    });\n  };\n  /**\r\n   * @hidden\r\n   * Polls a popup until it loads a url with a hash\r\n   * @ignore\r\n   */\n\n\n  WindowUtils.monitorPopupForHash = function (contentWindow, timeout, urlNavigate, logger) {\n    return new Promise(function (resolve, reject) {\n      /*\r\n       * Polling for popups needs to be tick-based,\r\n       * since a non-trivial amount of time can be spent on interaction (which should not count against the timeout).\r\n       */\n      var maxTicks = timeout / WindowUtils.POLLING_INTERVAL_MS;\n      var ticks = 0;\n      logger.verbose(\"monitorWindowForHash polling started\");\n      var intervalId = setInterval(function () {\n        if (contentWindow.closed) {\n          logger.error(\"monitorWindowForHash window closed\");\n          clearInterval(intervalId);\n          reject(ClientAuthError.createUserCancelledError());\n          return;\n        }\n\n        var href;\n\n        try {\n          /*\r\n           * Will throw if cross origin,\r\n           * which should be caught and ignored\r\n           * since we need the interval to keep running while on STS UI.\r\n           */\n          href = contentWindow.location.href;\n        } catch (e) {} // Don't process blank pages or cross domain\n\n\n        if (!href || href === \"about:blank\") {\n          return;\n        }\n        /*\r\n         * Only run clock when we are on same domain for popups\r\n         * as popup operations can take a long time.\r\n         */\n\n\n        ticks++;\n\n        if (href && UrlUtils.urlContainsHash(href)) {\n          logger.verbose(\"monitorPopupForHash found url in hash\");\n          clearInterval(intervalId);\n          resolve(contentWindow.location.hash);\n        } else if (ticks > maxTicks) {\n          logger.error(\"monitorPopupForHash unable to find hash in url, timing out\");\n          logger.errorPii(\"monitorPopupForHash polling timed out for url: \" + urlNavigate);\n          clearInterval(intervalId);\n          reject(ClientAuthError.createTokenRenewalTimeoutError());\n        }\n      }, WindowUtils.POLLING_INTERVAL_MS);\n    });\n  };\n  /**\r\n   * @hidden\r\n   * Loads iframe with authorization endpoint URL\r\n   * @ignore\r\n   */\n\n\n  WindowUtils.loadFrame = function (urlNavigate, frameName, timeoutMs, logger) {\n    var _this = this;\n    /*\r\n     * This trick overcomes iframe navigation in IE\r\n     * IE does not load the page consistently in iframe\r\n     */\n\n\n    logger.infoPii(\"LoadFrame: \" + frameName);\n    return new Promise(function (resolve, reject) {\n      setTimeout(function () {\n        var frameHandle = _this.loadFrameSync(urlNavigate, frameName, logger);\n\n        if (!frameHandle) {\n          reject(\"Unable to load iframe with name: \" + frameName);\n          return;\n        }\n\n        resolve(frameHandle);\n      }, timeoutMs);\n    });\n  };\n  /**\r\n   * @hidden\r\n   * Loads the iframe synchronously when the navigateTimeFrame is set to `0`\r\n   * @param urlNavigate\r\n   * @param frameName\r\n   * @param logger\r\n   */\n\n\n  WindowUtils.loadFrameSync = function (urlNavigate, frameName, logger) {\n    var frameHandle = WindowUtils.addHiddenIFrame(frameName, logger); // returning to handle null in loadFrame, also to avoid null object access errors\n\n    if (!frameHandle) {\n      return null;\n    } else if (frameHandle.src === \"\" || frameHandle.src === \"about:blank\") {\n      frameHandle.src = urlNavigate;\n      logger.infoPii(\"Frame Name : \" + frameName + \" Navigated to: \" + urlNavigate);\n    }\n\n    return frameHandle;\n  };\n  /**\r\n   * @hidden\r\n   * Adds the hidden iframe for silent token renewal.\r\n   * @ignore\r\n   */\n\n\n  WindowUtils.addHiddenIFrame = function (iframeId, logger) {\n    if (typeof iframeId === \"undefined\") {\n      return null;\n    }\n\n    logger.infoPii(\"Add msal frame to document:\" + iframeId);\n    var adalFrame = document.getElementById(iframeId);\n\n    if (!adalFrame) {\n      if (document.createElement && document.documentElement && window.navigator.userAgent.indexOf(\"MSIE 5.0\") === -1) {\n        var ifr = document.createElement(\"iframe\");\n        ifr.setAttribute(\"id\", iframeId);\n        ifr.setAttribute(\"aria-hidden\", \"true\");\n        ifr.style.visibility = \"hidden\";\n        ifr.style.position = \"absolute\";\n        ifr.style.width = ifr.style.height = \"0\";\n        ifr.style.border = \"0\";\n        ifr.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin allow-forms\");\n        adalFrame = document.getElementsByTagName(\"body\")[0].appendChild(ifr);\n      } else if (document.body && document.body.insertAdjacentHTML) {\n        document.body.insertAdjacentHTML(\"beforeend\", \"<iframe name='\" + iframeId + \"' id='\" + iframeId + \"' style='display:none'></iframe>\");\n      }\n\n      if (window.frames && window.frames[iframeId]) {\n        adalFrame = window.frames[iframeId];\n      }\n    }\n\n    return adalFrame;\n  };\n  /**\r\n   * @hidden\r\n   * Removes a hidden iframe from the page.\r\n   * @ignore\r\n   */\n\n\n  WindowUtils.removeHiddenIframe = function (iframe) {\n    if (document.body === iframe.parentNode) {\n      document.body.removeChild(iframe);\n    }\n  };\n  /**\r\n   * @hidden\r\n   * Find and return the iframe element with the given hash\r\n   * @ignore\r\n   */\n\n\n  WindowUtils.getIframeWithHash = function (hash) {\n    var iframes = document.getElementsByTagName(\"iframe\");\n    var iframeArray = Array.apply(null, Array(iframes.length)).map(function (iframe, index) {\n      return iframes.item(index);\n    }); // eslint-disable-line prefer-spread\n\n    return iframeArray.filter(function (iframe) {\n      try {\n        return iframe.contentWindow.location.hash === hash;\n      } catch (e) {\n        return false;\n      }\n    })[0];\n  };\n  /**\r\n   * @hidden\r\n   * Returns an array of all the popups opened by MSAL\r\n   * @ignore\r\n   */\n\n\n  WindowUtils.getPopups = function () {\n    if (!window.openedWindows) {\n      window.openedWindows = [];\n    }\n\n    return window.openedWindows;\n  };\n  /**\r\n   * @hidden\r\n   * Find and return the popup with the given hash\r\n   * @ignore\r\n   */\n\n\n  WindowUtils.getPopUpWithHash = function (hash) {\n    return WindowUtils.getPopups().filter(function (popup) {\n      try {\n        return popup.location.hash === hash;\n      } catch (e) {\n        return false;\n      }\n    })[0];\n  };\n  /**\r\n   * @hidden\r\n   * Add the popup to the known list of popups\r\n   * @ignore\r\n   */\n\n\n  WindowUtils.trackPopup = function (popup) {\n    WindowUtils.getPopups().push(popup);\n  };\n  /**\r\n   * @hidden\r\n   * Close all popups\r\n   * @ignore\r\n   */\n\n\n  WindowUtils.closePopups = function () {\n    WindowUtils.getPopups().forEach(function (popup) {\n      return popup.close();\n    });\n  };\n  /**\r\n   * @ignore\r\n   *\r\n   * blocks any login/acquireToken calls to reload from within a hidden iframe (generated for silent calls)\r\n   */\n\n\n  WindowUtils.blockReloadInHiddenIframes = function () {\n    // return an error if called from the hidden iframe created by the msal js silent calls\n    if (UrlUtils.urlContainsHash(window.location.hash) && WindowUtils.isInIframe()) {\n      throw ClientAuthError.createBlockTokenRequestsInHiddenIframeError();\n    }\n  };\n  /**\r\n   *\r\n   * @param cacheStorage\r\n   */\n\n\n  WindowUtils.checkIfBackButtonIsPressed = function (cacheStorage) {\n    var redirectCache = cacheStorage.getItem(TemporaryCacheKeys.REDIRECT_REQUEST); // if redirect request is set and there is no hash\n\n    if (redirectCache && !UrlUtils.urlContainsHash(window.location.hash)) {\n      var splitCache = redirectCache.split(Constants.resourceDelimiter);\n      splitCache.shift();\n      var state = splitCache.length > 0 ? splitCache.join(Constants.resourceDelimiter) : null;\n      cacheStorage.resetTempCacheItems(state);\n    }\n  };\n  /**\r\n   * Removes url fragment from browser url\r\n   */\n\n\n  WindowUtils.clearUrlFragment = function () {\n    // Office.js sets history.replaceState to null\n    if (typeof history.replaceState === \"function\") {\n      // Full removes \"#\" from url\n      history.replaceState(null, null, \"\" + window.location.pathname + window.location.search);\n    } else {\n      window.location.hash = \"\";\n    }\n  };\n  /**\r\n   * @hidden\r\n   * Interval in milliseconds that we poll a window\r\n   * @ignore\r\n   */\n\n\n  WindowUtils.POLLING_INTERVAL_MS = 50;\n  return WindowUtils;\n}();\n\nexport { WindowUtils };","map":{"version":3,"sources":["../../src/utils/WindowUtils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { UrlUtils } from \"./UrlUtils\";\r\nimport { TemporaryCacheKeys, Constants } from \"./Constants\";\r\nimport { TimeUtils } from \"./TimeUtils\";\r\nvar WindowUtils = /** @class */ (function () {\r\n    function WindowUtils() {\r\n    }\r\n    /**\r\n     * @hidden\r\n     * Checks if the current page is running in an iframe.\r\n     * @ignore\r\n     */\r\n    WindowUtils.isInIframe = function () {\r\n        return window.parent !== window;\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Check if the current page is running in a popup.\r\n     * @ignore\r\n     */\r\n    WindowUtils.isInPopup = function () {\r\n        return !!(window.opener && window.opener !== window);\r\n    };\r\n    /**\r\n     * @hidden\r\n     * @param prefix\r\n     * @param scopes\r\n     * @param authority\r\n     */\r\n    WindowUtils.generateFrameName = function (prefix, requestSignature) {\r\n        return \"\" + prefix + Constants.resourceDelimiter + requestSignature;\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Polls an iframe until it loads a url with a hash\r\n     * @ignore\r\n     */\r\n    WindowUtils.monitorIframeForHash = function (contentWindow, timeout, urlNavigate, logger) {\r\n        return new Promise(function (resolve, reject) {\r\n            /*\r\n             * Polling for iframes can be purely timing based,\r\n             * since we don't need to account for interaction.\r\n             */\r\n            var nowMark = TimeUtils.relativeNowMs();\r\n            var timeoutMark = nowMark + timeout;\r\n            logger.verbose(\"monitorWindowForIframe polling started\");\r\n            var intervalId = setInterval(function () {\r\n                if (TimeUtils.relativeNowMs() > timeoutMark) {\r\n                    logger.error(\"monitorIframeForHash unable to find hash in url, timing out\");\r\n                    logger.errorPii(\"monitorIframeForHash polling timed out for url: \" + urlNavigate);\r\n                    clearInterval(intervalId);\r\n                    reject(ClientAuthError.createTokenRenewalTimeoutError());\r\n                    return;\r\n                }\r\n                var href;\r\n                try {\r\n                    /*\r\n                     * Will throw if cross origin,\r\n                     * which should be caught and ignored\r\n                     * since we need the interval to keep running while on STS UI.\r\n                     */\r\n                    href = contentWindow.location.href;\r\n                }\r\n                catch (e) { }\r\n                if (href && UrlUtils.urlContainsHash(href)) {\r\n                    logger.verbose(\"monitorIframeForHash found url in hash\");\r\n                    clearInterval(intervalId);\r\n                    resolve(contentWindow.location.hash);\r\n                }\r\n            }, WindowUtils.POLLING_INTERVAL_MS);\r\n        });\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Polls a popup until it loads a url with a hash\r\n     * @ignore\r\n     */\r\n    WindowUtils.monitorPopupForHash = function (contentWindow, timeout, urlNavigate, logger) {\r\n        return new Promise(function (resolve, reject) {\r\n            /*\r\n             * Polling for popups needs to be tick-based,\r\n             * since a non-trivial amount of time can be spent on interaction (which should not count against the timeout).\r\n             */\r\n            var maxTicks = timeout / WindowUtils.POLLING_INTERVAL_MS;\r\n            var ticks = 0;\r\n            logger.verbose(\"monitorWindowForHash polling started\");\r\n            var intervalId = setInterval(function () {\r\n                if (contentWindow.closed) {\r\n                    logger.error(\"monitorWindowForHash window closed\");\r\n                    clearInterval(intervalId);\r\n                    reject(ClientAuthError.createUserCancelledError());\r\n                    return;\r\n                }\r\n                var href;\r\n                try {\r\n                    /*\r\n                     * Will throw if cross origin,\r\n                     * which should be caught and ignored\r\n                     * since we need the interval to keep running while on STS UI.\r\n                     */\r\n                    href = contentWindow.location.href;\r\n                }\r\n                catch (e) { }\r\n                // Don't process blank pages or cross domain\r\n                if (!href || href === \"about:blank\") {\r\n                    return;\r\n                }\r\n                /*\r\n                 * Only run clock when we are on same domain for popups\r\n                 * as popup operations can take a long time.\r\n                 */\r\n                ticks++;\r\n                if (href && UrlUtils.urlContainsHash(href)) {\r\n                    logger.verbose(\"monitorPopupForHash found url in hash\");\r\n                    clearInterval(intervalId);\r\n                    resolve(contentWindow.location.hash);\r\n                }\r\n                else if (ticks > maxTicks) {\r\n                    logger.error(\"monitorPopupForHash unable to find hash in url, timing out\");\r\n                    logger.errorPii(\"monitorPopupForHash polling timed out for url: \" + urlNavigate);\r\n                    clearInterval(intervalId);\r\n                    reject(ClientAuthError.createTokenRenewalTimeoutError());\r\n                }\r\n            }, WindowUtils.POLLING_INTERVAL_MS);\r\n        });\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Loads iframe with authorization endpoint URL\r\n     * @ignore\r\n     */\r\n    WindowUtils.loadFrame = function (urlNavigate, frameName, timeoutMs, logger) {\r\n        var _this = this;\r\n        /*\r\n         * This trick overcomes iframe navigation in IE\r\n         * IE does not load the page consistently in iframe\r\n         */\r\n        logger.infoPii(\"LoadFrame: \" + frameName);\r\n        return new Promise(function (resolve, reject) {\r\n            setTimeout(function () {\r\n                var frameHandle = _this.loadFrameSync(urlNavigate, frameName, logger);\r\n                if (!frameHandle) {\r\n                    reject(\"Unable to load iframe with name: \" + frameName);\r\n                    return;\r\n                }\r\n                resolve(frameHandle);\r\n            }, timeoutMs);\r\n        });\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Loads the iframe synchronously when the navigateTimeFrame is set to `0`\r\n     * @param urlNavigate\r\n     * @param frameName\r\n     * @param logger\r\n     */\r\n    WindowUtils.loadFrameSync = function (urlNavigate, frameName, logger) {\r\n        var frameHandle = WindowUtils.addHiddenIFrame(frameName, logger);\r\n        // returning to handle null in loadFrame, also to avoid null object access errors\r\n        if (!frameHandle) {\r\n            return null;\r\n        }\r\n        else if (frameHandle.src === \"\" || frameHandle.src === \"about:blank\") {\r\n            frameHandle.src = urlNavigate;\r\n            logger.infoPii(\"Frame Name : \" + frameName + \" Navigated to: \" + urlNavigate);\r\n        }\r\n        return frameHandle;\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Adds the hidden iframe for silent token renewal.\r\n     * @ignore\r\n     */\r\n    WindowUtils.addHiddenIFrame = function (iframeId, logger) {\r\n        if (typeof iframeId === \"undefined\") {\r\n            return null;\r\n        }\r\n        logger.infoPii(\"Add msal frame to document:\" + iframeId);\r\n        var adalFrame = document.getElementById(iframeId);\r\n        if (!adalFrame) {\r\n            if (document.createElement &&\r\n                document.documentElement &&\r\n                (window.navigator.userAgent.indexOf(\"MSIE 5.0\") === -1)) {\r\n                var ifr = document.createElement(\"iframe\");\r\n                ifr.setAttribute(\"id\", iframeId);\r\n                ifr.setAttribute(\"aria-hidden\", \"true\");\r\n                ifr.style.visibility = \"hidden\";\r\n                ifr.style.position = \"absolute\";\r\n                ifr.style.width = ifr.style.height = \"0\";\r\n                ifr.style.border = \"0\";\r\n                ifr.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin allow-forms\");\r\n                adalFrame = document.getElementsByTagName(\"body\")[0].appendChild(ifr);\r\n            }\r\n            else if (document.body && document.body.insertAdjacentHTML) {\r\n                document.body.insertAdjacentHTML(\"beforeend\", \"<iframe name='\" + iframeId + \"' id='\" + iframeId + \"' style='display:none'></iframe>\");\r\n            }\r\n            if (window.frames && window.frames[iframeId]) {\r\n                adalFrame = window.frames[iframeId];\r\n            }\r\n        }\r\n        return adalFrame;\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Removes a hidden iframe from the page.\r\n     * @ignore\r\n     */\r\n    WindowUtils.removeHiddenIframe = function (iframe) {\r\n        if (document.body === iframe.parentNode) {\r\n            document.body.removeChild(iframe);\r\n        }\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Find and return the iframe element with the given hash\r\n     * @ignore\r\n     */\r\n    WindowUtils.getIframeWithHash = function (hash) {\r\n        var iframes = document.getElementsByTagName(\"iframe\");\r\n        var iframeArray = Array.apply(null, Array(iframes.length)).map(function (iframe, index) { return iframes.item(index); }); // eslint-disable-line prefer-spread\r\n        return iframeArray.filter(function (iframe) {\r\n            try {\r\n                return iframe.contentWindow.location.hash === hash;\r\n            }\r\n            catch (e) {\r\n                return false;\r\n            }\r\n        })[0];\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Returns an array of all the popups opened by MSAL\r\n     * @ignore\r\n     */\r\n    WindowUtils.getPopups = function () {\r\n        if (!window.openedWindows) {\r\n            window.openedWindows = [];\r\n        }\r\n        return window.openedWindows;\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Find and return the popup with the given hash\r\n     * @ignore\r\n     */\r\n    WindowUtils.getPopUpWithHash = function (hash) {\r\n        return WindowUtils.getPopups().filter(function (popup) {\r\n            try {\r\n                return popup.location.hash === hash;\r\n            }\r\n            catch (e) {\r\n                return false;\r\n            }\r\n        })[0];\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Add the popup to the known list of popups\r\n     * @ignore\r\n     */\r\n    WindowUtils.trackPopup = function (popup) {\r\n        WindowUtils.getPopups().push(popup);\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Close all popups\r\n     * @ignore\r\n     */\r\n    WindowUtils.closePopups = function () {\r\n        WindowUtils.getPopups().forEach(function (popup) { return popup.close(); });\r\n    };\r\n    /**\r\n     * @ignore\r\n     *\r\n     * blocks any login/acquireToken calls to reload from within a hidden iframe (generated for silent calls)\r\n     */\r\n    WindowUtils.blockReloadInHiddenIframes = function () {\r\n        // return an error if called from the hidden iframe created by the msal js silent calls\r\n        if (UrlUtils.urlContainsHash(window.location.hash) && WindowUtils.isInIframe()) {\r\n            throw ClientAuthError.createBlockTokenRequestsInHiddenIframeError();\r\n        }\r\n    };\r\n    /**\r\n     *\r\n     * @param cacheStorage\r\n     */\r\n    WindowUtils.checkIfBackButtonIsPressed = function (cacheStorage) {\r\n        var redirectCache = cacheStorage.getItem(TemporaryCacheKeys.REDIRECT_REQUEST);\r\n        // if redirect request is set and there is no hash\r\n        if (redirectCache && !UrlUtils.urlContainsHash(window.location.hash)) {\r\n            var splitCache = redirectCache.split(Constants.resourceDelimiter);\r\n            splitCache.shift();\r\n            var state = splitCache.length > 0 ? splitCache.join(Constants.resourceDelimiter) : null;\r\n            cacheStorage.resetTempCacheItems(state);\r\n        }\r\n    };\r\n    /**\r\n     * Removes url fragment from browser url\r\n     */\r\n    WindowUtils.clearUrlFragment = function () {\r\n        // Office.js sets history.replaceState to null\r\n        if (typeof history.replaceState === \"function\") {\r\n            // Full removes \"#\" from url\r\n            history.replaceState(null, null, \"\" + window.location.pathname + window.location.search);\r\n        }\r\n        else {\r\n            window.location.hash = \"\";\r\n        }\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Interval in milliseconds that we poll a window\r\n     * @ignore\r\n     */\r\n    WindowUtils.POLLING_INTERVAL_MS = 50;\r\n    return WindowUtils;\r\n}());\r\nexport { WindowUtils };\r\n//# sourceMappingURL=WindowUtils.js.map"]},"metadata":{},"sourceType":"module"}